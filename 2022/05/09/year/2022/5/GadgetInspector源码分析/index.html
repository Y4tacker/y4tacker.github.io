<!DOCTYPE html><html lang="en"><head><meta charset="utf-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="HandheldFriendly" content="True"><meta name="viewport" content="width=device-width,initial-scale=1,maximum-scale=5"><meta name="description" content="GadgetInspector源码分析前置废话我不想搞介绍，就这样吧，写这个主要是网上的对我很晦涩，很多别人觉得简单的我不会，包括一些汇编指令等，当然本篇也是站在很多前辈的肩膀上进行学习，属实是少花了很多功夫 在分析gadgetinspector源码的时候，大概会对各个核心类讲解，并简单分析ASM部分，btw本篇基于jdk8进行分析 当然既然是学习，那么我们肯定是需要跟踪代码的，而GI这款工具属实"><meta property="og:type" content="article"><meta property="og:title" content="GadgetInspector源码分析"><meta property="og:url" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/index.html"><meta property="og:site_name" content="Y4tacker:Hacking The World!"><meta property="og:description" content="GadgetInspector源码分析前置废话我不想搞介绍，就这样吧，写这个主要是网上的对我很晦涩，很多别人觉得简单的我不会，包括一些汇编指令等，当然本篇也是站在很多前辈的肩膀上进行学习，属实是少花了很多功夫 在分析gadgetinspector源码的时候，大概会对各个核心类讲解，并简单分析ASM部分，btw本篇基于jdk8进行分析 当然既然是学习，那么我们肯定是需要跟踪代码的，而GI这款工具属实"><meta property="og:locale" content="en_US"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/17.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/18.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/19.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/21.png-w331s"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/22.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/23.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/24.png"><meta property="og:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/25.png"><meta property="article:published_time" content="2022-05-09T01:56:31.000Z"><meta property="article:modified_time" content="2024-08-04T09:01:49.335Z"><meta property="article:author" content="Y4tacker"><meta property="article:tag" content="Java"><meta property="article:tag" content="自动化"><meta name="twitter:card" content="summary"><meta name="twitter:image" content="https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0.png"><link rel="shortcut icon" href="/images/favicon.ico"><link rel="icon" type="image/png" href="/images/favicon-192x192.png" sizes="192x192"><link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon.png"><title>GadgetInspector源码分析</title><link rel="stylesheet" href="/css/style.css"><meta name="generator" content="Hexo 5.4.1"><link rel="alternate" href="/atom.xml" title="Y4tacker:Hacking The World!" type="application/atom+xml"></head><body class="max-width mx-auto px3 ltr"><div id="header-post"><a id="menu-icon" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="menu-icon-tablet" href="#" aria-label="Menu"><i class="fa-solid fa-bars fa-lg"></i></a> <a id="top-icon-tablet" href="#" aria-label="Top" onclick='$("html, body").animate({scrollTop:0},"fast")' style="display:none"><i class="fa-solid fa-chevron-up fa-lg"></i></a> <span id="menu"><span id="nav"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Topics</a></li><li><a href="/search/">Search</a></li><li><a href="/about/">About</a></li><li><a href="/link/">Friends</a></li></ul></span><br><span id="actions"><ul><li><a class="icon" aria-label="Previous post" href="/2022/05/16/year/2022/5/JspWebShell%E6%96%B0%E5%A7%BF%E5%8A%BF%E8%A7%A3%E8%AF%BB/"><i class="fa-solid fa-chevron-left" aria-hidden="true" onmouseover='$("#i-prev").toggle()' onmouseout='$("#i-prev").toggle()'></i></a></li><li><a class="icon" aria-label="Next post" href="/2022/05/05/year/2022/5/%E5%86%99%E7%BB%99%E8%87%AA%E5%B7%B1%E7%9A%842021%E5%B9%B4%E7%BB%88%E6%80%BB%E7%BB%93/"><i class="fa-solid fa-chevron-right" aria-hidden="true" onmouseover='$("#i-next").toggle()' onmouseout='$("#i-next").toggle()'></i></a></li><li><a class="icon" aria-label="Back to top" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up" aria-hidden="true" onmouseover='$("#i-top").toggle()' onmouseout='$("#i-top").toggle()'></i></a></li><li><a class="icon" aria-label="Share post" href="#"><i class="fa-solid fa-share-alt" aria-hidden="true" onmouseover='$("#i-share").toggle()' onmouseout='$("#i-share").toggle()' onclick='return $("#share").toggle(),!1'></i></a></li></ul><span id="i-prev" class="info" style="display:none">Previous post</span> <span id="i-next" class="info" style="display:none">Next post</span> <span id="i-top" class="info" style="display:none">Back to top</span> <span id="i-share" class="info" style="display:none">Share post</span></span><br><div id="share" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&text=GadgetInspector源码分析"><i class="fab fa-twitter" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-linkedin" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&is_video=false&description=GadgetInspector源码分析"><i class="fab fa-pinterest" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=GadgetInspector源码分析&body=Check out this article: https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-get-pocket" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-reddit" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-stumbleupon" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-digg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&name=GadgetInspector源码分析&description="><i class="fab fa-tumblr" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&t=GadgetInspector源码分析"><i class="fab fa-hacker-news" aria-hidden="true"></i></a></li></ul></div><div id="toc"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">GadgetInspector源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%BA%9F%E8%AF%9D"><span class="toc-number">1.1.</span> <span class="toc-text">前置废话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASM%E9%83%A8%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">ASM部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FJVM%E6%A0%88%E5%B8%A7%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">模拟JVM栈帧变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassVisitor"><span class="toc-number">1.2.2.</span> <span class="toc-text">ClassVisitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MethodVisitor"><span class="toc-number">1.2.3.</span> <span class="toc-text">MethodVisitor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MethodDiscovery"><span class="toc-number">1.3.1.</span> <span class="toc-text">MethodDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PassthroughDiscovery"><span class="toc-number">1.3.2.</span> <span class="toc-text">PassthroughDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallGraphDiscovery"><span class="toc-number">1.3.3.</span> <span class="toc-text">CallGraphDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceDiscovery"><span class="toc-number">1.3.4.</span> <span class="toc-text">SourceDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GadgetChainDiscovery"><span class="toc-number">1.3.5.</span> <span class="toc-text">GadgetChainDiscovery</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-number">1.4.</span> <span class="toc-text">题外话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Edup%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.1.</span> <span class="toc-text">关于dup指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECC"><span class="toc-number">1.4.2.</span> <span class="toc-text">关于CC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.5.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></div></span></div><div class="content index py4"><article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting"><header><h1 class="posttitle p-name" itemprop="name headline">GadgetInspector源码分析</h1><div class="meta"><span class="author p-author h-card" itemprop="author" itemscope itemtype="http://schema.org/Person"><span class="p-name" itemprop="name">Y4tacker</span></span><div class="postdate"><time datetime="2022-05-09T01:56:31.000Z" class="dt-published" itemprop="datePublished">2022-05-09</time> (Updated: <time datetime="2024-08-04T09:01:49.335Z" class="dt-updated" itemprop="dateModified">2024-08-04</time>)</div><div class="article-category"><i class="fa-solid fa-archive"></i> <a class="category-link" href="/categories/Java/">Java</a></div><div class="article-tag"><i class="fa-solid fa-tag"></i> <a class="p-category" href="/tags/Java/" rel="tag">Java</a>, <a class="p-category" href="/tags/%E8%87%AA%E5%8A%A8%E5%8C%96/" rel="tag">自动化</a></div></div></header><div class="content e-content" itemprop="articleBody"><h1 id="GadgetInspector源码分析"><a href="#GadgetInspector源码分析" class="headerlink" title="GadgetInspector源码分析"></a>GadgetInspector源码分析</h1><h2 id="前置废话"><a href="#前置废话" class="headerlink" title="前置废话"></a>前置废话</h2><p>我不想搞介绍，就这样吧，写这个主要是网上的对我很晦涩，很多别人觉得简单的我不会，包括一些汇编指令等，当然本篇也是站在很多前辈的肩膀上进行学习，属实是少花了很多功夫</p><p>在分析gadgetinspector源码的时候，大概会对各个核心类讲解，并简单分析ASM部分，btw本篇基于jdk8进行分析</p><p>当然既然是学习，那么我们肯定是需要跟踪代码的，而GI这款工具属实头疼，本身不仅引入了jdk的一些依赖如rt.jar，在调试的过程当中也出现了gadgetinspector当中的类，属实不适合学习时使用，为了解决这个问题，我在<code>gadgetinspector.ClassResourceEnumerator#getAllClasses</code>当中将源码修改如此，这样我便能自行写代码逻辑，并展开学习，我个人认为化繁为简也是一个很重要的过程，如下我剔除了jdk原本的类，并且要求全类名包含特定字符，因此解决了这个问题，当然在具体使用的时候还是要替换回来</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> Collection&lt;ClassResource&gt; <span class="title">getAllClasses</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//        Collection&lt;ClassResource&gt; result = new ArrayList&lt;&gt;(getRuntimeClasses());</span></span><br><span class="line">  Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line">  <span class="keyword">if</span> (ConfigHelper.onlyJDK)</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">    <span class="keyword">if</span> (classInfo.getName().contains(<span class="string">&quot;yyds&quot;</span>))&#123;</span><br><span class="line">      result.add(<span class="keyword">new</span> ClassLoaderClassResource(classLoader, classInfo.getResourceName()));</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>可以看到经过简单的优化，过程也更加清晰，但是在后面有些地方需要改回来不然得不到正确结果，这里是为了分析所以暂时改一下</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/0.png"></p><p>在学习的时候配合反汇编代码会更容易理解，Java也自带了查看的方法<code>javap -c 类名</code></p><p>lol，多逼逼一句一定要在熟悉jvm stack和本地变量表，不然很多逻辑会是懵的</p><h2 id="ASM部分"><a href="#ASM部分" class="headerlink" title="ASM部分"></a>ASM部分</h2><p>这部分不建议直接看，建议在后面看到具体部分再来看看</p><h3 id="模拟JVM栈帧变化"><a href="#模拟JVM栈帧变化" class="headerlink" title="模拟JVM栈帧变化"></a>模拟JVM栈帧变化</h3><p>这部分很重要如果搞不明白后面在看GI代码的时候会很懵逼</p><p>在程序运行的过程中，每一个线程都对应一个属于自己的JVM Stack。当一个新线程开始时会在内存上分配一个属于自己的JVM Stack；当该线程执行结束后，相应的JVM Stack内存空间也就被回收了。</p><p>在JVM Stack当中，是栈的结构，里面存储的是frames；每一个frame空间可以称之为Stack Frame。当调用一个新方法的时候，就会在JVM Stack上分配一个frame空间；当方法退出时，相应的frame空间也会JVM Stack上进行清除掉（出栈操作）。在frame空间当中，有两个重要的结构，即local variables（一个索引从0开始的数组）和operand stack（栈的结构）。对于每一个方法来说，它都是在自己的Stack Frame上来运行的，在编译的时候，就决定了local variables和operand stack的大小。</p><p>这里特别要注意在方法刚开始的时候，operand stack是空，不需要存储任何的数据，而local variables的初始状态，则需要考虑三个因素：</p><ul><li>当前方法是否为static方法。如果当前方法是non-static方法，则需要在local variables索引为0的位置存在一个this变量；如果当前方法是static方法，则不需要存储this。</li><li>当前方法是否接收参数。方法接收的参数，会按照参数的声明顺序放到local variables当中。</li><li>方法参数是否包含long或double类型。如果方法的参数是long或double类型，那么它在local variables当中占用两个位置。</li></ul><p>这里推荐一个IDEA的插件<code>ASM Bytecode Viewer</code>，可以很方便配合学习理解，同时如果需要查当中的汇编指令的含义也很简单，去官网看看就好<a target="_blank" rel="noopener" href="https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html">https://docs.oracle.com/javase/specs/jvms/se15/html/jvms-6.html</a></p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/1.png"></p><h3 id="ClassVisitor"><a href="#ClassVisitor" class="headerlink" title="ClassVisitor"></a>ClassVisitor</h3><p>我们只要知道在ClassVisitor类当中，定义的visitXxx()方法中的参数与ClassFile结构密切相关就很关键了</p><p>首先看看里面的字段</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">  	<span class="comment">//指出了当前使用的ASM API版本</span></span><br><span class="line">    <span class="keyword">protected</span> <span class="keyword">final</span> <span class="keyword">int</span> api;</span><br><span class="line">  	<span class="comment">//一个ClassVisitor类型的数据，可以将多个ClassVisitor串连起来</span></span><br><span class="line">    <span class="keyword">protected</span> ClassVisitor cv;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>ClassVisitor当中许多的visitXxx()方法，这些visitXxx()方法与<code>ClassFile</code>的结构密切相关，而这下面四个才是我们关注的主体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="class"><span class="keyword">class</span> <span class="title">ClassVisitor</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visit</span><span class="params">(</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">int</span> version,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String superName,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String[] interfaces)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> FieldVisitor <span class="title">visitField</span><span class="params">( // 访问字段</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> Object value)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">( // 访问方法</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> <span class="keyword">int</span> access,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String name,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String descriptor,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String signature,</span></span></span><br><span class="line"><span class="params"><span class="function">        <span class="keyword">final</span> String[] exceptions)</span></span>;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitEnd</span><span class="params">()</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中signature为类签名（非泛型为NUll），同时visitXxx()方法，也有调用顺序，了解下就好，结合这个调用顺序，GI的这部分代码就很好懂了</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">visit</span><br><span class="line">[visitSource][visitModule][visitNestHost][visitPermittedSubclass][visitOuterClass]</span><br><span class="line">(</span><br><span class="line"> visitAnnotation |</span><br><span class="line"> visitTypeAnnotation |</span><br><span class="line"> visitAttribute</span><br><span class="line">)*</span><br><span class="line">(</span><br><span class="line"> visitNestMember |</span><br><span class="line"> visitInnerClass |</span><br><span class="line"> visitRecordComponent |</span><br><span class="line"> visitField |</span><br><span class="line"> visitMethod</span><br><span class="line">)* </span><br><span class="line">visitEnd</span><br></pre></td></tr></table></figure><h3 id="MethodVisitor"><a href="#MethodVisitor" class="headerlink" title="MethodVisitor"></a>MethodVisitor</h3><p>和上面很多部分相似，我们直接入正文，也是有很多关键的visitxxx方法，对一些我们需要的做个精简的调用，看英文名称就能知道意思就不多说每个部分了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">(visitParameter)*</span><br><span class="line">[visitAnnotationDefault]</span><br><span class="line">(visitAnnotation | visitAnnotableParameterCount | visitParameterAnnotation | visitTypeAnnotation | visitAttribute)*</span><br><span class="line">[</span><br><span class="line">    visitCode</span><br><span class="line">    (</span><br><span class="line">        visitFrame<span class="comment">//访问当前局部变量表和操作数栈中元素的状态，参数就是局部变量表和操作数栈的内容 |</span></span><br><span class="line">        visitXxxInsn |</span><br><span class="line">        visitLabel |</span><br><span class="line">        visitInsnAnnotation |</span><br><span class="line">        visitTryCatchBlock |</span><br><span class="line">        visitTryCatchAnnotation |</span><br><span class="line">        visitLocalVariable |</span><br><span class="line">        visitLocalVariableAnnotation |</span><br><span class="line">        visitLineNumber</span><br><span class="line">    )*</span><br><span class="line">    visitMaxs</span><br><span class="line">]</span><br></pre></td></tr></table></figure><p>这里主要记录下visitxxxInsn</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">visitFieldInsn ： 访问某个成员变量的指令，支持GETSTATIC, PUTSTATIC, GETFIELD or PUTFIELD.</span><br><span class="line">visitIincInsn ： 访问自增指令</span><br><span class="line">visitVarInsn ：访问局部变量指令，就是取局部变量变的值放入操作数栈</span><br><span class="line">visitMethodInsn ：访问方法指令，就是调用某个方法，支持INVOKEVIRTUAL, INVOKESPECIAL, INVOKESTATIC or INVOKEINTERFACE.</span><br><span class="line">visitInsn ： 访问无操作数的指令，例如nop，duo等等</span><br><span class="line">visitTypeInsn：访问type指令，即将一个类的全限定名作为参数然后<span class="keyword">new</span>一个对象压入操作数栈中</span><br></pre></td></tr></table></figure><p>在GI当中我们主要关心visitMethodInsn，顺便说一些相关指令其中invokestatic用来调用静态方法；invokespecial用来调用私有方法，父类方法(super.)，类构造器方法；invokeinterface调用接口方法；invokedynamic方法动态执行；invokevirtual调用所有虚方法，即除了以上的方法外全用invokevirtual调用。</p><h2 id="分析"><a href="#分析" class="headerlink" title="分析"></a>分析</h2><p>下面根据流程分析具体的类当中的操作</p><h3 id="MethodDiscovery"><a href="#MethodDiscovery" class="headerlink" title="MethodDiscovery"></a>MethodDiscovery</h3><p>这个方法主要是获得类以及方法的信息</p><p>其中在methods.dat里面按照指定格式记录：类名、方法名、参数以及返回值、是否为静态方法</p><p>在classes.dat里面按照指定格式记录：类名、父类名、实现的接口名、是否为接口、类的所有字段、注解名</p><p>看了下main函数的主体</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ClassLoader classLoader = Util.getWarClassLoader(Paths.get(<span class="string">&quot;/Users/y4tacker/Desktop/test/shorter-0.0.1-SNAPSHOT.jar&quot;</span>));</span><br><span class="line">MethodDiscovery methodDiscovery = <span class="keyword">new</span> MethodDiscovery();</span><br><span class="line">methodDiscovery.discover(<span class="keyword">new</span> ClassResourceEnumerator(classLoader));</span><br><span class="line">methodDiscovery.save();</span><br></pre></td></tr></table></figure><p>首先第一行的<code>gadgetinspector.Util#getWarClassLoader</code>不是很难不贴代码了，首先创建了一个临时文件夹，通过addShutdownHook在jvm shutdown自动删除，之后将jar/war的文件解压到临时文件夹，并配置/资源文件的路径，并返回URLClassLoader</p><p>之后调用<code>gadgetinspector.MethodDiscovery#discover</code>，可以看出通过foreach遍历，之后使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator)</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">    <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">      ClassReader cr = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">      <span class="keyword">try</span> &#123;</span><br><span class="line">        <span class="comment">//使用asm的ClassVisitor、MethodVisitor，利用观察模式去扫描所有的class和method并记录</span></span><br><span class="line">        cr.accept(<span class="keyword">new</span> MethodDiscoveryClassVisitor(), ClassReader.EXPAND_FRAMES);</span><br><span class="line">      &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">        LOGGER.error(<span class="string">&quot;Exception analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">      &#125;</span><br><span class="line">    &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">      e.printStackTrace();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>调用<code>gadgetinspector.ClassResourceEnumerator#getAllClasses</code>，首先里面调用了*getRuntimeClasses()*函数</p><p>可以看到核心代码</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">URL stringClassUrl = Object.class.getResource(<span class="string">&quot;String.class&quot;</span>);</span><br><span class="line">URLConnection connection = stringClassUrl.openConnection();</span><br><span class="line">Collection&lt;ClassResource&gt; result = <span class="keyword">new</span> ArrayList&lt;&gt;();</span><br><span class="line"><span class="keyword">if</span> (connection <span class="keyword">instanceof</span> JarURLConnection) &#123;</span><br><span class="line">  URL runtimeUrl = ((JarURLConnection) connection).getJarFileURL();</span><br><span class="line">  URLClassLoader classLoader = <span class="keyword">new</span> URLClassLoader(<span class="keyword">new</span> URL[]&#123;runtimeUrl&#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (ClassPath.ClassInfo classInfo : ClassPath.from(classLoader).getAllClasses()) &#123;</span><br><span class="line">    result.add(<span class="keyword">new</span> ClassLoaderClassResource(classLoader, classInfo.getResourceName()));</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>他先获取JDK内部的String类的路径，加载String类的同时，类加载器还会将rt.jar的全部类一起加载，最后将rt.jar当中的所有类加入到ClassResource类型的result并且返回</p><p>之后也就是一个继承了ClassVisitor的MethodDiscoveryClassVisitor分别在visitMethod和visitEnd依次添加方法和类到缓存</p><p>之后就是调用save方法保存到文件</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">save</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">    <span class="comment">//保存和读取使用Factory实现</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">//classes.dat数据格式：</span></span><br><span class="line">    <span class="comment">//类名(例：java/lang/String) 父类 接口A,接口B,接口C 是否接口 字段1!字段1access!字段1类型!字段2!字段2access!字段1类型</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;classes.dat&quot;</span>), <span class="keyword">new</span> ClassReference.Factory(), discoveredClasses);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//methods.dat数据格式：</span></span><br><span class="line">    <span class="comment">//类名 方法名 方法描述 是否静态方法</span></span><br><span class="line">    DataLoader.saveData(Paths.get(<span class="string">&quot;methods.dat&quot;</span>), <span class="keyword">new</span> MethodReference.Factory(), discoveredMethods);</span><br><span class="line"></span><br><span class="line">    <span class="comment">//形成 类名(ClassReference.Handle)-&gt;类(ClassReference) 的映射关系</span></span><br><span class="line">    Map&lt;ClassReference.Handle, ClassReference&gt; classMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassReference clazz : discoveredClasses) &#123;</span><br><span class="line">        classMap.put(clazz.getHandle(), clazz);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//保存classes.dat和methods.dat的同时，对所有的class进行递归整合，得到集合&#123;class:[subclass]&#125;，</span></span><br><span class="line">    <span class="comment">// 递归寻找class的父类、超类或实现的接口类，保存至inheritanceMap.dat</span></span><br><span class="line">    InheritanceDeriver.derive(classMap).save();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="PassthroughDiscovery"><a href="#PassthroughDiscovery" class="headerlink" title="PassthroughDiscovery"></a>PassthroughDiscovery</h3><p>这个类用来寻找函数的第几个参数能控制返回值：</p><p>0代表this、1-n分别代表第几个函数当中的形参</p><p>我们主要来关注gadgetinspector.PassthroughDiscovery#discover，先简单看看逻辑</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator, <span class="keyword">final</span> GIConfig config)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  <span class="comment">//加载文件记录的所有方法信息</span></span><br><span class="line">  Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">  <span class="comment">//加载文件记录的所有类信息</span></span><br><span class="line">  Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">  <span class="comment">//加载文件记录的所有类继承、实现关联信息</span></span><br><span class="line">  InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">  <span class="comment">//搜索方法间的调用关系，缓存至methodCalls集合，返回 类名-&gt;类资源 映射集合</span></span><br><span class="line">  Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourceByName = discoverMethodCalls(classResourceEnumerator);</span><br><span class="line">  <span class="comment">//对方法调用关系进行字典排序</span></span><br><span class="line">  List&lt;MethodReference.Handle&gt; sortedMethods = topologicallySortMethodCalls();</span><br><span class="line">  <span class="comment">/**</span></span><br><span class="line"><span class="comment">         * classResourceByName：类资源集合</span></span><br><span class="line"><span class="comment">         * classMap：类信息集合</span></span><br><span class="line"><span class="comment">         * inheritanceMap：继承、实现关系集合</span></span><br><span class="line"><span class="comment">         * sortedMethods：方法集合</span></span><br><span class="line"><span class="comment">         * SerializableDecider：决策者</span></span><br><span class="line"><span class="comment">         */</span></span><br><span class="line">  passthroughDataflow = calculatePassthroughDataflow(classResourceByName, classMap, inheritanceMap, sortedMethods,</span><br><span class="line">                                                     config.getSerializableDecider(methodMap, inheritanceMap));</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>跳过加载文件的部分，我们来看gadgetinspector.PassthroughDiscovery#discoverMethodCalls</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> Map&lt;String, ClassResourceEnumerator.ClassResource&gt; discoverMethodCalls(<span class="keyword">final</span> ClassResourceEnumerator classResourceEnumerator) <span class="keyword">throws</span> IOException &#123;</span><br><span class="line">    Map&lt;String, ClassResourceEnumerator.ClassResource&gt; classResourcesByName = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">    <span class="keyword">for</span> (ClassResourceEnumerator.ClassResource classResource : classResourceEnumerator.getAllClasses()) &#123;</span><br><span class="line">        <span class="keyword">try</span> (InputStream in = classResource.getInputStream()) &#123;</span><br><span class="line">            ClassReader cr = <span class="keyword">new</span> ClassReader(in);</span><br><span class="line">            <span class="keyword">try</span> &#123;</span><br><span class="line">                MethodCallDiscoveryClassVisitor visitor = <span class="keyword">new</span> MethodCallDiscoveryClassVisitor(Opcodes.ASM6);</span><br><span class="line">                cr.accept(visitor, ClassReader.EXPAND_FRAMES);</span><br><span class="line">                classResourcesByName.put(visitor.getName(), classResource);</span><br><span class="line">            &#125; <span class="keyword">catch</span> (Exception e) &#123;</span><br><span class="line">                LOGGER.error(<span class="string">&quot;Error analyzing: &quot;</span> + classResource.getName(), e);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> classResourcesByName;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>很相似直接跟进<em>MethodCallDiscoveryClassVisitor</em>，其中重要的是<code>gadgetinspector.PassthroughDiscovery.MethodCallDiscoveryClassVisitor#visitMethod</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> MethodVisitor <span class="title">visitMethod</span><span class="params">(<span class="keyword">int</span> access, String name, String desc,</span></span></span><br><span class="line"><span class="params"><span class="function">                                 String signature, String[] exceptions)</span> </span>&#123;</span><br><span class="line">  MethodVisitor mv = <span class="keyword">super</span>.visitMethod(access, name, desc, signature, exceptions);</span><br><span class="line">  <span class="comment">//在visit每个method的时候，创建MethodVisitor对method进行观察</span></span><br><span class="line">  MethodCallDiscoveryMethodVisitor modelGeneratorMethodVisitor = <span class="keyword">new</span> MethodCallDiscoveryMethodVisitor(</span><br><span class="line">    api, mv, <span class="keyword">this</span>.name, name, desc);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> JSRInlinerAdapter(modelGeneratorMethodVisitor, access, name, desc, signature, exceptions);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在MethodCallDiscoveryMethodVisitor内重写了MethodCallDiscoveryMethodVisitor的visitMethodInsn方法，也就是在方法内调用其他方法时，会把方法的相关信息缓存到calledMethods</p><p>并且这个calledMethods之前在MethodCallDiscoveryMethodVisitor的初始化构造函数当中将calledMethods的引用也放到了类的成员变量methodCalls当中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="title">MethodCallDiscoveryMethodVisitor</span><span class="params">(<span class="keyword">final</span> <span class="keyword">int</span> api, <span class="keyword">final</span> MethodVisitor mv,</span></span></span><br><span class="line"><span class="params"><span class="function">                                        <span class="keyword">final</span> String owner, String name, String desc)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>(api, mv);</span><br><span class="line"></span><br><span class="line">  <span class="comment">//创建calledMethod收集调用到的method，最后形成集合&#123;&#123;sourceClass,sourceMethod&#125;:[&#123;targetClass,targetMethod&#125;]&#125;</span></span><br><span class="line">  <span class="keyword">this</span>.calledMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  methodCalls.put(<span class="keyword">new</span> MethodReference.Handle(<span class="keyword">new</span> ClassReference.Handle(owner), name, desc), calledMethods);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来就是最重要的逆拓扑排序topologicallySortMethodCalls，这个步骤对于我们之后污点跟踪非常重要，可以看看知道<a target="_blank" rel="noopener" href="https://paper.seebug.org/1034/">创宇404的文章</a>非常好，这里为了文章清晰将直接复制相关部分</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> List&lt;MethodReference.Handle&gt; topologicallySortMethodCalls() &#123;</span><br><span class="line">  Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodCalls.entrySet()) &#123;</span><br><span class="line">    MethodReference.Handle method = entry.getKey();</span><br><span class="line">    outgoingReferences.put(method, <span class="keyword">new</span> HashSet&lt;&gt;(entry.getValue()));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// Topological sort methods</span></span><br><span class="line">  LOGGER.debug(<span class="string">&quot;Performing topological sort...&quot;</span>);</span><br><span class="line">  Set&lt;MethodReference.Handle&gt; dfsStack = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  Set&lt;MethodReference.Handle&gt; visitedNodes = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">  List&lt;MethodReference.Handle&gt; sortedMethods = <span class="keyword">new</span> ArrayList&lt;&gt;(outgoingReferences.size());</span><br><span class="line">  <span class="keyword">for</span> (MethodReference.Handle root : outgoingReferences.keySet()) &#123;</span><br><span class="line">    <span class="comment">//遍历集合中的起始方法，进行递归搜索DFS，通过逆拓扑排序，调用链的最末端排在最前面，</span></span><br><span class="line">    <span class="comment">// 这样才能实现入参、返回值、函数调用链之间的污点影响</span></span><br><span class="line">    dfsTsort(outgoingReferences, sortedMethods, visitedNodes, dfsStack, root);</span><br><span class="line">  &#125;</span><br><span class="line">  LOGGER.debug(String.format(<span class="string">&quot;Outgoing references %d, sortedMethods %d&quot;</span>, outgoingReferences.size(), sortedMethods.size()));</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sortedMethods;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>在代码当中，首先有三个重要的变量</p><ul><li>dfsStack：用来分析方法调用顺序，保证在逆拓扑时候不形成环</li><li>visitedNodes：访问过的结点，在一条调用链出现重合的时候，不会造成重复的排序</li><li>sortedMethods：最终逆拓扑排序出来的结果</li></ul><p>接下来我们详细看看dfsTsort，可以看到是一个递归的过程</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">dfsTsort</span><span class="params">(Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; outgoingReferences,</span></span></span><br><span class="line"><span class="params"><span class="function">                             List&lt;MethodReference.Handle&gt; sortedMethods, Set&lt;MethodReference.Handle&gt; visitedNodes,</span></span></span><br><span class="line"><span class="params"><span class="function">                             Set&lt;MethodReference.Handle&gt; stack, MethodReference.Handle node)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (stack.contains(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">if</span> (visitedNodes.contains(node)) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">//根据起始方法，取出被调用的方法集</span></span><br><span class="line">  Set&lt;MethodReference.Handle&gt; outgoingRefs = outgoingReferences.get(node);</span><br><span class="line">  <span class="keyword">if</span> (outgoingRefs == <span class="keyword">null</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">//入栈，以便于递归不造成类似循环引用的死循环整合</span></span><br><span class="line">  stack.add(node);</span><br><span class="line">  <span class="keyword">for</span> (MethodReference.Handle child : outgoingRefs) &#123;</span><br><span class="line">    dfsTsort(outgoingReferences, sortedMethods, visitedNodes, stack, child);</span><br><span class="line">  &#125;</span><br><span class="line">  stack.remove(node);</span><br><span class="line">  visitedNodes.add(node);<span class="comment">//记录已被探索过的方法，用于在上层调用遇到重复方法时可以跳过</span></span><br><span class="line">  sortedMethods.add(node);<span class="comment">//递归完成的探索，会添加进来</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>为了防止在逆拓扑排序形成环，对于待分析的方法，如果在stack里面，则不再入栈了，如果之前已经分析过某方法，也不会再入栈，之后取出被调用的子方法集，遍历这个子方法集递归调用dfsTsort，最后将结果保存到sortedMethods</p><p>比较形象的过程看创宇里的图，配合理解代码就不难了</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/2.png"></p><p>对上图进行逆拓扑排序（DFS方式）：</p><p>从med1开始，先将med1加入stack中，此时stack、visited、sortedmethods状态如下：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/3.png"></p><p>med1还有子方法？有，继续深度遍历。将med2放入stack，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/4.png"></p><p>med3有子方法吗？有，继续深度遍历。将med7放入stack，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/5.png-w331s"></p><p>med7有子方法吗？没有，从stack中弹出med7并加入visited和sortedmethods，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/6.png-w331s"></p><p>回溯到上一层，med3还有其他子方法吗？有，med8，将med8放入stack，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/7.png-w331s"></p><p>med8还有子方法吗？没有，弹出stack，加入visited与sortedmethods，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/8.png-w331s"></p><p>回溯到上一层，med3还有其他子方法吗？没有了，弹出stack，加入visited与sortedmethods，此时的状态：</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/9.png-w331s"></p><p>一直类似上面的过程，得到最终结果：med7、med8、med3、med6、med2、med4、med1</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/10.png-w331s"></p><p>之后的过程就是调用calculatePassthroughDataflow，其中遍历了sortedmethods，并通过字节码分析，生成了方法返回值与参数关系的passthrough数据流(passthroughDataflow主要负责存储参数污染结果，key对应方法名，value对应的是这个方法中可以被污染的参数索引集合)，内置了三种反序列化的策略配置config类：JDK、Jackson、Xstream，这里我只分析默认的JDK反序列化，其他过程都是类似的，继续回到正题</p><p>，ok还是为了减少干扰，我又在函数逻辑稍作修改，因为上文提到过我们跟踪的代码是</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yyds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Main</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">main</span><span class="params">(String args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        String cmd = <span class="keyword">new</span> A().method1(args);</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> B().method2(cmd);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method1</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">B</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method2</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="keyword">new</span> C().method3(param);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method3</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>肉眼可得与构造函数无关，接下来我们具体看看函数<code>calculatePassthroughDataflow</code>做了些什么</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/11.png"></p><p>根据代码逻辑我们可以看出首先会跳过静态初始化代码(因为静态代码块不出意外基本上是没法被污染的)</p><p>接下来在遍历的每个方法时，会先获取它的所属类，传入函数<code>PassthroughDataflowClassVisitor</code>进行ASM访问者模式的分析，这里我们依然重点关注的是visitMethod函数，这里首先需要目标是需要观察的method，否则跳过<img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/12.png"></p><p>之后会传入<code>PassthroughDataflowMethodVisitor</code>做进一步的处理，在<code>JSRInlinerAdapter</code>的最后执行<code>visitEnd</code>会触发这个观察过程，猜测这样做的目的是便于筛选，便于观察目的类</p><p>那么我们来具体看看这个<code>PassthroughDataflowMethodVisitor</code>类，首先它是继承于父类<code>TaintTrackingMethodVisitor</code>,首先是<code>visitCode</code>函数，很简单就是为了模拟本地变量表和操作数栈的变化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="comment">//非静态方法，第一个局部变量应该为对象实例this</span></span><br><span class="line">    <span class="comment">//添加到本地变量表集合</span></span><br><span class="line">    setLocalTaint(localIndex, argIndex);</span><br><span class="line">    localIndex += <span class="number">1</span>;</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">    <span class="comment">//判断参数类型，得出变量占用空间大小，然后存储</span></span><br><span class="line">    setLocalTaint(localIndex, argIndex);</span><br><span class="line">    localIndex += argType.getSize();</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后的visitInsn方法(每当访问无操作数的指令，例如nop，duo等等，ASM都会调用这个方法，这里我们只需要关注返回值的部分lol)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitInsn</span><span class="params">(<span class="keyword">int</span> opcode)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">switch</span>(opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.IRETURN:<span class="comment">//从当前方法返回int</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.FRETURN:<span class="comment">//从当前方法返回float</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.ARETURN:<span class="comment">//从当前方法返回对象引用</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">0</span>));<span class="comment">//栈空间从内存高位到低位分配空间</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.LRETURN:<span class="comment">//从当前方法返回long</span></span><br><span class="line">        <span class="keyword">case</span> Opcodes.DRETURN:<span class="comment">//从当前方法返回double</span></span><br><span class="line">            returnTaint.addAll(getStackTaint(<span class="number">1</span>));</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.RETURN:<span class="comment">//从当前方法返回void</span></span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitInsn(opcode);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>之后还有个重要的就是<code>visitMethodInsn</code>(在方法体内，调用了其他方法，都会触发这个方法的调用)，这里逻辑也不难但是为了梳理逻辑这里先不谈，之后我们以开题提到的代码来做讲解</p><p>首先可以看到逆拓扑排序的结果以及可被污染的位置，<img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/13.png"></p><p>那么具体跟入这个过程分析</p><p>第一步，首先是对<code>C.method3</code>进行观察，节约纸张不废话，首先是到<code>gadgetinspector.PassthroughDiscovery.PassthroughDataflowClassVisitor#visitMethod</code>筛选目标类，之后传入到<code>PassthroughDataflowMethodVisitor</code>当中做进一步的观察，由于method3方法体比较简单，只是返回传入的参数</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">C</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method3</span><span class="params">(String param)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>由于在方法体内字节码操作了变量，因此会调用<code>visitVarInsn</code>，也就是在<code>gadgetinspector.TaintTrackingMethodVisitor#visitVarInsn</code>，在这里返回变量触发了aload操作指令，这里会将返回参数对应的本地变量推送至栈顶</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/14.png"></p><p>之后对应的ARETURN指令会触发调用<code>gadgetinspector.PassthroughDiscovery.PassthroughDataflowMethodVisitor#visitInsn</code>，这里将污染的变量保存到<code>returnTaint</code>变量当中，这里返回long和double的和上面不一样主要是因为它们占两个位置</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/15.png"></p><p>至此我们的第一步method3也就结束了，之后就是将其缓存到passthroughDataflow当中</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/16.png"></p><p>接下来第二步，也就是调用<code>B.method2</code>方法，这个稍微复杂一点，结合对应的汇编来理解呗</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public java.lang.String method2(java.lang.String);</span><br><span class="line">  Code:</span><br><span class="line">     0: new           #2                  // class yyds/C</span><br><span class="line">     3: dup</span><br><span class="line">     4: invokespecial #3                  // Method yyds/C.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">     7: aload_1</span><br><span class="line">     8: invokevirtual #4                  // Method yyds/C.method3:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">    11: areturn</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>跳开第一步new，之后dup会触发<code>gadgetinspector.TaintTrackingMethodVisitor#visitInsn</code>，做的操作也很easy，可能觉得这个很不可思议很难理解，dup指令部分可以拉到最下面看看题外话部分呢</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">case</span> Opcodes.DUP:</span><br><span class="line">  push(get(<span class="number">0</span>));</span><br><span class="line">  <span class="keyword">break</span>;</span><br></pre></td></tr></table></figure><p>之后INVOKESPECIAL会触发<code>visitMethodInsn</code>，当然肉眼可知实例化C的时候与我们无关没啥好康的，之后又是<code>aload_1</code>去触发visitVarInsn的过程，这里逻辑类似我们第一步讲的那样没啥好说的呗，之后又是<code>invokevirtual</code>触发<code>visitMethodInsn</code>的调用也就是<code>new C().method3()</code>中调用方法3的过程，虽然结合注释也是能看懂的这里也简单说说</p><p>首先获取method参数类型，由于是非静态方法会进入if条件<img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/17.png"></p><p>之后构造了污染参数集合，for循环当中根据参数类型大小，从栈底获取入参，参数入栈是从右到左的</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/18.png"></p><p>由于不是构造函数，会新建一个HashSet用于保存污染参数的返回值</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/19.png"></p><p>之后判断是否和同一方法体内的其它方法返回值关联，有关联则添加到栈底，等待执行return时保存</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/20.png"></p><p>至此我们也得到了我们可以污染B.method2，控制返回值</p><p>之后A.method1同C.method3就不再重复，最后分析的是main方法的入参args是否会污染到其返回值，也其实差不多，没必要再浪费笔墨了，看看下面反汇编代码即可，有兴趣可以自己更入具体过程看看</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">   0: new           #2                  // class yyds/A</span><br><span class="line">   3: dup</span><br><span class="line">   4: invokespecial #3                  // Method yyds/A.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   7: aload_1</span><br><span class="line">   8: invokevirtual #4                  // Method yyds/A.method1:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  11: astore_2</span><br><span class="line">  12: new           #5                  // class yyds/B</span><br><span class="line">  15: dup</span><br><span class="line">  16: invokespecial #6                  // Method yyds/B.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">  19: aload_2</span><br><span class="line">  20: invokevirtual #7                  // Method yyds/B.method2:(Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  23: areturn</span><br></pre></td></tr></table></figure><p>至此我们得到了如下的结果</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">yyds/<span class="function">C	<span class="title">method3</span>	<span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>;	<span class="number">1</span>,</span><br><span class="line">yyds/<span class="function">B	<span class="title">method2</span>	<span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>;	<span class="number">1</span>,</span><br><span class="line">yyds/<span class="function">A	<span class="title">method1</span>	<span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>;	<span class="number">1</span>,</span><br><span class="line">yyds/<span class="function">Main	<span class="title">main</span>	<span class="params">(Ljava/lang/String;)</span>Ljava/lang/String</span>;	<span class="number">1</span>,</span><br></pre></td></tr></table></figure><h3 id="CallGraphDiscovery"><a href="#CallGraphDiscovery" class="headerlink" title="CallGraphDiscovery"></a>CallGraphDiscovery</h3><p>这个类主要是为了检查子方法的参数是否可以被父方法的参数所影响</p><p>也是从创宇当中的例子开始</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> MyObject obj;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">parentMethod</span><span class="params">(Object arg)</span></span>&#123;</span><br><span class="line">  ...</span><br><span class="line">    TestObject obj1 = <span class="keyword">new</span> TestObject();</span><br><span class="line">  Object obj2 = obj1.childMethod1(arg);</span><br><span class="line">  <span class="keyword">this</span>.obj.childMethod(obj2); </span><br><span class="line">  ...</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>其中如果没有生成passthrough数据流操作，就无法判断childMethod1的返回值是否会受到参数arg的影响，也就无法继续判断parentMethod的arg参数与子方法MyObject.childmethod的参数传递关系</p><p>也是先看原作者的例子以及创宇的师傅的原文帮助理解</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/21.png-w331s"></p><p>AbstractTableModel$ff19274a.hashcode与子方法IFn.invoke：</p><ul><li>AbstractTableModel$ff19274a.hashcode的this(0参)传递给了IFn.invoke的1参，表示为0-&gt;IFn.invoke()@1</li><li>由于f是通过this.__clojureFnMap(0参)获取的，而f又为IFn.invoke()的this(0参)，即AbstractTableModel$ff19274a.hashcode的0参传递给了IFn.invoke的0参，表示为0-&gt;IFn.invoke()@0</li></ul><p>FnCompose.invoke与子方法IFn.invoke：</p><ul><li>FnCompose.invoked的arg(1参)传递给了IFn.invoke的1参，表示为1-&gt;IFn.invoke()@1</li><li>f1为FnCompose的属性(this，0参)，被做为了IFn.invoke的this(0参数)传递，表示为0-&gt;IFn.invoke()@1</li><li>f1.invoke(arg)做为一个整体被当作1参传递给了IFn.invoke，由于f1在序列化时我们可以控制具体是IFn的哪个实现类，所以具体调用哪个实现类的invoke也相当于能够控制，即f1.invoke(arg)这个整体可以视为0参数传递给了IFn.invoke的1参(这里只是进行的简单猜测，具体实现在字节码分析中，可能也体现了作者说的合理的风险判断吧)，表示为0-&gt;IFn.invoke()@1</li></ul><p>好吧返回正题，来到<code>gadgetinspector.CallGraphDiscovery#discover</code></p><p>会遍历每一个class，并传入<code>ModelGeneratorClassVisitor</code>进行观察，一样的这里加点代码跳过对构造函数的观察</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/22.png"></p><p>首先是对B类进行观察，还是再列一次反汇编代码</p><pre><code>Code:
   0: new           #2                  // class yyds/C
   3: dup
   4: invokespecial #3                  // Method yyds/C.&quot;&lt;init&gt;&quot;:()V
   7: aload_1
   8: invokevirtual #4                  // Method yyds/C.method3:(Ljava/lang/String;)Ljava/lang/String;
  11: areturn
</code></pre><p>长话短说，万物之源肯定还是visitCode，可以看到对于对于非静态方法会额外多一个arg0，不需要理解，本来Java底层就是这样子处理滴</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitCode</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">super</span>.visitCode();</span><br><span class="line"></span><br><span class="line">  <span class="keyword">int</span> localIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">int</span> argIndex = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">//使用arg前缀来表示方法入参，后续用于判断是否为目标调用方法的入参</span></span><br><span class="line">  <span class="keyword">if</span> ((<span class="keyword">this</span>.access &amp; Opcodes.ACC_STATIC) == <span class="number">0</span>) &#123;</span><br><span class="line">    setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">    localIndex += <span class="number">1</span>;</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">for</span> (Type argType : Type.getArgumentTypes(desc)) &#123;</span><br><span class="line">    setLocalTaint(localIndex, <span class="string">&quot;arg&quot;</span> + argIndex);</span><br><span class="line">    localIndex += argType.getSize();</span><br><span class="line">    argIndex += <span class="number">1</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>根据汇编由于会调用到<code>invokevirtual</code>,最终会触发<code>gadgetinspector.CallGraphDiscovery.ModelGeneratorMethodVisitor#visitMethodInsn</code>的调用，这里面就会记录最终结果，在代码当中有一些简单的过滤，比如这个arg，就是为了保证参数为当前方法的入参</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/23.png"></p><p>之后便会在参数discoveredCalls当中记录参数流动关系</p><p><img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/24.png"></p><p>当然后面才发现这里还有一个细节的点，我们加强难度，如果代码改为这样，可以看到在上面基础上只是加了个成员变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> yyds;</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> java.io.IOException;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">Test</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> String name;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String[] args)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">main</span><span class="params">(String args)</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">        <span class="keyword">new</span> AA().method1(args, name);</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">AA</span> </span>&#123;</span><br><span class="line">    <span class="function"><span class="keyword">public</span> String <span class="title">method1</span><span class="params">(String param, String param2)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> param + param2;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>看看他的反汇编</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">Code:</span><br><span class="line">   0: new           #2                  // class yyds/AA</span><br><span class="line">   3: dup</span><br><span class="line">   4: invokespecial #3                  // Method yyds/AA.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">   7: aload_1</span><br><span class="line">   8: aload_0</span><br><span class="line">   9: getfield      #4                  // Field name:Ljava/lang/String;</span><br><span class="line">  12: invokevirtual #5                  // Method yyds/AA.method1:(Ljava/lang/String;Ljava/lang/String;)Ljava/lang/String;</span><br><span class="line">  15: pop</span><br><span class="line">  16: return</span><br></pre></td></tr></table></figure><p>其实和上面分析过程差不多的，唯一多了个区别就是多了个汇编指令<code>getfield</code>的调用，也因此会触发<code>visitFieldInsn</code>，我们具体来看看<code>gadgetinspector.CallGraphDiscovery.ModelGeneratorMethodVisitor#visitFieldInsn</code>，其实就是判断字段是否是transient的，逻辑也很简单，看注释即可</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">visitFieldInsn</span><span class="params">(<span class="keyword">int</span> opcode, String owner, String name, String desc)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">switch</span> (opcode) &#123;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETSTATIC:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTSTATIC:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.GETFIELD:<span class="comment">//入操作栈</span></span><br><span class="line">            Type type = Type.getType(desc);</span><br><span class="line">            <span class="keyword">if</span> (type.getSize() == <span class="number">1</span>) &#123;</span><br><span class="line">                Boolean isTransient = <span class="keyword">null</span>;</span><br><span class="line"></span><br><span class="line">                <span class="comment">// If a field type could not possibly be serialized, it&#x27;s effectively transient</span></span><br><span class="line">                <span class="keyword">if</span> (!couldBeSerialized(serializableDecider, inheritanceMap, <span class="keyword">new</span> ClassReference.Handle(type.getInternalName()))) &#123;</span><br><span class="line">                    isTransient = Boolean.TRUE;</span><br><span class="line">                &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                    ClassReference clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(owner));</span><br><span class="line">                    <span class="keyword">while</span> (clazz != <span class="keyword">null</span>) &#123;</span><br><span class="line">                        <span class="keyword">for</span> (ClassReference.Member member : clazz.getMembers()) &#123;</span><br><span class="line">                            <span class="keyword">if</span> (member.getName().equals(name)) &#123;</span><br><span class="line">                                isTransient = (member.getModifiers() &amp; Opcodes.ACC_TRANSIENT) != <span class="number">0</span>;</span><br><span class="line">                                <span class="keyword">break</span>;</span><br><span class="line">                            &#125;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="keyword">if</span> (isTransient != <span class="keyword">null</span>) &#123;</span><br><span class="line">                            <span class="keyword">break</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        clazz = classMap.get(<span class="keyword">new</span> ClassReference.Handle(clazz.getSuperClass()));</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line"></span><br><span class="line">                Set&lt;String&gt; newTaint = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                <span class="keyword">if</span> (!Boolean.TRUE.equals(isTransient)) &#123;</span><br><span class="line">                    <span class="keyword">for</span> (String s : getStackTaint(<span class="number">0</span>)) &#123;</span><br><span class="line">                        newTaint.add(s + <span class="string">&quot;.&quot;</span> + name);</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">                <span class="comment">//在调用方法前，都会先入栈，作为参数</span></span><br><span class="line">                setStackTaint(<span class="number">0</span>, newTaint);</span><br><span class="line">                <span class="keyword">return</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">case</span> Opcodes.PUTFIELD:</span><br><span class="line">            <span class="keyword">break</span>;</span><br><span class="line">        <span class="keyword">default</span>:</span><br><span class="line">            <span class="keyword">throw</span> <span class="keyword">new</span> IllegalStateException(<span class="string">&quot;Unsupported opcode: &quot;</span> + opcode);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">super</span>.visitFieldInsn(opcode, owner, name, desc);</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure><p>这一部分也算完结了</p><h3 id="SourceDiscovery"><a href="#SourceDiscovery" class="headerlink" title="SourceDiscovery"></a>SourceDiscovery</h3><p>在gadgetinspector中，存在着多个SourceDiscovery的实现，有jackson的，java原生序列化的等等，我这里主要以jackson的SourceDiscovery实现开始分析</p><p>首先在SourceDiscovery抽象类的discover当中，先是加载了所有的类、方法、继承实现关系的数据</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> IOException </span>&#123;</span><br><span class="line">  Map&lt;ClassReference.Handle, ClassReference&gt; classMap = DataLoader.loadClasses();</span><br><span class="line">  Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line">  InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line"></span><br><span class="line">  Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">  <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">    MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">    <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">      Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">      graphCalls.add(graphCall);</span><br><span class="line">      graphCallMap.put(caller, graphCalls);</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">      graphCallMap.get(caller).add(graphCall);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  discover(classMap, methodMap, inheritanceMap, graphCallMap);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>接下来调用discover在实现类<code>gadgetinspector.javaserial.SimpleSourceDiscovery#discover</code>,主要是收集可用的source，逻辑也很简单了</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">(Map&lt;ClassReference.Handle, ClassReference&gt; classMap,</span></span></span><br><span class="line"><span class="params"><span class="function">                         Map&lt;MethodReference.Handle, MethodReference&gt; methodMap,</span></span></span><br><span class="line"><span class="params"><span class="function">                         InheritanceMap inheritanceMap)</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> SerializableDecider serializableDecider = <span class="keyword">new</span> SimpleSerializableDecider(inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;finalize&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// If a class implements readObject, the ObjectInputStream passed in is considered tainted</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;readObject&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/io/ObjectInputStream;)V&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using the proxy trick, anything extending serializable and invocation handler is tainted.</span></span><br><span class="line">        <span class="keyword">for</span> (ClassReference.Handle clazz : classMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(clazz))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(clazz, <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;java/lang/reflect/InvocationHandler&quot;</span>))) &#123;</span><br><span class="line">                MethodReference.Handle method = <span class="keyword">new</span> MethodReference.Handle(</span><br><span class="line">                        clazz, <span class="string">&quot;invoke&quot;</span>, <span class="string">&quot;(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;)Ljava/lang/Object;&quot;</span>);</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// hashCode() or equals() are accessible entry points using standard tricks of putting those objects</span></span><br><span class="line">        <span class="comment">// into a HashMap.</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))) &#123;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;hashCode&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;()I&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                &#125;</span><br><span class="line">                <span class="keyword">if</span> (method.getName().equals(<span class="string">&quot;equals&quot;</span>) &amp;&amp; method.getDesc().equals(<span class="string">&quot;(Ljava/lang/Object;)Z&quot;</span>)) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">// Using a comparator proxy, we can jump into the call() / doCall() method of any groovy Closure and all the</span></span><br><span class="line">        <span class="comment">// args are tainted.</span></span><br><span class="line">        <span class="comment">// https://github.com/frohoff/ysoserial/blob/master/src/main/java/ysoserial/payloads/Groovy1.java</span></span><br><span class="line">        <span class="keyword">for</span> (MethodReference.Handle method : methodMap.keySet()) &#123;</span><br><span class="line">            <span class="keyword">if</span> (Boolean.TRUE.equals(serializableDecider.apply(method.getClassReference()))</span><br><span class="line">                    &amp;&amp; inheritanceMap.isSubclassOf(method.getClassReference(), <span class="keyword">new</span> ClassReference.Handle(<span class="string">&quot;groovy/lang/Closure&quot;</span>))</span><br><span class="line">                    &amp;&amp; (method.getName().equals(<span class="string">&quot;call&quot;</span>) || method.getName().equals(<span class="string">&quot;doCall&quot;</span>))) &#123;</span><br><span class="line"></span><br><span class="line">                addDiscoveredSource(<span class="keyword">new</span> Source(method, <span class="number">0</span>));</span><br><span class="line">                Type[] methodArgs = Type.getArgumentTypes(method.getDesc());</span><br><span class="line">                <span class="keyword">for</span> (<span class="keyword">int</span> i = <span class="number">0</span>; i &lt; methodArgs.length; i++) &#123;</span><br><span class="line">                    addDiscoveredSource(<span class="keyword">new</span> Source(method, i + <span class="number">1</span>));</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h3 id="GadgetChainDiscovery"><a href="#GadgetChainDiscovery" class="headerlink" title="GadgetChainDiscovery"></a>GadgetChainDiscovery</h3><p>接下来就是最重要的生成利用链的部分了，这部分整合了上面所有的信息，会遍历全部的source，并在callgraph.dat中递归查找所有可以继续传递污点参数的子方法调用，直至遇到sink标记的方法，看看discover即可，带了备注</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">discover</span><span class="params">()</span> <span class="keyword">throws</span> Exception </span>&#123;</span><br><span class="line">        <span class="comment">//方法信息</span></span><br><span class="line">        Map&lt;MethodReference.Handle, MethodReference&gt; methodMap = DataLoader.loadMethods();</span><br><span class="line"></span><br><span class="line">        InheritanceMap inheritanceMap = InheritanceMap.load();</span><br><span class="line">        <span class="comment">//得到方法的所有子类方法实现</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; methodImplMap = InheritanceDeriver.getAllMethodImplementations(</span><br><span class="line">                inheritanceMap, methodMap);</span><br><span class="line"></span><br><span class="line">        <span class="keyword">final</span> ImplementationFinder implementationFinder = config.getImplementationFinder(</span><br><span class="line">                methodMap, methodImplMap, inheritanceMap);</span><br><span class="line"></span><br><span class="line">        <span class="comment">//写入文件</span></span><br><span class="line">        <span class="keyword">try</span> (Writer writer = Files.newBufferedWriter(Paths.get(<span class="string">&quot;methodimpl.dat&quot;</span>))) &#123;</span><br><span class="line">            <span class="keyword">for</span> (Map.Entry&lt;MethodReference.Handle, Set&lt;MethodReference.Handle&gt;&gt; entry : methodImplMap.entrySet()) &#123;</span><br><span class="line">                writer.write(entry.getKey().getClassReference().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getName());</span><br><span class="line">                writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                writer.write(entry.getKey().getDesc());</span><br><span class="line">                writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                <span class="keyword">for</span> (MethodReference.Handle method : entry.getValue()) &#123;</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getClassReference().getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getName());</span><br><span class="line">                    writer.write(<span class="string">&quot;\t&quot;</span>);</span><br><span class="line">                    writer.write(method.getDesc());</span><br><span class="line">                    writer.write(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="comment">//方法调用map，key为父方法，value为子方法与父方法参数传递关系</span></span><br><span class="line">        Map&lt;MethodReference.Handle, Set&lt;GraphCall&gt;&gt; graphCallMap = <span class="keyword">new</span> HashMap&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (GraphCall graphCall : DataLoader.loadData(Paths.get(<span class="string">&quot;callgraph.dat&quot;</span>), <span class="keyword">new</span> GraphCall.Factory())) &#123;</span><br><span class="line">            MethodReference.Handle caller = graphCall.getCallerMethod();</span><br><span class="line">            <span class="keyword">if</span> (!graphCallMap.containsKey(caller)) &#123;</span><br><span class="line">                Set&lt;GraphCall&gt; graphCalls = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">                graphCalls.add(graphCall);</span><br><span class="line">                graphCallMap.put(caller, graphCalls);</span><br><span class="line">            &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                graphCallMap.get(caller).add(graphCall);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="comment">//exploredMethods保存在调用链从查找过程中已经访问过的方法节点，methodsToExplore保存调用链</span></span><br><span class="line">        Set&lt;GadgetChainLink&gt; exploredMethods = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        LinkedList&lt;GadgetChain&gt; methodsToExplore = <span class="keyword">new</span> LinkedList&lt;&gt;();</span><br><span class="line">        <span class="keyword">for</span> (Source source : DataLoader.loadData(Paths.get(<span class="string">&quot;sources.dat&quot;</span>), <span class="keyword">new</span> Source.Factory())) &#123;</span><br><span class="line">            GadgetChainLink srcLink = <span class="keyword">new</span> GadgetChainLink(source.getSourceMethod(), source.getTaintedArgIndex());</span><br><span class="line">            <span class="keyword">if</span> (exploredMethods.contains(srcLink)) &#123;</span><br><span class="line">                <span class="keyword">continue</span>;</span><br><span class="line">            &#125;</span><br><span class="line">            methodsToExplore.add(<span class="keyword">new</span> GadgetChain(Arrays.asList(srcLink)));</span><br><span class="line">            exploredMethods.add(srcLink);</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">long</span> iteration = <span class="number">0</span>;</span><br><span class="line">        Set&lt;GadgetChain&gt; discoveredGadgets = <span class="keyword">new</span> HashSet&lt;&gt;();</span><br><span class="line">        <span class="comment">//使用广度优先搜索所有从source到sink的调用链</span></span><br><span class="line">        <span class="keyword">while</span> (methodsToExplore.size() &gt; <span class="number">0</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span> ((iteration % <span class="number">1000</span>) == <span class="number">0</span>) &#123;</span><br><span class="line">                LOGGER.info(<span class="string">&quot;Iteration &quot;</span> + iteration + <span class="string">&quot;, Search space: &quot;</span> + methodsToExplore.size());</span><br><span class="line">            &#125;</span><br><span class="line">            iteration += <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line">            GadgetChain chain = methodsToExplore.pop();</span><br><span class="line">            GadgetChainLink lastLink = chain.links.get(chain.links.size()-<span class="number">1</span>);</span><br><span class="line">            <span class="comment">//获取当前节点方法所有子方法与当前节点方法参数传递关系</span></span><br><span class="line">            Set&lt;GraphCall&gt; methodCalls = graphCallMap.get(lastLink.method);</span><br><span class="line">            <span class="keyword">if</span> (methodCalls != <span class="keyword">null</span>) &#123;</span><br><span class="line">                <span class="keyword">for</span> (GraphCall graphCall : methodCalls) &#123;</span><br><span class="line">                    <span class="comment">//如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过</span></span><br><span class="line">                    <span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex) &#123;</span><br><span class="line">                        <span class="keyword">continue</span>;</span><br><span class="line">                    &#125;</span><br><span class="line"></span><br><span class="line">                    Set&lt;MethodReference.Handle&gt; allImpls = implementationFinder.getImplementations(graphCall.getTargetMethod());</span><br><span class="line"></span><br><span class="line">                    <span class="keyword">for</span> (MethodReference.Handle methodImpl : allImpls) &#123;</span><br><span class="line">                        GadgetChainLink newLink = <span class="keyword">new</span> GadgetChainLink(methodImpl, graphCall.getTargetArgIndex());</span><br><span class="line">                        <span class="comment">//如果新方法已近被访问过了，则跳过,这里能减少开销。但是这一步跳过会使其他链/分支链经过此节点时，由于已经此节点被访问过了，链会在这里断掉。那么如果这个条件去掉就能实现找到所有链了吗？这里去掉会遇到环状问题，造成路径无限增加</span></span><br><span class="line">                        <span class="keyword">if</span> (exploredMethods.contains(newLink)) &#123;</span><br><span class="line">                            <span class="keyword">continue</span>;</span><br><span class="line">                        &#125;</span><br><span class="line">                        <span class="comment">//新节点与之前的链组成新链</span></span><br><span class="line">                        GadgetChain newChain = <span class="keyword">new</span> GadgetChain(chain, newLink);</span><br><span class="line">                        <span class="comment">//如果到达了sink，则加入discoveredGadgets</span></span><br><span class="line">                        <span class="keyword">if</span> (isSink(methodImpl, graphCall.getTargetArgIndex(), inheritanceMap)) &#123;</span><br><span class="line">                            discoveredGadgets.add(newChain);</span><br><span class="line">                        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">                            methodsToExplore.add(newChain);</span><br><span class="line">                            exploredMethods.add(newLink);</span><br><span class="line">                        &#125;</span><br><span class="line">                    &#125;</span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">try</span> (OutputStream outputStream = Files.newOutputStream(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">             Writer writer = <span class="keyword">new</span> OutputStreamWriter(outputStream, StandardCharsets.UTF_8)) &#123;</span><br><span class="line">            <span class="keyword">for</span> (GadgetChain chain : discoveredGadgets) &#123;</span><br><span class="line">                printGadgetChain(writer, chain);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        System.out.println(Paths.get(<span class="string">&quot;gadget-chains.txt&quot;</span>));</span><br><span class="line">        LOGGER.info(<span class="string">&quot;Found &#123;&#125; gadget chains.&quot;</span>, discoveredGadgets.size());</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>到这里GI的关键逻辑也走完了难点部分也结束了</p><h2 id="题外话"><a href="#题外话" class="headerlink" title="题外话"></a>题外话</h2><h3 id="关于dup指令"><a href="#关于dup指令" class="headerlink" title="关于dup指令"></a>关于dup指令</h3><p>这里我非常好奇java虚拟机里的dup指令的作用，看官方描述是复制栈顶数值并将复制值压入栈顶，很懵逼，但看了<a target="_blank" rel="noopener" href="https://www.jb51.net/article/126349.htm">脚本之家的例子</a>后就完全明白了</p><p>对于类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">ExceptionTest</span></span>&#123;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">void</span> <span class="title">cantBeZero</span><span class="params">(<span class="keyword">int</span> i)</span> <span class="keyword">throws</span> Exception</span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Exception();</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>得到字节码如下</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">0: iload_1</span><br><span class="line">1: ifne     12</span><br><span class="line">4: new      #2         </span><br><span class="line">// class java/lang/Exception</span><br><span class="line">7: dup</span><br><span class="line">8: invokespecial #3         </span><br><span class="line">// Method java/lang/Exception.&quot;&lt;init&gt;&quot;:()V</span><br><span class="line">11: athrow</span><br><span class="line">12: return</span><br></pre></td></tr></table></figure><ol><li><p>其中new指令在java堆上为Exception对象分配内存空间，并将地址压入操作数栈顶；</p></li><li><p>然后dup指令为复制操作数栈顶值，并将其压入栈顶，也就是说此时操作数栈上有连续相同的两个对象地址；</p></li><li><p>invokespecial指令调用实例初始化方法<init>:()V，注意这个方法是一个实例方法，所以需要从操作数栈顶弹出一个this引用，也就是说这一步会弹出一个之前入栈的对象地址；</init></p></li><li><p>athrow指令从操作数栈顶取出一个引用类型的值，并抛出；</p></li><li><p>最后由return指令结束方法</p></li></ol><p>从上面的五个步骤中可以看出，需要从栈顶弹出两个实例对象的引用，这就是为什么会在new指令下面有一个dup指令</p><h3 id="关于CC"><a href="#关于CC" class="headerlink" title="关于CC"></a>关于CC</h3><p>​ 在简单了解完逻辑之后，打算试一试扫描cc组件，但是没有出现任何的结果，于是就做了一些简单的修改，在<code>gadgetinspector.GadgetChainDiscovery#isSink</code>我增加了一条规则直接将<code>org.apache.commons.collections.Transformer#transform</code> 作为 sink</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (method.getClassReference().getName().equals(<span class="string">&quot;org/apache/commons/collections/Transformer&quot;</span>)</span><br><span class="line">    &amp;&amp; method.getName().equals(<span class="string">&quot;transform&quot;</span>)) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">true</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>但是之后发现比如像AnnotationInvocationHandler这样的链，由于LazyMap在之前可能被添加到exploredMethods当中，导致利用链断了，后面自己尝试了下修复bug通过设置记录最大重复分支，但是发现重复利用链太多了，还是顶哦，还好发现了某个大师傅的宝藏仓库，里面对重复以及重复链做了聚合优化</p><p><a target="_blank" rel="noopener" href="https://github.com/5wimming/gadgetinspector/blob/main/src/main/java/gadgetinspector/GadgetChainDiscovery.java">https://github.com/5wimming/gadgetinspector/blob/main/src/main/java/gadgetinspector/GadgetChainDiscovery.java</a></p><p>看了思路后尝试自己修改，最终出来的结果这样看起来更直观666<img src="/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/25.png"></p><p>之后还有其他问题比如像cc当中的有PriorityQueue的链子，由于下面这串代码也会受影响</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//如果当前节点方法的污染参数与当前子方法受父方法参数影响的Index不一致则跳过</span></span><br><span class="line"><span class="keyword">if</span> (graphCall.getCallerArgIndex() != lastLink.taintedArgIndex ) &#123;</span><br><span class="line">    <span class="keyword">continue</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>暂时的解决方案就是注释掉这一行来获得所有利用链，但是就是太慢了，而且人工审计工作量更大</p><p>总之GI真的太笨重了，这里主要是学习原理也不想深入改bug了</p><h2 id="参考文章"><a href="#参考文章" class="headerlink" title="参考文章"></a>参考文章</h2><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7058">https://xz.aliyun.com/t/7058</a></p><p><a target="_blank" rel="noopener" href="https://cloud.tencent.com/developer/article/1633445">https://cloud.tencent.com/developer/article/1633445</a></p><p><a target="_blank" rel="noopener" href="https://www.cnblogs.com/tr1ple/p/12800859.html">https://www.cnblogs.com/tr1ple/p/12800859.html</a></p><p><a target="_blank" rel="noopener" href="https://www.jianshu.com/p/dfdfdb455d8c">https://www.jianshu.com/p/dfdfdb455d8c</a></p><p><a target="_blank" rel="noopener" href="https://xz.aliyun.com/t/7058">https://xz.aliyun.com/t/7058</a></p><p><a target="_blank" rel="noopener" href="https://paper.seebug.org/1034/">https://paper.seebug.org/1034/</a></p></div></article><div class="blog-post-comments"><div id="utterances_thread"><noscript>Please enable JavaScript to view the comments.</noscript></div></div><div id="footer-post-container"><div id="footer-post"><div id="nav-footer" style="display:none"><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Topics</a></li><li><a href="/search/">Search</a></li><li><a href="/about/">About</a></li><li><a href="/link/">Friends</a></li></ul></div><div id="toc-footer" style="display:none"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90"><span class="toc-number">1.</span> <span class="toc-text">GadgetInspector源码分析</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%89%8D%E7%BD%AE%E5%BA%9F%E8%AF%9D"><span class="toc-number">1.1.</span> <span class="toc-text">前置废话</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#ASM%E9%83%A8%E5%88%86"><span class="toc-number">1.2.</span> <span class="toc-text">ASM部分</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%A8%A1%E6%8B%9FJVM%E6%A0%88%E5%B8%A7%E5%8F%98%E5%8C%96"><span class="toc-number">1.2.1.</span> <span class="toc-text">模拟JVM栈帧变化</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#ClassVisitor"><span class="toc-number">1.2.2.</span> <span class="toc-text">ClassVisitor</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#MethodVisitor"><span class="toc-number">1.2.3.</span> <span class="toc-text">MethodVisitor</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%88%86%E6%9E%90"><span class="toc-number">1.3.</span> <span class="toc-text">分析</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#MethodDiscovery"><span class="toc-number">1.3.1.</span> <span class="toc-text">MethodDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#PassthroughDiscovery"><span class="toc-number">1.3.2.</span> <span class="toc-text">PassthroughDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#CallGraphDiscovery"><span class="toc-number">1.3.3.</span> <span class="toc-text">CallGraphDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#SourceDiscovery"><span class="toc-number">1.3.4.</span> <span class="toc-text">SourceDiscovery</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#GadgetChainDiscovery"><span class="toc-number">1.3.5.</span> <span class="toc-text">GadgetChainDiscovery</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E9%A2%98%E5%A4%96%E8%AF%9D"><span class="toc-number">1.4.</span> <span class="toc-text">题外话</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8Edup%E6%8C%87%E4%BB%A4"><span class="toc-number">1.4.1.</span> <span class="toc-text">关于dup指令</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E4%BA%8ECC"><span class="toc-number">1.4.2.</span> <span class="toc-text">关于CC</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%8F%82%E8%80%83%E6%96%87%E7%AB%A0"><span class="toc-number">1.5.</span> <span class="toc-text">参考文章</span></a></li></ol></li></ol></div><div id="share-footer" style="display:none"><ul><li><a class="icon" target="_blank" rel="noopener" href="http://www.facebook.com/sharer.php?u=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fab fa-facebook fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://twitter.com/share?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&text=GadgetInspector源码分析"><i class="fab fa-twitter fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.linkedin.com/shareArticle?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-linkedin fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://pinterest.com/pin/create/bookmarklet/?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&is_video=false&description=GadgetInspector源码分析"><i class="fab fa-pinterest fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" href="mailto:?subject=GadgetInspector源码分析&body=Check out this article: https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/"><i class="fa-solid fa-envelope fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://getpocket.com/save?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-get-pocket fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://reddit.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-reddit fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.stumbleupon.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-stumbleupon fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://digg.com/submit?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&title=GadgetInspector源码分析"><i class="fab fa-digg fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="http://www.tumblr.com/share/link?url=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&name=GadgetInspector源码分析&description="><i class="fab fa-tumblr fa-lg" aria-hidden="true"></i></a></li><li><a class="icon" target="_blank" rel="noopener" href="https://news.ycombinator.com/submitlink?u=https://y4tacker.github.io/2022/05/09/year/2022/5/GadgetInspector%E6%BA%90%E7%A0%81%E5%88%86%E6%9E%90/&t=GadgetInspector源码分析"><i class="fab fa-hacker-news fa-lg" aria-hidden="true"></i></a></li></ul></div><div id="actions-footer"><a id="menu" class="icon" href="#" onclick='return $("#nav-footer").toggle(),!1'><i class="fa-solid fa-bars fa-lg" aria-hidden="true"></i> Menu</a> <a id="toc" class="icon" href="#" onclick='return $("#toc-footer").toggle(),!1'><i class="fa-solid fa-list fa-lg" aria-hidden="true"></i> TOC</a> <a id="share" class="icon" href="#" onclick='return $("#share-footer").toggle(),!1'><i class="fa-solid fa-share-alt fa-lg" aria-hidden="true"></i> Share</a> <a id="top" style="display:none" class="icon" href="#" onclick='$("html, body").animate({scrollTop:0},"fast")'><i class="fa-solid fa-chevron-up fa-lg" aria-hidden="true"></i> Top</a></div></div></div><footer id="footer"><div class="footer-left">Copyright &copy; 2016-2025 Y4tacker</div><div class="footer-right"><nav><ul><li><a href="/">Home</a></li><li><a href="/archives/">Writing</a></li><li><a href="/tags/">Topics</a></li><li><a href="/search/">Search</a></li><li><a href="/about/">About</a></li><li><a href="/link/">Friends</a></li></ul><ul><span id="busuanzi_container_site_pv">本站总访问量<span id="busuanzi_value_site_pv"></span>次 </span><span class="post-meta-divider">|</span> <span id="busuanzi_container_site_uv" style="display:none">本站访客数<span id="busuanzi_value_site_uv"></span>人</span><script async src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></ul></nav></div></footer></div><link rel="preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/6.4.0/css/all.min.css" crossorigin="anonymous" onload='this.onload=null,this.rel="stylesheet"'><script src="https://cdnjs.cloudflare.com/ajax/libs/jquery/3.6.0/jquery.min.js" crossorigin="anonymous"></script><script src="https://cdnjs.cloudflare.com/ajax/libs/clipboard.js/2.0.7/clipboard.min.js" crossorigin="anonymous"></script><script type="text/javascript">$(function() {
    // copy-btn HTML
    var btn = "<span class=\"btn-copy tooltipped tooltipped-sw\" aria-label=\"Copy to clipboard!\">";
    btn += '<i class="fa-regular fa-clone"></i>';
    btn += '</span>';
    // mount it!
    $(".highlight table").before(btn);
    var clip = new ClipboardJS('.btn-copy', {
      text: function(trigger) {
        return Array.from(trigger.nextElementSibling.querySelectorAll('.code')).reduce((str,it)=>str+it.innerText+'\n','')
      }
    });
    clip.on('success', function(e) {
      e.trigger.setAttribute('aria-label', "Copied!");
      e.clearSelection();
    })
  })</script><script src="/js/main.js"></script><script type="text/javascript">var _hmt=_hmt||[];!function(){var e=document.createElement("script");e.src="https://hm.baidu.com/hm.js?e6d8a6d6d91254d9108e469862e88709";var t=document.getElementsByTagName("script")[0];t.parentNode.insertBefore(e,t)}()</script><script type="text/javascript">var utterances_repo="Y4tacker/y4tacker.github.io",utterances_issue_term="pathname",utterances_label="Comment",utterances_theme="github-dark";!function(){var t=document.createElement("script");t.src="https://utteranc.es/client.js",t.setAttribute("repo",utterances_repo),t.setAttribute("issue-term","pathname"),t.setAttribute("label",utterances_label),t.setAttribute("theme",utterances_theme),t.setAttribute("crossorigin","anonymous"),t.async=!0,document.getElementById("utterances_thread").appendChild(t)}()</script></body></html>